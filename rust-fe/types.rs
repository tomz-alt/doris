// Autogenerated by Thrift Compiler (0.22.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(dead_code)]
#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![allow(clippy::too_many_arguments, clippy::type_complexity, clippy::vec_box, clippy::wrong_self_convention)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;

use thrift::OrderedFloat;
use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSerializable, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TStorageType(pub i32);

impl TStorageType {
  pub const ROW: TStorageType = TStorageType(0);
  pub const COLUMN: TStorageType = TStorageType(1);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::ROW,
    Self::COLUMN,
  ];
}

impl TSerializable for TStorageType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TStorageType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TStorageType::from(enum_value))
  }
}

impl From<i32> for TStorageType {
  fn from(i: i32) -> Self {
    match i {
      0 => TStorageType::ROW,
      1 => TStorageType::COLUMN,
      _ => TStorageType(i)
    }
  }
}

impl From<&i32> for TStorageType {
  fn from(i: &i32) -> Self {
    TStorageType::from(*i)
  }
}

impl From<TStorageType> for i32 {
  fn from(e: TStorageType) -> i32 {
    e.0
  }
}

impl From<&TStorageType> for i32 {
  fn from(e: &TStorageType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TStorageMedium(pub i32);

impl TStorageMedium {
  pub const HDD: TStorageMedium = TStorageMedium(0);
  pub const SSD: TStorageMedium = TStorageMedium(1);
  pub const S3: TStorageMedium = TStorageMedium(2);
  pub const REMOTE_CACHE: TStorageMedium = TStorageMedium(3);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::HDD,
    Self::SSD,
    Self::S3,
    Self::REMOTE_CACHE,
  ];
}

impl TSerializable for TStorageMedium {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TStorageMedium> {
    let enum_value = i_prot.read_i32()?;
    Ok(TStorageMedium::from(enum_value))
  }
}

impl From<i32> for TStorageMedium {
  fn from(i: i32) -> Self {
    match i {
      0 => TStorageMedium::HDD,
      1 => TStorageMedium::SSD,
      2 => TStorageMedium::S3,
      3 => TStorageMedium::REMOTE_CACHE,
      _ => TStorageMedium(i)
    }
  }
}

impl From<&i32> for TStorageMedium {
  fn from(i: &i32) -> Self {
    TStorageMedium::from(*i)
  }
}

impl From<TStorageMedium> for i32 {
  fn from(e: TStorageMedium) -> i32 {
    e.0
  }
}

impl From<&TStorageMedium> for i32 {
  fn from(e: &TStorageMedium) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TVarType(pub i32);

impl TVarType {
  pub const SESSION: TVarType = TVarType(0);
  pub const GLOBAL: TVarType = TVarType(1);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::SESSION,
    Self::GLOBAL,
  ];
}

impl TSerializable for TVarType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TVarType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TVarType::from(enum_value))
  }
}

impl From<i32> for TVarType {
  fn from(i: i32) -> Self {
    match i {
      0 => TVarType::SESSION,
      1 => TVarType::GLOBAL,
      _ => TVarType(i)
    }
  }
}

impl From<&i32> for TVarType {
  fn from(i: &i32) -> Self {
    TVarType::from(*i)
  }
}

impl From<TVarType> for i32 {
  fn from(e: TVarType) -> i32 {
    e.0
  }
}

impl From<&TVarType> for i32 {
  fn from(e: &TVarType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TPrimitiveType(pub i32);

impl TPrimitiveType {
  pub const INVALID_TYPE: TPrimitiveType = TPrimitiveType(0);
  pub const NULL_TYPE: TPrimitiveType = TPrimitiveType(1);
  pub const BOOLEAN: TPrimitiveType = TPrimitiveType(2);
  pub const TINYINT: TPrimitiveType = TPrimitiveType(3);
  pub const SMALLINT: TPrimitiveType = TPrimitiveType(4);
  pub const INT: TPrimitiveType = TPrimitiveType(5);
  pub const BIGINT: TPrimitiveType = TPrimitiveType(6);
  pub const FLOAT: TPrimitiveType = TPrimitiveType(7);
  pub const DOUBLE: TPrimitiveType = TPrimitiveType(8);
  pub const DATE: TPrimitiveType = TPrimitiveType(9);
  pub const DATETIME: TPrimitiveType = TPrimitiveType(10);
  pub const BINARY: TPrimitiveType = TPrimitiveType(11);
  pub const DECIMAL_DEPRACTED: TPrimitiveType = TPrimitiveType(12);
  pub const CHAR: TPrimitiveType = TPrimitiveType(13);
  pub const LARGEINT: TPrimitiveType = TPrimitiveType(14);
  pub const VARCHAR: TPrimitiveType = TPrimitiveType(15);
  pub const HLL: TPrimitiveType = TPrimitiveType(16);
  pub const DECIMALV2: TPrimitiveType = TPrimitiveType(17);
  pub const BITMAP: TPrimitiveType = TPrimitiveType(19);
  pub const ARRAY: TPrimitiveType = TPrimitiveType(20);
  pub const MAP: TPrimitiveType = TPrimitiveType(21);
  pub const STRUCT: TPrimitiveType = TPrimitiveType(22);
  pub const STRING: TPrimitiveType = TPrimitiveType(23);
  pub const ALL: TPrimitiveType = TPrimitiveType(24);
  pub const QUANTILE_STATE: TPrimitiveType = TPrimitiveType(25);
  pub const DATEV2: TPrimitiveType = TPrimitiveType(26);
  pub const DATETIMEV2: TPrimitiveType = TPrimitiveType(27);
  pub const TIMEV2: TPrimitiveType = TPrimitiveType(28);
  pub const DECIMAL32: TPrimitiveType = TPrimitiveType(29);
  pub const DECIMAL64: TPrimitiveType = TPrimitiveType(30);
  pub const DECIMAL128I: TPrimitiveType = TPrimitiveType(31);
  pub const JSONB: TPrimitiveType = TPrimitiveType(32);
  pub const UNSUPPORTED: TPrimitiveType = TPrimitiveType(33);
  pub const VARIANT: TPrimitiveType = TPrimitiveType(34);
  pub const LAMBDA_FUNCTION: TPrimitiveType = TPrimitiveType(35);
  pub const AGG_STATE: TPrimitiveType = TPrimitiveType(36);
  pub const DECIMAL256: TPrimitiveType = TPrimitiveType(37);
  pub const IPV4: TPrimitiveType = TPrimitiveType(38);
  pub const IPV6: TPrimitiveType = TPrimitiveType(39);
  pub const UINT32: TPrimitiveType = TPrimitiveType(40);
  pub const UINT64: TPrimitiveType = TPrimitiveType(41);
  pub const FIXED_LENGTH_OBJECT: TPrimitiveType = TPrimitiveType(42);
  pub const VARBINARY: TPrimitiveType = TPrimitiveType(43);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::INVALID_TYPE,
    Self::NULL_TYPE,
    Self::BOOLEAN,
    Self::TINYINT,
    Self::SMALLINT,
    Self::INT,
    Self::BIGINT,
    Self::FLOAT,
    Self::DOUBLE,
    Self::DATE,
    Self::DATETIME,
    Self::BINARY,
    Self::DECIMAL_DEPRACTED,
    Self::CHAR,
    Self::LARGEINT,
    Self::VARCHAR,
    Self::HLL,
    Self::DECIMALV2,
    Self::BITMAP,
    Self::ARRAY,
    Self::MAP,
    Self::STRUCT,
    Self::STRING,
    Self::ALL,
    Self::QUANTILE_STATE,
    Self::DATEV2,
    Self::DATETIMEV2,
    Self::TIMEV2,
    Self::DECIMAL32,
    Self::DECIMAL64,
    Self::DECIMAL128I,
    Self::JSONB,
    Self::UNSUPPORTED,
    Self::VARIANT,
    Self::LAMBDA_FUNCTION,
    Self::AGG_STATE,
    Self::DECIMAL256,
    Self::IPV4,
    Self::IPV6,
    Self::UINT32,
    Self::UINT64,
    Self::FIXED_LENGTH_OBJECT,
    Self::VARBINARY,
  ];
}

impl TSerializable for TPrimitiveType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TPrimitiveType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TPrimitiveType::from(enum_value))
  }
}

impl From<i32> for TPrimitiveType {
  fn from(i: i32) -> Self {
    match i {
      0 => TPrimitiveType::INVALID_TYPE,
      1 => TPrimitiveType::NULL_TYPE,
      2 => TPrimitiveType::BOOLEAN,
      3 => TPrimitiveType::TINYINT,
      4 => TPrimitiveType::SMALLINT,
      5 => TPrimitiveType::INT,
      6 => TPrimitiveType::BIGINT,
      7 => TPrimitiveType::FLOAT,
      8 => TPrimitiveType::DOUBLE,
      9 => TPrimitiveType::DATE,
      10 => TPrimitiveType::DATETIME,
      11 => TPrimitiveType::BINARY,
      12 => TPrimitiveType::DECIMAL_DEPRACTED,
      13 => TPrimitiveType::CHAR,
      14 => TPrimitiveType::LARGEINT,
      15 => TPrimitiveType::VARCHAR,
      16 => TPrimitiveType::HLL,
      17 => TPrimitiveType::DECIMALV2,
      19 => TPrimitiveType::BITMAP,
      20 => TPrimitiveType::ARRAY,
      21 => TPrimitiveType::MAP,
      22 => TPrimitiveType::STRUCT,
      23 => TPrimitiveType::STRING,
      24 => TPrimitiveType::ALL,
      25 => TPrimitiveType::QUANTILE_STATE,
      26 => TPrimitiveType::DATEV2,
      27 => TPrimitiveType::DATETIMEV2,
      28 => TPrimitiveType::TIMEV2,
      29 => TPrimitiveType::DECIMAL32,
      30 => TPrimitiveType::DECIMAL64,
      31 => TPrimitiveType::DECIMAL128I,
      32 => TPrimitiveType::JSONB,
      33 => TPrimitiveType::UNSUPPORTED,
      34 => TPrimitiveType::VARIANT,
      35 => TPrimitiveType::LAMBDA_FUNCTION,
      36 => TPrimitiveType::AGG_STATE,
      37 => TPrimitiveType::DECIMAL256,
      38 => TPrimitiveType::IPV4,
      39 => TPrimitiveType::IPV6,
      40 => TPrimitiveType::UINT32,
      41 => TPrimitiveType::UINT64,
      42 => TPrimitiveType::FIXED_LENGTH_OBJECT,
      43 => TPrimitiveType::VARBINARY,
      _ => TPrimitiveType(i)
    }
  }
}

impl From<&i32> for TPrimitiveType {
  fn from(i: &i32) -> Self {
    TPrimitiveType::from(*i)
  }
}

impl From<TPrimitiveType> for i32 {
  fn from(e: TPrimitiveType) -> i32 {
    e.0
  }
}

impl From<&TPrimitiveType> for i32 {
  fn from(e: &TPrimitiveType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTypeNodeType(pub i32);

impl TTypeNodeType {
  pub const SCALAR: TTypeNodeType = TTypeNodeType(0);
  pub const ARRAY: TTypeNodeType = TTypeNodeType(1);
  pub const MAP: TTypeNodeType = TTypeNodeType(2);
  pub const STRUCT: TTypeNodeType = TTypeNodeType(3);
  pub const VARIANT: TTypeNodeType = TTypeNodeType(4);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::SCALAR,
    Self::ARRAY,
    Self::MAP,
    Self::STRUCT,
    Self::VARIANT,
  ];
}

impl TSerializable for TTypeNodeType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTypeNodeType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TTypeNodeType::from(enum_value))
  }
}

impl From<i32> for TTypeNodeType {
  fn from(i: i32) -> Self {
    match i {
      0 => TTypeNodeType::SCALAR,
      1 => TTypeNodeType::ARRAY,
      2 => TTypeNodeType::MAP,
      3 => TTypeNodeType::STRUCT,
      4 => TTypeNodeType::VARIANT,
      _ => TTypeNodeType(i)
    }
  }
}

impl From<&i32> for TTypeNodeType {
  fn from(i: &i32) -> Self {
    TTypeNodeType::from(*i)
  }
}

impl From<TTypeNodeType> for i32 {
  fn from(e: TTypeNodeType) -> i32 {
    e.0
  }
}

impl From<&TTypeNodeType> for i32 {
  fn from(e: &TTypeNodeType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TStorageBackendType(pub i32);

impl TStorageBackendType {
  pub const BROKER: TStorageBackendType = TStorageBackendType(0);
  pub const S3: TStorageBackendType = TStorageBackendType(1);
  pub const HDFS: TStorageBackendType = TStorageBackendType(2);
  pub const JFS: TStorageBackendType = TStorageBackendType(3);
  pub const LOCAL: TStorageBackendType = TStorageBackendType(4);
  pub const OFS: TStorageBackendType = TStorageBackendType(5);
  pub const AZURE: TStorageBackendType = TStorageBackendType(6);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::BROKER,
    Self::S3,
    Self::HDFS,
    Self::JFS,
    Self::LOCAL,
    Self::OFS,
    Self::AZURE,
  ];
}

impl TSerializable for TStorageBackendType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TStorageBackendType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TStorageBackendType::from(enum_value))
  }
}

impl From<i32> for TStorageBackendType {
  fn from(i: i32) -> Self {
    match i {
      0 => TStorageBackendType::BROKER,
      1 => TStorageBackendType::S3,
      2 => TStorageBackendType::HDFS,
      3 => TStorageBackendType::JFS,
      4 => TStorageBackendType::LOCAL,
      5 => TStorageBackendType::OFS,
      6 => TStorageBackendType::AZURE,
      _ => TStorageBackendType(i)
    }
  }
}

impl From<&i32> for TStorageBackendType {
  fn from(i: &i32) -> Self {
    TStorageBackendType::from(*i)
  }
}

impl From<TStorageBackendType> for i32 {
  fn from(e: TStorageBackendType) -> i32 {
    e.0
  }
}

impl From<&TStorageBackendType> for i32 {
  fn from(e: &TStorageBackendType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TInvertedIndexFileStorageFormat(pub i32);

impl TInvertedIndexFileStorageFormat {
  pub const DEFAULT: TInvertedIndexFileStorageFormat = TInvertedIndexFileStorageFormat(0);
  pub const V1: TInvertedIndexFileStorageFormat = TInvertedIndexFileStorageFormat(1);
  pub const V2: TInvertedIndexFileStorageFormat = TInvertedIndexFileStorageFormat(2);
  pub const V3: TInvertedIndexFileStorageFormat = TInvertedIndexFileStorageFormat(3);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::DEFAULT,
    Self::V1,
    Self::V2,
    Self::V3,
  ];
}

impl TSerializable for TInvertedIndexFileStorageFormat {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TInvertedIndexFileStorageFormat> {
    let enum_value = i_prot.read_i32()?;
    Ok(TInvertedIndexFileStorageFormat::from(enum_value))
  }
}

impl From<i32> for TInvertedIndexFileStorageFormat {
  fn from(i: i32) -> Self {
    match i {
      0 => TInvertedIndexFileStorageFormat::DEFAULT,
      1 => TInvertedIndexFileStorageFormat::V1,
      2 => TInvertedIndexFileStorageFormat::V2,
      3 => TInvertedIndexFileStorageFormat::V3,
      _ => TInvertedIndexFileStorageFormat(i)
    }
  }
}

impl From<&i32> for TInvertedIndexFileStorageFormat {
  fn from(i: &i32) -> Self {
    TInvertedIndexFileStorageFormat::from(*i)
  }
}

impl From<TInvertedIndexFileStorageFormat> for i32 {
  fn from(e: TInvertedIndexFileStorageFormat) -> i32 {
    e.0
  }
}

impl From<&TInvertedIndexFileStorageFormat> for i32 {
  fn from(e: &TInvertedIndexFileStorageFormat) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TAggregationType(pub i32);

impl TAggregationType {
  pub const SUM: TAggregationType = TAggregationType(0);
  pub const MAX: TAggregationType = TAggregationType(1);
  pub const MIN: TAggregationType = TAggregationType(2);
  pub const REPLACE: TAggregationType = TAggregationType(3);
  pub const HLL_UNION: TAggregationType = TAggregationType(4);
  pub const NONE: TAggregationType = TAggregationType(5);
  pub const BITMAP_UNION: TAggregationType = TAggregationType(6);
  pub const REPLACE_IF_NOT_NULL: TAggregationType = TAggregationType(7);
  pub const QUANTILE_UNION: TAggregationType = TAggregationType(8);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::SUM,
    Self::MAX,
    Self::MIN,
    Self::REPLACE,
    Self::HLL_UNION,
    Self::NONE,
    Self::BITMAP_UNION,
    Self::REPLACE_IF_NOT_NULL,
    Self::QUANTILE_UNION,
  ];
}

impl TSerializable for TAggregationType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TAggregationType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TAggregationType::from(enum_value))
  }
}

impl From<i32> for TAggregationType {
  fn from(i: i32) -> Self {
    match i {
      0 => TAggregationType::SUM,
      1 => TAggregationType::MAX,
      2 => TAggregationType::MIN,
      3 => TAggregationType::REPLACE,
      4 => TAggregationType::HLL_UNION,
      5 => TAggregationType::NONE,
      6 => TAggregationType::BITMAP_UNION,
      7 => TAggregationType::REPLACE_IF_NOT_NULL,
      8 => TAggregationType::QUANTILE_UNION,
      _ => TAggregationType(i)
    }
  }
}

impl From<&i32> for TAggregationType {
  fn from(i: &i32) -> Self {
    TAggregationType::from(*i)
  }
}

impl From<TAggregationType> for i32 {
  fn from(e: TAggregationType) -> i32 {
    e.0
  }
}

impl From<&TAggregationType> for i32 {
  fn from(e: &TAggregationType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TPushType(pub i32);

impl TPushType {
  pub const LOAD: TPushType = TPushType(0);
  pub const DELETE: TPushType = TPushType(1);
  pub const LOAD_DELETE: TPushType = TPushType(2);
  pub const LOAD_V2: TPushType = TPushType(3);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::LOAD,
    Self::DELETE,
    Self::LOAD_DELETE,
    Self::LOAD_V2,
  ];
}

impl TSerializable for TPushType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TPushType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TPushType::from(enum_value))
  }
}

impl From<i32> for TPushType {
  fn from(i: i32) -> Self {
    match i {
      0 => TPushType::LOAD,
      1 => TPushType::DELETE,
      2 => TPushType::LOAD_DELETE,
      3 => TPushType::LOAD_V2,
      _ => TPushType(i)
    }
  }
}

impl From<&i32> for TPushType {
  fn from(i: &i32) -> Self {
    TPushType::from(*i)
  }
}

impl From<TPushType> for i32 {
  fn from(e: TPushType) -> i32 {
    e.0
  }
}

impl From<&TPushType> for i32 {
  fn from(e: &TPushType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTaskType(pub i32);

impl TTaskType {
  pub const CREATE: TTaskType = TTaskType(0);
  pub const DROP: TTaskType = TTaskType(1);
  pub const PUSH: TTaskType = TTaskType(2);
  pub const CLONE: TTaskType = TTaskType(3);
  pub const STORAGE_MEDIUM_MIGRATE: TTaskType = TTaskType(4);
  pub const ROLLUP: TTaskType = TTaskType(5);
  pub const SCHEMA_CHANGE: TTaskType = TTaskType(6);
  pub const CANCEL_DELETE: TTaskType = TTaskType(7);
  pub const MAKE_SNAPSHOT: TTaskType = TTaskType(8);
  pub const RELEASE_SNAPSHOT: TTaskType = TTaskType(9);
  pub const CHECK_CONSISTENCY: TTaskType = TTaskType(10);
  pub const UPLOAD: TTaskType = TTaskType(11);
  pub const DOWNLOAD: TTaskType = TTaskType(12);
  pub const CLEAR_REMOTE_FILE: TTaskType = TTaskType(13);
  pub const MOVE: TTaskType = TTaskType(14);
  pub const REALTIME_PUSH: TTaskType = TTaskType(15);
  pub const PUBLISH_VERSION: TTaskType = TTaskType(16);
  pub const CLEAR_ALTER_TASK: TTaskType = TTaskType(17);
  pub const CLEAR_TRANSACTION_TASK: TTaskType = TTaskType(18);
  pub const RECOVER_TABLET: TTaskType = TTaskType(19);
  pub const STREAM_LOAD: TTaskType = TTaskType(20);
  pub const UPDATE_TABLET_META_INFO: TTaskType = TTaskType(21);
  pub const ALTER: TTaskType = TTaskType(22);
  pub const INSTALL_PLUGIN: TTaskType = TTaskType(23);
  pub const UNINSTALL_PLUGIN: TTaskType = TTaskType(24);
  pub const COMPACTION: TTaskType = TTaskType(25);
  pub const STORAGE_MEDIUM_MIGRATE_V2: TTaskType = TTaskType(26);
  pub const NOTIFY_UPDATE_STORAGE_POLICY: TTaskType = TTaskType(27);
  pub const PUSH_COOLDOWN_CONF: TTaskType = TTaskType(28);
  pub const PUSH_STORAGE_POLICY: TTaskType = TTaskType(29);
  pub const ALTER_INVERTED_INDEX: TTaskType = TTaskType(30);
  pub const GC_BINLOG: TTaskType = TTaskType(31);
  pub const CLEAN_TRASH: TTaskType = TTaskType(32);
  pub const UPDATE_VISIBLE_VERSION: TTaskType = TTaskType(33);
  pub const CLEAN_UDF_CACHE: TTaskType = TTaskType(34);
  pub const PUSH_INDEX_POLICY: TTaskType = TTaskType(35);
  pub const CALCULATE_DELETE_BITMAP: TTaskType = TTaskType(1000);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::CREATE,
    Self::DROP,
    Self::PUSH,
    Self::CLONE,
    Self::STORAGE_MEDIUM_MIGRATE,
    Self::ROLLUP,
    Self::SCHEMA_CHANGE,
    Self::CANCEL_DELETE,
    Self::MAKE_SNAPSHOT,
    Self::RELEASE_SNAPSHOT,
    Self::CHECK_CONSISTENCY,
    Self::UPLOAD,
    Self::DOWNLOAD,
    Self::CLEAR_REMOTE_FILE,
    Self::MOVE,
    Self::REALTIME_PUSH,
    Self::PUBLISH_VERSION,
    Self::CLEAR_ALTER_TASK,
    Self::CLEAR_TRANSACTION_TASK,
    Self::RECOVER_TABLET,
    Self::STREAM_LOAD,
    Self::UPDATE_TABLET_META_INFO,
    Self::ALTER,
    Self::INSTALL_PLUGIN,
    Self::UNINSTALL_PLUGIN,
    Self::COMPACTION,
    Self::STORAGE_MEDIUM_MIGRATE_V2,
    Self::NOTIFY_UPDATE_STORAGE_POLICY,
    Self::PUSH_COOLDOWN_CONF,
    Self::PUSH_STORAGE_POLICY,
    Self::ALTER_INVERTED_INDEX,
    Self::GC_BINLOG,
    Self::CLEAN_TRASH,
    Self::UPDATE_VISIBLE_VERSION,
    Self::CLEAN_UDF_CACHE,
    Self::PUSH_INDEX_POLICY,
    Self::CALCULATE_DELETE_BITMAP,
  ];
}

impl TSerializable for TTaskType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTaskType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TTaskType::from(enum_value))
  }
}

impl From<i32> for TTaskType {
  fn from(i: i32) -> Self {
    match i {
      0 => TTaskType::CREATE,
      1 => TTaskType::DROP,
      2 => TTaskType::PUSH,
      3 => TTaskType::CLONE,
      4 => TTaskType::STORAGE_MEDIUM_MIGRATE,
      5 => TTaskType::ROLLUP,
      6 => TTaskType::SCHEMA_CHANGE,
      7 => TTaskType::CANCEL_DELETE,
      8 => TTaskType::MAKE_SNAPSHOT,
      9 => TTaskType::RELEASE_SNAPSHOT,
      10 => TTaskType::CHECK_CONSISTENCY,
      11 => TTaskType::UPLOAD,
      12 => TTaskType::DOWNLOAD,
      13 => TTaskType::CLEAR_REMOTE_FILE,
      14 => TTaskType::MOVE,
      15 => TTaskType::REALTIME_PUSH,
      16 => TTaskType::PUBLISH_VERSION,
      17 => TTaskType::CLEAR_ALTER_TASK,
      18 => TTaskType::CLEAR_TRANSACTION_TASK,
      19 => TTaskType::RECOVER_TABLET,
      20 => TTaskType::STREAM_LOAD,
      21 => TTaskType::UPDATE_TABLET_META_INFO,
      22 => TTaskType::ALTER,
      23 => TTaskType::INSTALL_PLUGIN,
      24 => TTaskType::UNINSTALL_PLUGIN,
      25 => TTaskType::COMPACTION,
      26 => TTaskType::STORAGE_MEDIUM_MIGRATE_V2,
      27 => TTaskType::NOTIFY_UPDATE_STORAGE_POLICY,
      28 => TTaskType::PUSH_COOLDOWN_CONF,
      29 => TTaskType::PUSH_STORAGE_POLICY,
      30 => TTaskType::ALTER_INVERTED_INDEX,
      31 => TTaskType::GC_BINLOG,
      32 => TTaskType::CLEAN_TRASH,
      33 => TTaskType::UPDATE_VISIBLE_VERSION,
      34 => TTaskType::CLEAN_UDF_CACHE,
      35 => TTaskType::PUSH_INDEX_POLICY,
      1000 => TTaskType::CALCULATE_DELETE_BITMAP,
      _ => TTaskType(i)
    }
  }
}

impl From<&i32> for TTaskType {
  fn from(i: &i32) -> Self {
    TTaskType::from(*i)
  }
}

impl From<TTaskType> for i32 {
  fn from(e: TTaskType) -> i32 {
    e.0
  }
}

impl From<&TTaskType> for i32 {
  fn from(e: &TTaskType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TExplainLevel(pub i32);

impl TExplainLevel {
  pub const BRIEF: TExplainLevel = TExplainLevel(0);
  pub const NORMAL: TExplainLevel = TExplainLevel(1);
  pub const VERBOSE: TExplainLevel = TExplainLevel(2);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::BRIEF,
    Self::NORMAL,
    Self::VERBOSE,
  ];
}

impl TSerializable for TExplainLevel {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TExplainLevel> {
    let enum_value = i_prot.read_i32()?;
    Ok(TExplainLevel::from(enum_value))
  }
}

impl From<i32> for TExplainLevel {
  fn from(i: i32) -> Self {
    match i {
      0 => TExplainLevel::BRIEF,
      1 => TExplainLevel::NORMAL,
      2 => TExplainLevel::VERBOSE,
      _ => TExplainLevel(i)
    }
  }
}

impl From<&i32> for TExplainLevel {
  fn from(i: &i32) -> Self {
    TExplainLevel::from(*i)
  }
}

impl From<TExplainLevel> for i32 {
  fn from(e: TExplainLevel) -> i32 {
    e.0
  }
}

impl From<&TExplainLevel> for i32 {
  fn from(e: &TExplainLevel) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TRuntimeFilterMode(pub i32);

impl TRuntimeFilterMode {
  pub const OFF: TRuntimeFilterMode = TRuntimeFilterMode(0);
  pub const LOCAL: TRuntimeFilterMode = TRuntimeFilterMode(1);
  pub const REMOTE: TRuntimeFilterMode = TRuntimeFilterMode(2);
  pub const GLOBAL: TRuntimeFilterMode = TRuntimeFilterMode(3);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::OFF,
    Self::LOCAL,
    Self::REMOTE,
    Self::GLOBAL,
  ];
}

impl TSerializable for TRuntimeFilterMode {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TRuntimeFilterMode> {
    let enum_value = i_prot.read_i32()?;
    Ok(TRuntimeFilterMode::from(enum_value))
  }
}

impl From<i32> for TRuntimeFilterMode {
  fn from(i: i32) -> Self {
    match i {
      0 => TRuntimeFilterMode::OFF,
      1 => TRuntimeFilterMode::LOCAL,
      2 => TRuntimeFilterMode::REMOTE,
      3 => TRuntimeFilterMode::GLOBAL,
      _ => TRuntimeFilterMode(i)
    }
  }
}

impl From<&i32> for TRuntimeFilterMode {
  fn from(i: &i32) -> Self {
    TRuntimeFilterMode::from(*i)
  }
}

impl From<TRuntimeFilterMode> for i32 {
  fn from(e: TRuntimeFilterMode) -> i32 {
    e.0
  }
}

impl From<&TRuntimeFilterMode> for i32 {
  fn from(e: &TRuntimeFilterMode) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct QueryState(pub i32);

impl QueryState {
  pub const CREATED: QueryState = QueryState(0);
  pub const INITIALIZED: QueryState = QueryState(1);
  pub const COMPILED: QueryState = QueryState(2);
  pub const RUNNING: QueryState = QueryState(3);
  pub const FINISHED: QueryState = QueryState(4);
  pub const EXCEPTION: QueryState = QueryState(5);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::CREATED,
    Self::INITIALIZED,
    Self::COMPILED,
    Self::RUNNING,
    Self::FINISHED,
    Self::EXCEPTION,
  ];
}

impl TSerializable for QueryState {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<QueryState> {
    let enum_value = i_prot.read_i32()?;
    Ok(QueryState::from(enum_value))
  }
}

impl From<i32> for QueryState {
  fn from(i: i32) -> Self {
    match i {
      0 => QueryState::CREATED,
      1 => QueryState::INITIALIZED,
      2 => QueryState::COMPILED,
      3 => QueryState::RUNNING,
      4 => QueryState::FINISHED,
      5 => QueryState::EXCEPTION,
      _ => QueryState(i)
    }
  }
}

impl From<&i32> for QueryState {
  fn from(i: &i32) -> Self {
    QueryState::from(*i)
  }
}

impl From<QueryState> for i32 {
  fn from(e: QueryState) -> i32 {
    e.0
  }
}

impl From<&QueryState> for i32 {
  fn from(e: &QueryState) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TFunctionType(pub i32);

impl TFunctionType {
  pub const SCALAR: TFunctionType = TFunctionType(0);
  pub const AGGREGATE: TFunctionType = TFunctionType(1);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::SCALAR,
    Self::AGGREGATE,
  ];
}

impl TSerializable for TFunctionType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TFunctionType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TFunctionType::from(enum_value))
  }
}

impl From<i32> for TFunctionType {
  fn from(i: i32) -> Self {
    match i {
      0 => TFunctionType::SCALAR,
      1 => TFunctionType::AGGREGATE,
      _ => TFunctionType(i)
    }
  }
}

impl From<&i32> for TFunctionType {
  fn from(i: &i32) -> Self {
    TFunctionType::from(*i)
  }
}

impl From<TFunctionType> for i32 {
  fn from(e: TFunctionType) -> i32 {
    e.0
  }
}

impl From<&TFunctionType> for i32 {
  fn from(e: &TFunctionType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TFunctionBinaryType(pub i32);

impl TFunctionBinaryType {
  pub const BUILTIN: TFunctionBinaryType = TFunctionBinaryType(0);
  pub const HIVE: TFunctionBinaryType = TFunctionBinaryType(1);
  pub const NATIVE: TFunctionBinaryType = TFunctionBinaryType(2);
  pub const IR: TFunctionBinaryType = TFunctionBinaryType(3);
  pub const RPC: TFunctionBinaryType = TFunctionBinaryType(4);
  pub const JAVA_UDF: TFunctionBinaryType = TFunctionBinaryType(5);
  pub const AGG_STATE: TFunctionBinaryType = TFunctionBinaryType(6);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::BUILTIN,
    Self::HIVE,
    Self::NATIVE,
    Self::IR,
    Self::RPC,
    Self::JAVA_UDF,
    Self::AGG_STATE,
  ];
}

impl TSerializable for TFunctionBinaryType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TFunctionBinaryType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TFunctionBinaryType::from(enum_value))
  }
}

impl From<i32> for TFunctionBinaryType {
  fn from(i: i32) -> Self {
    match i {
      0 => TFunctionBinaryType::BUILTIN,
      1 => TFunctionBinaryType::HIVE,
      2 => TFunctionBinaryType::NATIVE,
      3 => TFunctionBinaryType::IR,
      4 => TFunctionBinaryType::RPC,
      5 => TFunctionBinaryType::JAVA_UDF,
      6 => TFunctionBinaryType::AGG_STATE,
      _ => TFunctionBinaryType(i)
    }
  }
}

impl From<&i32> for TFunctionBinaryType {
  fn from(i: &i32) -> Self {
    TFunctionBinaryType::from(*i)
  }
}

impl From<TFunctionBinaryType> for i32 {
  fn from(e: TFunctionBinaryType) -> i32 {
    e.0
  }
}

impl From<&TFunctionBinaryType> for i32 {
  fn from(e: &TFunctionBinaryType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TJdbcOperation(pub i32);

impl TJdbcOperation {
  pub const READ: TJdbcOperation = TJdbcOperation(0);
  pub const WRITE: TJdbcOperation = TJdbcOperation(1);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::READ,
    Self::WRITE,
  ];
}

impl TSerializable for TJdbcOperation {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TJdbcOperation> {
    let enum_value = i_prot.read_i32()?;
    Ok(TJdbcOperation::from(enum_value))
  }
}

impl From<i32> for TJdbcOperation {
  fn from(i: i32) -> Self {
    match i {
      0 => TJdbcOperation::READ,
      1 => TJdbcOperation::WRITE,
      _ => TJdbcOperation(i)
    }
  }
}

impl From<&i32> for TJdbcOperation {
  fn from(i: &i32) -> Self {
    TJdbcOperation::from(*i)
  }
}

impl From<TJdbcOperation> for i32 {
  fn from(e: TJdbcOperation) -> i32 {
    e.0
  }
}

impl From<&TJdbcOperation> for i32 {
  fn from(e: &TJdbcOperation) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TOdbcTableType(pub i32);

impl TOdbcTableType {
  pub const MYSQL: TOdbcTableType = TOdbcTableType(0);
  pub const ORACLE: TOdbcTableType = TOdbcTableType(1);
  pub const POSTGRESQL: TOdbcTableType = TOdbcTableType(2);
  pub const SQLSERVER: TOdbcTableType = TOdbcTableType(3);
  pub const REDIS: TOdbcTableType = TOdbcTableType(4);
  pub const MONGODB: TOdbcTableType = TOdbcTableType(5);
  pub const CLICKHOUSE: TOdbcTableType = TOdbcTableType(6);
  pub const SAP_HANA: TOdbcTableType = TOdbcTableType(7);
  pub const TRINO: TOdbcTableType = TOdbcTableType(8);
  pub const PRESTO: TOdbcTableType = TOdbcTableType(9);
  pub const OCEANBASE: TOdbcTableType = TOdbcTableType(10);
  pub const OCEANBASE_ORACLE: TOdbcTableType = TOdbcTableType(11);
  pub const NEBULA: TOdbcTableType = TOdbcTableType(12);
  pub const DB2: TOdbcTableType = TOdbcTableType(13);
  pub const GBASE: TOdbcTableType = TOdbcTableType(14);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::MYSQL,
    Self::ORACLE,
    Self::POSTGRESQL,
    Self::SQLSERVER,
    Self::REDIS,
    Self::MONGODB,
    Self::CLICKHOUSE,
    Self::SAP_HANA,
    Self::TRINO,
    Self::PRESTO,
    Self::OCEANBASE,
    Self::OCEANBASE_ORACLE,
    Self::NEBULA,
    Self::DB2,
    Self::GBASE,
  ];
}

impl TSerializable for TOdbcTableType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TOdbcTableType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TOdbcTableType::from(enum_value))
  }
}

impl From<i32> for TOdbcTableType {
  fn from(i: i32) -> Self {
    match i {
      0 => TOdbcTableType::MYSQL,
      1 => TOdbcTableType::ORACLE,
      2 => TOdbcTableType::POSTGRESQL,
      3 => TOdbcTableType::SQLSERVER,
      4 => TOdbcTableType::REDIS,
      5 => TOdbcTableType::MONGODB,
      6 => TOdbcTableType::CLICKHOUSE,
      7 => TOdbcTableType::SAP_HANA,
      8 => TOdbcTableType::TRINO,
      9 => TOdbcTableType::PRESTO,
      10 => TOdbcTableType::OCEANBASE,
      11 => TOdbcTableType::OCEANBASE_ORACLE,
      12 => TOdbcTableType::NEBULA,
      13 => TOdbcTableType::DB2,
      14 => TOdbcTableType::GBASE,
      _ => TOdbcTableType(i)
    }
  }
}

impl From<&i32> for TOdbcTableType {
  fn from(i: &i32) -> Self {
    TOdbcTableType::from(*i)
  }
}

impl From<TOdbcTableType> for i32 {
  fn from(e: TOdbcTableType) -> i32 {
    e.0
  }
}

impl From<&TOdbcTableType> for i32 {
  fn from(e: &TOdbcTableType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TLoadJobState(pub i32);

impl TLoadJobState {
  pub const PENDING: TLoadJobState = TLoadJobState(0);
  pub const ETL: TLoadJobState = TLoadJobState(1);
  pub const LOADING: TLoadJobState = TLoadJobState(2);
  pub const FINISHED: TLoadJobState = TLoadJobState(3);
  pub const CANCELLED: TLoadJobState = TLoadJobState(4);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::PENDING,
    Self::ETL,
    Self::LOADING,
    Self::FINISHED,
    Self::CANCELLED,
  ];
}

impl TSerializable for TLoadJobState {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TLoadJobState> {
    let enum_value = i_prot.read_i32()?;
    Ok(TLoadJobState::from(enum_value))
  }
}

impl From<i32> for TLoadJobState {
  fn from(i: i32) -> Self {
    match i {
      0 => TLoadJobState::PENDING,
      1 => TLoadJobState::ETL,
      2 => TLoadJobState::LOADING,
      3 => TLoadJobState::FINISHED,
      4 => TLoadJobState::CANCELLED,
      _ => TLoadJobState(i)
    }
  }
}

impl From<&i32> for TLoadJobState {
  fn from(i: &i32) -> Self {
    TLoadJobState::from(*i)
  }
}

impl From<TLoadJobState> for i32 {
  fn from(e: TLoadJobState) -> i32 {
    e.0
  }
}

impl From<&TLoadJobState> for i32 {
  fn from(e: &TLoadJobState) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TEtlState(pub i32);

impl TEtlState {
  pub const RUNNING: TEtlState = TEtlState(0);
  pub const FINISHED: TEtlState = TEtlState(1);
  pub const CANCELLED: TEtlState = TEtlState(2);
  pub const UNKNOWN: TEtlState = TEtlState(3);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::RUNNING,
    Self::FINISHED,
    Self::CANCELLED,
    Self::UNKNOWN,
  ];
}

impl TSerializable for TEtlState {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TEtlState> {
    let enum_value = i_prot.read_i32()?;
    Ok(TEtlState::from(enum_value))
  }
}

impl From<i32> for TEtlState {
  fn from(i: i32) -> Self {
    match i {
      0 => TEtlState::RUNNING,
      1 => TEtlState::FINISHED,
      2 => TEtlState::CANCELLED,
      3 => TEtlState::UNKNOWN,
      _ => TEtlState(i)
    }
  }
}

impl From<&i32> for TEtlState {
  fn from(i: &i32) -> Self {
    TEtlState::from(*i)
  }
}

impl From<TEtlState> for i32 {
  fn from(e: TEtlState) -> i32 {
    e.0
  }
}

impl From<&TEtlState> for i32 {
  fn from(e: &TEtlState) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTableType(pub i32);

impl TTableType {
  pub const MYSQL_TABLE: TTableType = TTableType(0);
  pub const OLAP_TABLE: TTableType = TTableType(1);
  pub const SCHEMA_TABLE: TTableType = TTableType(2);
  pub const KUDU_TABLE: TTableType = TTableType(3);
  pub const BROKER_TABLE: TTableType = TTableType(4);
  pub const ES_TABLE: TTableType = TTableType(5);
  pub const ODBC_TABLE: TTableType = TTableType(6);
  pub const HIVE_TABLE: TTableType = TTableType(7);
  pub const ICEBERG_TABLE: TTableType = TTableType(8);
  pub const HUDI_TABLE: TTableType = TTableType(9);
  pub const JDBC_TABLE: TTableType = TTableType(10);
  pub const TEST_EXTERNAL_TABLE: TTableType = TTableType(11);
  pub const MAX_COMPUTE_TABLE: TTableType = TTableType(12);
  pub const LAKESOUL_TABLE: TTableType = TTableType(13);
  pub const TRINO_CONNECTOR_TABLE: TTableType = TTableType(14);
  pub const DICTIONARY_TABLE: TTableType = TTableType(15);
  pub const REMOTE_DORIS_TABLE: TTableType = TTableType(16);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::MYSQL_TABLE,
    Self::OLAP_TABLE,
    Self::SCHEMA_TABLE,
    Self::KUDU_TABLE,
    Self::BROKER_TABLE,
    Self::ES_TABLE,
    Self::ODBC_TABLE,
    Self::HIVE_TABLE,
    Self::ICEBERG_TABLE,
    Self::HUDI_TABLE,
    Self::JDBC_TABLE,
    Self::TEST_EXTERNAL_TABLE,
    Self::MAX_COMPUTE_TABLE,
    Self::LAKESOUL_TABLE,
    Self::TRINO_CONNECTOR_TABLE,
    Self::DICTIONARY_TABLE,
    Self::REMOTE_DORIS_TABLE,
  ];
}

impl TSerializable for TTableType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTableType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TTableType::from(enum_value))
  }
}

impl From<i32> for TTableType {
  fn from(i: i32) -> Self {
    match i {
      0 => TTableType::MYSQL_TABLE,
      1 => TTableType::OLAP_TABLE,
      2 => TTableType::SCHEMA_TABLE,
      3 => TTableType::KUDU_TABLE,
      4 => TTableType::BROKER_TABLE,
      5 => TTableType::ES_TABLE,
      6 => TTableType::ODBC_TABLE,
      7 => TTableType::HIVE_TABLE,
      8 => TTableType::ICEBERG_TABLE,
      9 => TTableType::HUDI_TABLE,
      10 => TTableType::JDBC_TABLE,
      11 => TTableType::TEST_EXTERNAL_TABLE,
      12 => TTableType::MAX_COMPUTE_TABLE,
      13 => TTableType::LAKESOUL_TABLE,
      14 => TTableType::TRINO_CONNECTOR_TABLE,
      15 => TTableType::DICTIONARY_TABLE,
      16 => TTableType::REMOTE_DORIS_TABLE,
      _ => TTableType(i)
    }
  }
}

impl From<&i32> for TTableType {
  fn from(i: &i32) -> Self {
    TTableType::from(*i)
  }
}

impl From<TTableType> for i32 {
  fn from(e: TTableType) -> i32 {
    e.0
  }
}

impl From<&TTableType> for i32 {
  fn from(e: &TTableType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TKeysType(pub i32);

impl TKeysType {
  pub const PRIMARY_KEYS: TKeysType = TKeysType(0);
  pub const DUP_KEYS: TKeysType = TKeysType(1);
  pub const UNIQUE_KEYS: TKeysType = TKeysType(2);
  pub const AGG_KEYS: TKeysType = TKeysType(3);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::PRIMARY_KEYS,
    Self::DUP_KEYS,
    Self::UNIQUE_KEYS,
    Self::AGG_KEYS,
  ];
}

impl TSerializable for TKeysType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TKeysType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TKeysType::from(enum_value))
  }
}

impl From<i32> for TKeysType {
  fn from(i: i32) -> Self {
    match i {
      0 => TKeysType::PRIMARY_KEYS,
      1 => TKeysType::DUP_KEYS,
      2 => TKeysType::UNIQUE_KEYS,
      3 => TKeysType::AGG_KEYS,
      _ => TKeysType(i)
    }
  }
}

impl From<&i32> for TKeysType {
  fn from(i: &i32) -> Self {
    TKeysType::from(*i)
  }
}

impl From<TKeysType> for i32 {
  fn from(e: TKeysType) -> i32 {
    e.0
  }
}

impl From<&TKeysType> for i32 {
  fn from(e: &TKeysType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TPriority(pub i32);

impl TPriority {
  pub const NORMAL: TPriority = TPriority(0);
  pub const HIGH: TPriority = TPriority(1);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NORMAL,
    Self::HIGH,
  ];
}

impl TSerializable for TPriority {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TPriority> {
    let enum_value = i_prot.read_i32()?;
    Ok(TPriority::from(enum_value))
  }
}

impl From<i32> for TPriority {
  fn from(i: i32) -> Self {
    match i {
      0 => TPriority::NORMAL,
      1 => TPriority::HIGH,
      _ => TPriority(i)
    }
  }
}

impl From<&i32> for TPriority {
  fn from(i: &i32) -> Self {
    TPriority::from(*i)
  }
}

impl From<TPriority> for i32 {
  fn from(e: TPriority) -> i32 {
    e.0
  }
}

impl From<&TPriority> for i32 {
  fn from(e: &TPriority) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TFileType(pub i32);

impl TFileType {
  pub const FILE_LOCAL: TFileType = TFileType(0);
  pub const FILE_BROKER: TFileType = TFileType(1);
  pub const FILE_STREAM: TFileType = TFileType(2);
  pub const FILE_S3: TFileType = TFileType(3);
  pub const FILE_HDFS: TFileType = TFileType(4);
  pub const FILE_NET: TFileType = TFileType(5);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::FILE_LOCAL,
    Self::FILE_BROKER,
    Self::FILE_STREAM,
    Self::FILE_S3,
    Self::FILE_HDFS,
    Self::FILE_NET,
  ];
}

impl TSerializable for TFileType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TFileType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TFileType::from(enum_value))
  }
}

impl From<i32> for TFileType {
  fn from(i: i32) -> Self {
    match i {
      0 => TFileType::FILE_LOCAL,
      1 => TFileType::FILE_BROKER,
      2 => TFileType::FILE_STREAM,
      3 => TFileType::FILE_S3,
      4 => TFileType::FILE_HDFS,
      5 => TFileType::FILE_NET,
      _ => TFileType(i)
    }
  }
}

impl From<&i32> for TFileType {
  fn from(i: &i32) -> Self {
    TFileType::from(*i)
  }
}

impl From<TFileType> for i32 {
  fn from(e: TFileType) -> i32 {
    e.0
  }
}

impl From<&TFileType> for i32 {
  fn from(e: &TFileType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TLoadType(pub i32);

impl TLoadType {
  pub const MANUL_LOAD: TLoadType = TLoadType(0);
  pub const ROUTINE_LOAD: TLoadType = TLoadType(1);
  pub const MINI_LOAD: TLoadType = TLoadType(2);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::MANUL_LOAD,
    Self::ROUTINE_LOAD,
    Self::MINI_LOAD,
  ];
}

impl TSerializable for TLoadType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TLoadType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TLoadType::from(enum_value))
  }
}

impl From<i32> for TLoadType {
  fn from(i: i32) -> Self {
    match i {
      0 => TLoadType::MANUL_LOAD,
      1 => TLoadType::ROUTINE_LOAD,
      2 => TLoadType::MINI_LOAD,
      _ => TLoadType(i)
    }
  }
}

impl From<&i32> for TLoadType {
  fn from(i: &i32) -> Self {
    TLoadType::from(*i)
  }
}

impl From<TLoadType> for i32 {
  fn from(e: TLoadType) -> i32 {
    e.0
  }
}

impl From<&TLoadType> for i32 {
  fn from(e: &TLoadType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TLoadSourceType(pub i32);

impl TLoadSourceType {
  pub const RAW: TLoadSourceType = TLoadSourceType(0);
  pub const KAFKA: TLoadSourceType = TLoadSourceType(1);
  pub const MULTI_TABLE: TLoadSourceType = TLoadSourceType(2);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::RAW,
    Self::KAFKA,
    Self::MULTI_TABLE,
  ];
}

impl TSerializable for TLoadSourceType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TLoadSourceType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TLoadSourceType::from(enum_value))
  }
}

impl From<i32> for TLoadSourceType {
  fn from(i: i32) -> Self {
    match i {
      0 => TLoadSourceType::RAW,
      1 => TLoadSourceType::KAFKA,
      2 => TLoadSourceType::MULTI_TABLE,
      _ => TLoadSourceType(i)
    }
  }
}

impl From<&i32> for TLoadSourceType {
  fn from(i: &i32) -> Self {
    TLoadSourceType::from(*i)
  }
}

impl From<TLoadSourceType> for i32 {
  fn from(e: TLoadSourceType) -> i32 {
    e.0
  }
}

impl From<&TLoadSourceType> for i32 {
  fn from(e: &TLoadSourceType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TMergeType(pub i32);

impl TMergeType {
  pub const APPEND: TMergeType = TMergeType(0);
  pub const MERGE: TMergeType = TMergeType(1);
  pub const DELETE: TMergeType = TMergeType(2);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::APPEND,
    Self::MERGE,
    Self::DELETE,
  ];
}

impl TSerializable for TMergeType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TMergeType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TMergeType::from(enum_value))
  }
}

impl From<i32> for TMergeType {
  fn from(i: i32) -> Self {
    match i {
      0 => TMergeType::APPEND,
      1 => TMergeType::MERGE,
      2 => TMergeType::DELETE,
      _ => TMergeType(i)
    }
  }
}

impl From<&i32> for TMergeType {
  fn from(i: &i32) -> Self {
    TMergeType::from(*i)
  }
}

impl From<TMergeType> for i32 {
  fn from(e: TMergeType) -> i32 {
    e.0
  }
}

impl From<&TMergeType> for i32 {
  fn from(e: &TMergeType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TUniqueKeyUpdateMode(pub i32);

impl TUniqueKeyUpdateMode {
  pub const UPSERT: TUniqueKeyUpdateMode = TUniqueKeyUpdateMode(0);
  pub const UPDATE_FIXED_COLUMNS: TUniqueKeyUpdateMode = TUniqueKeyUpdateMode(1);
  pub const UPDATE_FLEXIBLE_COLUMNS: TUniqueKeyUpdateMode = TUniqueKeyUpdateMode(2);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::UPSERT,
    Self::UPDATE_FIXED_COLUMNS,
    Self::UPDATE_FLEXIBLE_COLUMNS,
  ];
}

impl TSerializable for TUniqueKeyUpdateMode {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TUniqueKeyUpdateMode> {
    let enum_value = i_prot.read_i32()?;
    Ok(TUniqueKeyUpdateMode::from(enum_value))
  }
}

impl From<i32> for TUniqueKeyUpdateMode {
  fn from(i: i32) -> Self {
    match i {
      0 => TUniqueKeyUpdateMode::UPSERT,
      1 => TUniqueKeyUpdateMode::UPDATE_FIXED_COLUMNS,
      2 => TUniqueKeyUpdateMode::UPDATE_FLEXIBLE_COLUMNS,
      _ => TUniqueKeyUpdateMode(i)
    }
  }
}

impl From<&i32> for TUniqueKeyUpdateMode {
  fn from(i: &i32) -> Self {
    TUniqueKeyUpdateMode::from(*i)
  }
}

impl From<TUniqueKeyUpdateMode> for i32 {
  fn from(e: TUniqueKeyUpdateMode) -> i32 {
    e.0
  }
}

impl From<&TUniqueKeyUpdateMode> for i32 {
  fn from(e: &TUniqueKeyUpdateMode) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSortType(pub i32);

impl TSortType {
  pub const LEXICAL: TSortType = TSortType(0);
  pub const ZORDER: TSortType = TSortType(1);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::LEXICAL,
    Self::ZORDER,
  ];
}

impl TSerializable for TSortType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSortType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TSortType::from(enum_value))
  }
}

impl From<i32> for TSortType {
  fn from(i: i32) -> Self {
    match i {
      0 => TSortType::LEXICAL,
      1 => TSortType::ZORDER,
      _ => TSortType(i)
    }
  }
}

impl From<&i32> for TSortType {
  fn from(i: &i32) -> Self {
    TSortType::from(*i)
  }
}

impl From<TSortType> for i32 {
  fn from(e: TSortType) -> i32 {
    e.0
  }
}

impl From<&TSortType> for i32 {
  fn from(e: &TSortType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TMetadataType(pub i32);

impl TMetadataType {
  pub const ICEBERG: TMetadataType = TMetadataType(0);
  pub const BACKENDS: TMetadataType = TMetadataType(1);
  pub const FRONTENDS: TMetadataType = TMetadataType(2);
  pub const CATALOGS: TMetadataType = TMetadataType(3);
  pub const FRONTENDS_DISKS: TMetadataType = TMetadataType(4);
  pub const MATERIALIZED_VIEWS: TMetadataType = TMetadataType(5);
  pub const JOBS: TMetadataType = TMetadataType(6);
  pub const TASKS: TMetadataType = TMetadataType(7);
  pub const WORKLOAD_SCHED_POLICY: TMetadataType = TMetadataType(8);
  pub const PARTITIONS: TMetadataType = TMetadataType(9);
  pub const PARTITION_VALUES: TMetadataType = TMetadataType(10);
  pub const HUDI: TMetadataType = TMetadataType(11);
  pub const PAIMON: TMetadataType = TMetadataType(12);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::ICEBERG,
    Self::BACKENDS,
    Self::FRONTENDS,
    Self::CATALOGS,
    Self::FRONTENDS_DISKS,
    Self::MATERIALIZED_VIEWS,
    Self::JOBS,
    Self::TASKS,
    Self::WORKLOAD_SCHED_POLICY,
    Self::PARTITIONS,
    Self::PARTITION_VALUES,
    Self::HUDI,
    Self::PAIMON,
  ];
}

impl TSerializable for TMetadataType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TMetadataType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TMetadataType::from(enum_value))
  }
}

impl From<i32> for TMetadataType {
  fn from(i: i32) -> Self {
    match i {
      0 => TMetadataType::ICEBERG,
      1 => TMetadataType::BACKENDS,
      2 => TMetadataType::FRONTENDS,
      3 => TMetadataType::CATALOGS,
      4 => TMetadataType::FRONTENDS_DISKS,
      5 => TMetadataType::MATERIALIZED_VIEWS,
      6 => TMetadataType::JOBS,
      7 => TMetadataType::TASKS,
      8 => TMetadataType::WORKLOAD_SCHED_POLICY,
      9 => TMetadataType::PARTITIONS,
      10 => TMetadataType::PARTITION_VALUES,
      11 => TMetadataType::HUDI,
      12 => TMetadataType::PAIMON,
      _ => TMetadataType(i)
    }
  }
}

impl From<&i32> for TMetadataType {
  fn from(i: &i32) -> Self {
    TMetadataType::from(*i)
  }
}

impl From<TMetadataType> for i32 {
  fn from(e: TMetadataType) -> i32 {
    e.0
  }
}

impl From<&TMetadataType> for i32 {
  fn from(e: &TMetadataType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TIcebergQueryType(pub i32);

impl TIcebergQueryType {
  pub const SNAPSHOTS: TIcebergQueryType = TIcebergQueryType(0);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::SNAPSHOTS,
  ];
}

impl TSerializable for TIcebergQueryType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TIcebergQueryType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TIcebergQueryType::from(enum_value))
  }
}

impl From<i32> for TIcebergQueryType {
  fn from(i: i32) -> Self {
    match i {
      0 => TIcebergQueryType::SNAPSHOTS,
      _ => TIcebergQueryType(i)
    }
  }
}

impl From<&i32> for TIcebergQueryType {
  fn from(i: &i32) -> Self {
    TIcebergQueryType::from(*i)
  }
}

impl From<TIcebergQueryType> for i32 {
  fn from(e: TIcebergQueryType) -> i32 {
    e.0
  }
}

impl From<&TIcebergQueryType> for i32 {
  fn from(e: &TIcebergQueryType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct THudiQueryType(pub i32);

impl THudiQueryType {
  pub const TIMELINE: THudiQueryType = THudiQueryType(0);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::TIMELINE,
  ];
}

impl TSerializable for THudiQueryType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<THudiQueryType> {
    let enum_value = i_prot.read_i32()?;
    Ok(THudiQueryType::from(enum_value))
  }
}

impl From<i32> for THudiQueryType {
  fn from(i: i32) -> Self {
    match i {
      0 => THudiQueryType::TIMELINE,
      _ => THudiQueryType(i)
    }
  }
}

impl From<&i32> for THudiQueryType {
  fn from(i: &i32) -> Self {
    THudiQueryType::from(*i)
  }
}

impl From<THudiQueryType> for i32 {
  fn from(e: THudiQueryType) -> i32 {
    e.0
  }
}

impl From<&THudiQueryType> for i32 {
  fn from(e: &THudiQueryType) -> i32 {
    e.0
  }
}

pub type TTimestamp = i64;

pub type TPlanNodeId = i32;

pub type TTupleId = i32;

pub type TSlotId = i32;

pub type TTableId = i64;

pub type TTabletId = i64;

pub type TReplicaId = i64;

pub type TVersion = i64;

pub type TVersionHash = i64;

pub type TSchemaHash = i32;

pub type TPort = i32;

pub type TCount = i64;

pub type TSize = i64;

pub type TClusterId = i32;

pub type TEpoch = i64;

pub type TTransactionId = i64;

pub type TPartitionId = i64;

//
// TScalarType
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TScalarType {
  pub type_: TPrimitiveType,
  pub len: Option<i32>,
  pub precision: Option<i32>,
  pub scale: Option<i32>,
  pub variant_max_subcolumns_count: Option<i32>,
}

impl TScalarType {
  pub fn new<F2, F3, F4, F5>(type_: TPrimitiveType, len: F2, precision: F3, scale: F4, variant_max_subcolumns_count: F5) -> TScalarType where F2: Into<Option<i32>>, F3: Into<Option<i32>>, F4: Into<Option<i32>>, F5: Into<Option<i32>> {
    TScalarType {
      type_,
      len: len.into(),
      precision: precision.into(),
      scale: scale.into(),
      variant_max_subcolumns_count: variant_max_subcolumns_count.into(),
    }
  }
}

impl TSerializable for TScalarType {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TScalarType> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TPrimitiveType> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<i32> = None;
    let mut f_5: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TPrimitiveType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TScalarType.type_", &f_1)?;
    let ret = TScalarType {
      type_: f_1.expect("auto-generated code should have checked for presence of required fields"),
      len: f_2,
      precision: f_3,
      scale: f_4,
      variant_max_subcolumns_count: f_5,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TScalarType");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 1))?;
    self.type_.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.len {
      o_prot.write_field_begin(&TFieldIdentifier::new("len", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.precision {
      o_prot.write_field_begin(&TFieldIdentifier::new("precision", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.scale {
      o_prot.write_field_begin(&TFieldIdentifier::new("scale", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.variant_max_subcolumns_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("variant_max_subcolumns_count", TType::I32, 5))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TStructField
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TStructField {
  pub name: String,
  pub comment: Option<String>,
  pub contains_null: Option<bool>,
}

impl TStructField {
  pub fn new<F2, F3>(name: String, comment: F2, contains_null: F3) -> TStructField where F2: Into<Option<String>>, F3: Into<Option<bool>> {
    TStructField {
      name,
      comment: comment.into(),
      contains_null: contains_null.into(),
    }
  }
}

impl TSerializable for TStructField {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TStructField> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TStructField.name", &f_1)?;
    let ret = TStructField {
      name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      comment: f_2,
      contains_null: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TStructField");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 1))?;
    o_prot.write_string(&self.name)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.comment {
      o_prot.write_field_begin(&TFieldIdentifier::new("comment", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.contains_null {
      o_prot.write_field_begin(&TFieldIdentifier::new("contains_null", TType::Bool, 3))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TTypeNode
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTypeNode {
  pub type_: TTypeNodeType,
  pub scalar_type: Option<TScalarType>,
  pub struct_fields: Option<Vec<TStructField>>,
  pub contains_null: Option<bool>,
  pub contains_nulls: Option<Vec<bool>>,
}

impl TTypeNode {
  pub fn new<F2, F3, F4, F5>(type_: TTypeNodeType, scalar_type: F2, struct_fields: F3, contains_null: F4, contains_nulls: F5) -> TTypeNode where F2: Into<Option<TScalarType>>, F3: Into<Option<Vec<TStructField>>>, F4: Into<Option<bool>>, F5: Into<Option<Vec<bool>>> {
    TTypeNode {
      type_,
      scalar_type: scalar_type.into(),
      struct_fields: struct_fields.into(),
      contains_null: contains_null.into(),
      contains_nulls: contains_nulls.into(),
    }
  }
}

impl TSerializable for TTypeNode {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTypeNode> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TTypeNodeType> = None;
    let mut f_2: Option<TScalarType> = None;
    let mut f_3: Option<Vec<TStructField>> = None;
    let mut f_4: Option<bool> = None;
    let mut f_5: Option<Vec<bool>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TTypeNodeType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = TScalarType::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TStructField> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_0 = TStructField::read_from_in_protocol(i_prot)?;
            val.push(list_elem_0);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<bool> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_1 = i_prot.read_bool()?;
            val.push(list_elem_1);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TTypeNode.type_", &f_1)?;
    let ret = TTypeNode {
      type_: f_1.expect("auto-generated code should have checked for presence of required fields"),
      scalar_type: f_2,
      struct_fields: f_3,
      contains_null: f_4,
      contains_nulls: f_5,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TTypeNode");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 1))?;
    self.type_.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.scalar_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("scalar_type", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.struct_fields {
      o_prot.write_field_begin(&TFieldIdentifier::new("struct_fields", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.contains_null {
      o_prot.write_field_begin(&TFieldIdentifier::new("contains_null", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.contains_nulls {
      o_prot.write_field_begin(&TFieldIdentifier::new("contains_nulls", TType::List, 5))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Bool, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_bool(*e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TTypeDesc
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTypeDesc {
  pub types: Option<Vec<TTypeNode>>,
  pub is_nullable: Option<bool>,
  pub byte_size: Option<i64>,
  pub sub_types: Option<Vec<Box<TTypeDesc>>>,
  pub result_is_nullable: Option<bool>,
  pub function_name: Option<String>,
  pub be_exec_version: Option<i32>,
}

impl TTypeDesc {
  pub fn new<F1, F2, F3, F4, F5, F6, F7>(types: F1, is_nullable: F2, byte_size: F3, sub_types: F4, result_is_nullable: F5, function_name: F6, be_exec_version: F7) -> TTypeDesc where F1: Into<Option<Vec<TTypeNode>>>, F2: Into<Option<bool>>, F3: Into<Option<i64>>, F4: Into<Option<Vec<Box<TTypeDesc>>>>, F5: Into<Option<bool>>, F6: Into<Option<String>>, F7: Into<Option<i32>> {
    TTypeDesc {
      types: types.into(),
      is_nullable: is_nullable.into(),
      byte_size: byte_size.into(),
      sub_types: sub_types.into(),
      result_is_nullable: result_is_nullable.into(),
      function_name: function_name.into(),
      be_exec_version: be_exec_version.into(),
    }
  }
}

impl TSerializable for TTypeDesc {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTypeDesc> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<TTypeNode>> = Some(Vec::new());
    let mut f_2: Option<bool> = None;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<Vec<Box<TTypeDesc>>> = None;
    let mut f_5: Option<bool> = None;
    let mut f_6: Option<String> = None;
    let mut f_7: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TTypeNode> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_2 = TTypeNode::read_from_in_protocol(i_prot)?;
            val.push(list_elem_2);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Box<TTypeDesc>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_3 = Box::new(TTypeDesc::read_from_in_protocol(i_prot)?);
            val.push(list_elem_3);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i32()?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TTypeDesc {
      types: f_1,
      is_nullable: f_2,
      byte_size: f_3,
      sub_types: f_4,
      result_is_nullable: f_5,
      function_name: f_6,
      be_exec_version: f_7,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TTypeDesc");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.types {
      o_prot.write_field_begin(&TFieldIdentifier::new("types", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_nullable {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_nullable", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.byte_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("byte_size", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.sub_types {
      o_prot.write_field_begin(&TFieldIdentifier::new("sub_types", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.result_is_nullable {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_is_nullable", TType::Bool, 5))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.function_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("function_name", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.be_exec_version {
      o_prot.write_field_begin(&TFieldIdentifier::new("be_exec_version", TType::I32, 7))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TColumnType
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TColumnType {
  pub type_: TPrimitiveType,
  pub len: Option<i32>,
  pub index_len: Option<i32>,
  pub precision: Option<i32>,
  pub scale: Option<i32>,
  pub variant_max_subcolumns_count: Option<i32>,
}

impl TColumnType {
  pub fn new<F2, F3, F4, F5, F6>(type_: TPrimitiveType, len: F2, index_len: F3, precision: F4, scale: F5, variant_max_subcolumns_count: F6) -> TColumnType where F2: Into<Option<i32>>, F3: Into<Option<i32>>, F4: Into<Option<i32>>, F5: Into<Option<i32>>, F6: Into<Option<i32>> {
    TColumnType {
      type_,
      len: len.into(),
      index_len: index_len.into(),
      precision: precision.into(),
      scale: scale.into(),
      variant_max_subcolumns_count: variant_max_subcolumns_count.into(),
    }
  }
}

impl TSerializable for TColumnType {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TColumnType> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TPrimitiveType> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<i32> = None;
    let mut f_5: Option<i32> = None;
    let mut f_6: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TPrimitiveType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TColumnType.type_", &f_1)?;
    let ret = TColumnType {
      type_: f_1.expect("auto-generated code should have checked for presence of required fields"),
      len: f_2,
      index_len: f_3,
      precision: f_4,
      scale: f_5,
      variant_max_subcolumns_count: f_6,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TColumnType");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 1))?;
    self.type_.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.len {
      o_prot.write_field_begin(&TFieldIdentifier::new("len", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.index_len {
      o_prot.write_field_begin(&TFieldIdentifier::new("index_len", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.precision {
      o_prot.write_field_begin(&TFieldIdentifier::new("precision", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.scale {
      o_prot.write_field_begin(&TFieldIdentifier::new("scale", TType::I32, 5))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.variant_max_subcolumns_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("variant_max_subcolumns_count", TType::I32, 6))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TNetworkAddress
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TNetworkAddress {
  pub hostname: String,
  pub port: i32,
}

impl TNetworkAddress {
  pub fn new(hostname: String, port: i32) -> TNetworkAddress {
    TNetworkAddress {
      hostname,
      port,
    }
  }
}

impl TSerializable for TNetworkAddress {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TNetworkAddress> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TNetworkAddress.hostname", &f_1)?;
    verify_required_field_exists("TNetworkAddress.port", &f_2)?;
    let ret = TNetworkAddress {
      hostname: f_1.expect("auto-generated code should have checked for presence of required fields"),
      port: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TNetworkAddress");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("hostname", TType::String, 1))?;
    o_prot.write_string(&self.hostname)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("port", TType::I32, 2))?;
    o_prot.write_i32(self.port)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TUniqueId
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TUniqueId {
  pub hi: i64,
  pub lo: i64,
}

impl TUniqueId {
  pub fn new(hi: i64, lo: i64) -> TUniqueId {
    TUniqueId {
      hi,
      lo,
    }
  }
}

impl TSerializable for TUniqueId {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TUniqueId> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TUniqueId.hi", &f_1)?;
    verify_required_field_exists("TUniqueId.lo", &f_2)?;
    let ret = TUniqueId {
      hi: f_1.expect("auto-generated code should have checked for presence of required fields"),
      lo: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TUniqueId");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("hi", TType::I64, 1))?;
    o_prot.write_i64(self.hi)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("lo", TType::I64, 2))?;
    o_prot.write_i64(self.lo)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TFunctionName
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TFunctionName {
  pub db_name: Option<String>,
  pub function_name: String,
}

impl TFunctionName {
  pub fn new<F1>(db_name: F1, function_name: String) -> TFunctionName where F1: Into<Option<String>> {
    TFunctionName {
      db_name: db_name.into(),
      function_name,
    }
  }
}

impl TSerializable for TFunctionName {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TFunctionName> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TFunctionName.function_name", &f_2)?;
    let ret = TFunctionName {
      db_name: f_1,
      function_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TFunctionName");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.db_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_begin(&TFieldIdentifier::new("function_name", TType::String, 2))?;
    o_prot.write_string(&self.function_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TScalarFunction
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TScalarFunction {
  pub symbol: String,
  pub prepare_fn_symbol: Option<String>,
  pub close_fn_symbol: Option<String>,
}

impl TScalarFunction {
  pub fn new<F2, F3>(symbol: String, prepare_fn_symbol: F2, close_fn_symbol: F3) -> TScalarFunction where F2: Into<Option<String>>, F3: Into<Option<String>> {
    TScalarFunction {
      symbol,
      prepare_fn_symbol: prepare_fn_symbol.into(),
      close_fn_symbol: close_fn_symbol.into(),
    }
  }
}

impl TSerializable for TScalarFunction {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TScalarFunction> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TScalarFunction.symbol", &f_1)?;
    let ret = TScalarFunction {
      symbol: f_1.expect("auto-generated code should have checked for presence of required fields"),
      prepare_fn_symbol: f_2,
      close_fn_symbol: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TScalarFunction");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("symbol", TType::String, 1))?;
    o_prot.write_string(&self.symbol)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.prepare_fn_symbol {
      o_prot.write_field_begin(&TFieldIdentifier::new("prepare_fn_symbol", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.close_fn_symbol {
      o_prot.write_field_begin(&TFieldIdentifier::new("close_fn_symbol", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TAggregateFunction
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TAggregateFunction {
  pub intermediate_type: TTypeDesc,
  pub update_fn_symbol: Option<String>,
  pub init_fn_symbol: Option<String>,
  pub serialize_fn_symbol: Option<String>,
  pub merge_fn_symbol: Option<String>,
  pub finalize_fn_symbol: Option<String>,
  pub get_value_fn_symbol: Option<String>,
  pub remove_fn_symbol: Option<String>,
  pub is_analytic_only_fn: Option<bool>,
  pub symbol: Option<String>,
}

impl TAggregateFunction {
  pub fn new<F2, F3, F4, F5, F6, F8, F9, F10, F11>(intermediate_type: TTypeDesc, update_fn_symbol: F2, init_fn_symbol: F3, serialize_fn_symbol: F4, merge_fn_symbol: F5, finalize_fn_symbol: F6, get_value_fn_symbol: F8, remove_fn_symbol: F9, is_analytic_only_fn: F10, symbol: F11) -> TAggregateFunction where F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<String>>, F6: Into<Option<String>>, F8: Into<Option<String>>, F9: Into<Option<String>>, F10: Into<Option<bool>>, F11: Into<Option<String>> {
    TAggregateFunction {
      intermediate_type,
      update_fn_symbol: update_fn_symbol.into(),
      init_fn_symbol: init_fn_symbol.into(),
      serialize_fn_symbol: serialize_fn_symbol.into(),
      merge_fn_symbol: merge_fn_symbol.into(),
      finalize_fn_symbol: finalize_fn_symbol.into(),
      get_value_fn_symbol: get_value_fn_symbol.into(),
      remove_fn_symbol: remove_fn_symbol.into(),
      is_analytic_only_fn: is_analytic_only_fn.into(),
      symbol: symbol.into(),
    }
  }
}

impl TSerializable for TAggregateFunction {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TAggregateFunction> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TTypeDesc> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<String> = None;
    let mut f_8: Option<String> = None;
    let mut f_9: Option<String> = None;
    let mut f_10: Option<bool> = None;
    let mut f_11: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TTypeDesc::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        8 => {
          let val = i_prot.read_string()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_string()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_bool()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_string()?;
          f_11 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TAggregateFunction.intermediate_type", &f_1)?;
    let ret = TAggregateFunction {
      intermediate_type: f_1.expect("auto-generated code should have checked for presence of required fields"),
      update_fn_symbol: f_2,
      init_fn_symbol: f_3,
      serialize_fn_symbol: f_4,
      merge_fn_symbol: f_5,
      finalize_fn_symbol: f_6,
      get_value_fn_symbol: f_8,
      remove_fn_symbol: f_9,
      is_analytic_only_fn: f_10,
      symbol: f_11,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TAggregateFunction");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("intermediate_type", TType::Struct, 1))?;
    self.intermediate_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.update_fn_symbol {
      o_prot.write_field_begin(&TFieldIdentifier::new("update_fn_symbol", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.init_fn_symbol {
      o_prot.write_field_begin(&TFieldIdentifier::new("init_fn_symbol", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.serialize_fn_symbol {
      o_prot.write_field_begin(&TFieldIdentifier::new("serialize_fn_symbol", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.merge_fn_symbol {
      o_prot.write_field_begin(&TFieldIdentifier::new("merge_fn_symbol", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.finalize_fn_symbol {
      o_prot.write_field_begin(&TFieldIdentifier::new("finalize_fn_symbol", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.get_value_fn_symbol {
      o_prot.write_field_begin(&TFieldIdentifier::new("get_value_fn_symbol", TType::String, 8))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.remove_fn_symbol {
      o_prot.write_field_begin(&TFieldIdentifier::new("remove_fn_symbol", TType::String, 9))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_analytic_only_fn {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_analytic_only_fn", TType::Bool, 10))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.symbol {
      o_prot.write_field_begin(&TFieldIdentifier::new("symbol", TType::String, 11))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TDictFunction
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDictFunction {
  pub dictionary_id: Option<i64>,
  pub version_id: Option<i64>,
}

impl TDictFunction {
  pub fn new<F1, F2>(dictionary_id: F1, version_id: F2) -> TDictFunction where F1: Into<Option<i64>>, F2: Into<Option<i64>> {
    TDictFunction {
      dictionary_id: dictionary_id.into(),
      version_id: version_id.into(),
    }
  }
}

impl TSerializable for TDictFunction {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDictFunction> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TDictFunction {
      dictionary_id: f_1,
      version_id: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDictFunction");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.dictionary_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("dictionary_id", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.version_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("version_id", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TFunction
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TFunction {
  pub name: TFunctionName,
  pub binary_type: TFunctionBinaryType,
  pub arg_types: Vec<TTypeDesc>,
  pub ret_type: TTypeDesc,
  pub has_var_args: bool,
  pub comment: Option<String>,
  pub signature: Option<String>,
  pub hdfs_location: Option<String>,
  pub scalar_fn: Option<TScalarFunction>,
  pub aggregate_fn: Option<TAggregateFunction>,
  pub id: Option<i64>,
  pub checksum: Option<String>,
  pub vectorized: Option<bool>,
  pub is_udtf_function: Option<bool>,
  pub is_static_load: Option<bool>,
  pub expiration_time: Option<i64>,
  pub dict_function: Option<TDictFunction>,
}

impl TFunction {
  pub fn new<F6, F7, F8, F9, F10, F11, F12, F13, F14, F15, F16, F17>(name: TFunctionName, binary_type: TFunctionBinaryType, arg_types: Vec<TTypeDesc>, ret_type: TTypeDesc, has_var_args: bool, comment: F6, signature: F7, hdfs_location: F8, scalar_fn: F9, aggregate_fn: F10, id: F11, checksum: F12, vectorized: F13, is_udtf_function: F14, is_static_load: F15, expiration_time: F16, dict_function: F17) -> TFunction where F6: Into<Option<String>>, F7: Into<Option<String>>, F8: Into<Option<String>>, F9: Into<Option<TScalarFunction>>, F10: Into<Option<TAggregateFunction>>, F11: Into<Option<i64>>, F12: Into<Option<String>>, F13: Into<Option<bool>>, F14: Into<Option<bool>>, F15: Into<Option<bool>>, F16: Into<Option<i64>>, F17: Into<Option<TDictFunction>> {
    TFunction {
      name,
      binary_type,
      arg_types,
      ret_type,
      has_var_args,
      comment: comment.into(),
      signature: signature.into(),
      hdfs_location: hdfs_location.into(),
      scalar_fn: scalar_fn.into(),
      aggregate_fn: aggregate_fn.into(),
      id: id.into(),
      checksum: checksum.into(),
      vectorized: vectorized.into(),
      is_udtf_function: is_udtf_function.into(),
      is_static_load: is_static_load.into(),
      expiration_time: expiration_time.into(),
      dict_function: dict_function.into(),
    }
  }
}

impl TSerializable for TFunction {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TFunction> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TFunctionName> = None;
    let mut f_2: Option<TFunctionBinaryType> = None;
    let mut f_3: Option<Vec<TTypeDesc>> = None;
    let mut f_4: Option<TTypeDesc> = None;
    let mut f_5: Option<bool> = None;
    let mut f_6: Option<String> = None;
    let mut f_7: Option<String> = None;
    let mut f_8: Option<String> = None;
    let mut f_9: Option<TScalarFunction> = None;
    let mut f_10: Option<TAggregateFunction> = None;
    let mut f_11: Option<i64> = None;
    let mut f_12: Option<String> = None;
    let mut f_13: Option<bool> = None;
    let mut f_14: Option<bool> = None;
    let mut f_15: Option<bool> = None;
    let mut f_16: Option<i64> = None;
    let mut f_17: Option<TDictFunction> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TFunctionName::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = TFunctionBinaryType::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TTypeDesc> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_4 = TTypeDesc::read_from_in_protocol(i_prot)?;
            val.push(list_elem_4);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = TTypeDesc::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_string()?;
          f_8 = Some(val);
        },
        9 => {
          let val = TScalarFunction::read_from_in_protocol(i_prot)?;
          f_9 = Some(val);
        },
        10 => {
          let val = TAggregateFunction::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_i64()?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_string()?;
          f_12 = Some(val);
        },
        13 => {
          let val = i_prot.read_bool()?;
          f_13 = Some(val);
        },
        14 => {
          let val = i_prot.read_bool()?;
          f_14 = Some(val);
        },
        15 => {
          let val = i_prot.read_bool()?;
          f_15 = Some(val);
        },
        16 => {
          let val = i_prot.read_i64()?;
          f_16 = Some(val);
        },
        17 => {
          let val = TDictFunction::read_from_in_protocol(i_prot)?;
          f_17 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TFunction.name", &f_1)?;
    verify_required_field_exists("TFunction.binary_type", &f_2)?;
    verify_required_field_exists("TFunction.arg_types", &f_3)?;
    verify_required_field_exists("TFunction.ret_type", &f_4)?;
    verify_required_field_exists("TFunction.has_var_args", &f_5)?;
    let ret = TFunction {
      name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      binary_type: f_2.expect("auto-generated code should have checked for presence of required fields"),
      arg_types: f_3.expect("auto-generated code should have checked for presence of required fields"),
      ret_type: f_4.expect("auto-generated code should have checked for presence of required fields"),
      has_var_args: f_5.expect("auto-generated code should have checked for presence of required fields"),
      comment: f_6,
      signature: f_7,
      hdfs_location: f_8,
      scalar_fn: f_9,
      aggregate_fn: f_10,
      id: f_11,
      checksum: f_12,
      vectorized: f_13,
      is_udtf_function: f_14,
      is_static_load: f_15,
      expiration_time: f_16,
      dict_function: f_17,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TFunction");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::Struct, 1))?;
    self.name.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("binary_type", TType::I32, 2))?;
    self.binary_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("arg_types", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.arg_types.len() as i32))?;
    for e in &self.arg_types {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("ret_type", TType::Struct, 4))?;
    self.ret_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("has_var_args", TType::Bool, 5))?;
    o_prot.write_bool(self.has_var_args)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.comment {
      o_prot.write_field_begin(&TFieldIdentifier::new("comment", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.signature {
      o_prot.write_field_begin(&TFieldIdentifier::new("signature", TType::String, 7))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.hdfs_location {
      o_prot.write_field_begin(&TFieldIdentifier::new("hdfs_location", TType::String, 8))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.scalar_fn {
      o_prot.write_field_begin(&TFieldIdentifier::new("scalar_fn", TType::Struct, 9))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.aggregate_fn {
      o_prot.write_field_begin(&TFieldIdentifier::new("aggregate_fn", TType::Struct, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.id {
      o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::I64, 11))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.checksum {
      o_prot.write_field_begin(&TFieldIdentifier::new("checksum", TType::String, 12))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.vectorized {
      o_prot.write_field_begin(&TFieldIdentifier::new("vectorized", TType::Bool, 13))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_udtf_function {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_udtf_function", TType::Bool, 14))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_static_load {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_static_load", TType::Bool, 15))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.expiration_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("expiration_time", TType::I64, 16))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.dict_function {
      o_prot.write_field_begin(&TFieldIdentifier::new("dict_function", TType::Struct, 17))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TJdbcExecutorCtorParams
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TJdbcExecutorCtorParams {
  pub statement: Option<String>,
  pub jdbc_url: Option<String>,
  pub jdbc_user: Option<String>,
  pub jdbc_password: Option<String>,
  pub jdbc_driver_class: Option<String>,
  pub batch_size: Option<i32>,
  pub op: Option<TJdbcOperation>,
  pub driver_path: Option<String>,
  pub table_type: Option<TOdbcTableType>,
  pub connection_pool_min_size: Option<i32>,
  pub connection_pool_max_size: Option<i32>,
  pub connection_pool_max_wait_time: Option<i32>,
  pub connection_pool_max_life_time: Option<i32>,
  pub connection_pool_cache_clear_time: Option<i32>,
  pub connection_pool_keep_alive: Option<bool>,
  pub catalog_id: Option<i64>,
  pub jdbc_driver_checksum: Option<String>,
  pub is_tvf: Option<bool>,
}

impl TJdbcExecutorCtorParams {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15, F16, F17, F18>(statement: F1, jdbc_url: F2, jdbc_user: F3, jdbc_password: F4, jdbc_driver_class: F5, batch_size: F6, op: F7, driver_path: F8, table_type: F9, connection_pool_min_size: F10, connection_pool_max_size: F11, connection_pool_max_wait_time: F12, connection_pool_max_life_time: F13, connection_pool_cache_clear_time: F14, connection_pool_keep_alive: F15, catalog_id: F16, jdbc_driver_checksum: F17, is_tvf: F18) -> TJdbcExecutorCtorParams where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<String>>, F6: Into<Option<i32>>, F7: Into<Option<TJdbcOperation>>, F8: Into<Option<String>>, F9: Into<Option<TOdbcTableType>>, F10: Into<Option<i32>>, F11: Into<Option<i32>>, F12: Into<Option<i32>>, F13: Into<Option<i32>>, F14: Into<Option<i32>>, F15: Into<Option<bool>>, F16: Into<Option<i64>>, F17: Into<Option<String>>, F18: Into<Option<bool>> {
    TJdbcExecutorCtorParams {
      statement: statement.into(),
      jdbc_url: jdbc_url.into(),
      jdbc_user: jdbc_user.into(),
      jdbc_password: jdbc_password.into(),
      jdbc_driver_class: jdbc_driver_class.into(),
      batch_size: batch_size.into(),
      op: op.into(),
      driver_path: driver_path.into(),
      table_type: table_type.into(),
      connection_pool_min_size: connection_pool_min_size.into(),
      connection_pool_max_size: connection_pool_max_size.into(),
      connection_pool_max_wait_time: connection_pool_max_wait_time.into(),
      connection_pool_max_life_time: connection_pool_max_life_time.into(),
      connection_pool_cache_clear_time: connection_pool_cache_clear_time.into(),
      connection_pool_keep_alive: connection_pool_keep_alive.into(),
      catalog_id: catalog_id.into(),
      jdbc_driver_checksum: jdbc_driver_checksum.into(),
      is_tvf: is_tvf.into(),
    }
  }
}

impl TSerializable for TJdbcExecutorCtorParams {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TJdbcExecutorCtorParams> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<i32> = None;
    let mut f_7: Option<TJdbcOperation> = None;
    let mut f_8: Option<String> = None;
    let mut f_9: Option<TOdbcTableType> = None;
    let mut f_10: Option<i32> = None;
    let mut f_11: Option<i32> = None;
    let mut f_12: Option<i32> = None;
    let mut f_13: Option<i32> = None;
    let mut f_14: Option<i32> = None;
    let mut f_15: Option<bool> = None;
    let mut f_16: Option<i64> = None;
    let mut f_17: Option<String> = None;
    let mut f_18: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        7 => {
          let val = TJdbcOperation::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_string()?;
          f_8 = Some(val);
        },
        9 => {
          let val = TOdbcTableType::read_from_in_protocol(i_prot)?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_i32()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_i32()?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_i32()?;
          f_12 = Some(val);
        },
        13 => {
          let val = i_prot.read_i32()?;
          f_13 = Some(val);
        },
        14 => {
          let val = i_prot.read_i32()?;
          f_14 = Some(val);
        },
        15 => {
          let val = i_prot.read_bool()?;
          f_15 = Some(val);
        },
        16 => {
          let val = i_prot.read_i64()?;
          f_16 = Some(val);
        },
        17 => {
          let val = i_prot.read_string()?;
          f_17 = Some(val);
        },
        18 => {
          let val = i_prot.read_bool()?;
          f_18 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TJdbcExecutorCtorParams {
      statement: f_1,
      jdbc_url: f_2,
      jdbc_user: f_3,
      jdbc_password: f_4,
      jdbc_driver_class: f_5,
      batch_size: f_6,
      op: f_7,
      driver_path: f_8,
      table_type: f_9,
      connection_pool_min_size: f_10,
      connection_pool_max_size: f_11,
      connection_pool_max_wait_time: f_12,
      connection_pool_max_life_time: f_13,
      connection_pool_cache_clear_time: f_14,
      connection_pool_keep_alive: f_15,
      catalog_id: f_16,
      jdbc_driver_checksum: f_17,
      is_tvf: f_18,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TJdbcExecutorCtorParams");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.statement {
      o_prot.write_field_begin(&TFieldIdentifier::new("statement", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.jdbc_url {
      o_prot.write_field_begin(&TFieldIdentifier::new("jdbc_url", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.jdbc_user {
      o_prot.write_field_begin(&TFieldIdentifier::new("jdbc_user", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.jdbc_password {
      o_prot.write_field_begin(&TFieldIdentifier::new("jdbc_password", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.jdbc_driver_class {
      o_prot.write_field_begin(&TFieldIdentifier::new("jdbc_driver_class", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.batch_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("batch_size", TType::I32, 6))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.op {
      o_prot.write_field_begin(&TFieldIdentifier::new("op", TType::I32, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.driver_path {
      o_prot.write_field_begin(&TFieldIdentifier::new("driver_path", TType::String, 8))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.table_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_type", TType::I32, 9))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.connection_pool_min_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("connection_pool_min_size", TType::I32, 10))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.connection_pool_max_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("connection_pool_max_size", TType::I32, 11))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.connection_pool_max_wait_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("connection_pool_max_wait_time", TType::I32, 12))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.connection_pool_max_life_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("connection_pool_max_life_time", TType::I32, 13))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.connection_pool_cache_clear_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("connection_pool_cache_clear_time", TType::I32, 14))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.connection_pool_keep_alive {
      o_prot.write_field_begin(&TFieldIdentifier::new("connection_pool_keep_alive", TType::Bool, 15))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.catalog_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("catalog_id", TType::I64, 16))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.jdbc_driver_checksum {
      o_prot.write_field_begin(&TFieldIdentifier::new("jdbc_driver_checksum", TType::String, 17))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_tvf {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_tvf", TType::Bool, 18))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TJavaUdfExecutorCtorParams
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TJavaUdfExecutorCtorParams {
  pub fn_: Option<TFunction>,
  pub location: Option<String>,
  pub input_offsets_ptrs: Option<i64>,
  pub input_nulls_ptrs: Option<i64>,
  pub input_buffer_ptrs: Option<i64>,
  pub output_null_ptr: Option<i64>,
  pub output_buffer_ptr: Option<i64>,
  pub output_offsets_ptr: Option<i64>,
  pub output_intermediate_state_ptr: Option<i64>,
  pub batch_size_ptr: Option<i64>,
  pub input_places_ptr: Option<i64>,
  pub input_array_nulls_buffer_ptr: Option<i64>,
  pub input_array_string_offsets_ptrs: Option<i64>,
  pub output_array_null_ptr: Option<i64>,
  pub output_array_string_offsets_ptr: Option<i64>,
}

impl TJavaUdfExecutorCtorParams {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15>(fn_: F1, location: F2, input_offsets_ptrs: F3, input_nulls_ptrs: F4, input_buffer_ptrs: F5, output_null_ptr: F6, output_buffer_ptr: F7, output_offsets_ptr: F8, output_intermediate_state_ptr: F9, batch_size_ptr: F10, input_places_ptr: F11, input_array_nulls_buffer_ptr: F12, input_array_string_offsets_ptrs: F13, output_array_null_ptr: F14, output_array_string_offsets_ptr: F15) -> TJavaUdfExecutorCtorParams where F1: Into<Option<TFunction>>, F2: Into<Option<String>>, F3: Into<Option<i64>>, F4: Into<Option<i64>>, F5: Into<Option<i64>>, F6: Into<Option<i64>>, F7: Into<Option<i64>>, F8: Into<Option<i64>>, F9: Into<Option<i64>>, F10: Into<Option<i64>>, F11: Into<Option<i64>>, F12: Into<Option<i64>>, F13: Into<Option<i64>>, F14: Into<Option<i64>>, F15: Into<Option<i64>> {
    TJavaUdfExecutorCtorParams {
      fn_: fn_.into(),
      location: location.into(),
      input_offsets_ptrs: input_offsets_ptrs.into(),
      input_nulls_ptrs: input_nulls_ptrs.into(),
      input_buffer_ptrs: input_buffer_ptrs.into(),
      output_null_ptr: output_null_ptr.into(),
      output_buffer_ptr: output_buffer_ptr.into(),
      output_offsets_ptr: output_offsets_ptr.into(),
      output_intermediate_state_ptr: output_intermediate_state_ptr.into(),
      batch_size_ptr: batch_size_ptr.into(),
      input_places_ptr: input_places_ptr.into(),
      input_array_nulls_buffer_ptr: input_array_nulls_buffer_ptr.into(),
      input_array_string_offsets_ptrs: input_array_string_offsets_ptrs.into(),
      output_array_null_ptr: output_array_null_ptr.into(),
      output_array_string_offsets_ptr: output_array_string_offsets_ptr.into(),
    }
  }
}

impl TSerializable for TJavaUdfExecutorCtorParams {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TJavaUdfExecutorCtorParams> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TFunction> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<i64> = None;
    let mut f_5: Option<i64> = None;
    let mut f_6: Option<i64> = None;
    let mut f_7: Option<i64> = None;
    let mut f_8: Option<i64> = None;
    let mut f_9: Option<i64> = None;
    let mut f_10: Option<i64> = None;
    let mut f_11: Option<i64> = None;
    let mut f_12: Option<i64> = None;
    let mut f_13: Option<i64> = None;
    let mut f_14: Option<i64> = None;
    let mut f_15: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TFunction::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i64()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i64()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i64()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_i64()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_i64()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_i64()?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_i64()?;
          f_12 = Some(val);
        },
        13 => {
          let val = i_prot.read_i64()?;
          f_13 = Some(val);
        },
        14 => {
          let val = i_prot.read_i64()?;
          f_14 = Some(val);
        },
        15 => {
          let val = i_prot.read_i64()?;
          f_15 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TJavaUdfExecutorCtorParams {
      fn_: f_1,
      location: f_2,
      input_offsets_ptrs: f_3,
      input_nulls_ptrs: f_4,
      input_buffer_ptrs: f_5,
      output_null_ptr: f_6,
      output_buffer_ptr: f_7,
      output_offsets_ptr: f_8,
      output_intermediate_state_ptr: f_9,
      batch_size_ptr: f_10,
      input_places_ptr: f_11,
      input_array_nulls_buffer_ptr: f_12,
      input_array_string_offsets_ptrs: f_13,
      output_array_null_ptr: f_14,
      output_array_string_offsets_ptr: f_15,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TJavaUdfExecutorCtorParams");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.fn_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("fn", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.location {
      o_prot.write_field_begin(&TFieldIdentifier::new("location", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.input_offsets_ptrs {
      o_prot.write_field_begin(&TFieldIdentifier::new("input_offsets_ptrs", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.input_nulls_ptrs {
      o_prot.write_field_begin(&TFieldIdentifier::new("input_nulls_ptrs", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.input_buffer_ptrs {
      o_prot.write_field_begin(&TFieldIdentifier::new("input_buffer_ptrs", TType::I64, 5))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.output_null_ptr {
      o_prot.write_field_begin(&TFieldIdentifier::new("output_null_ptr", TType::I64, 6))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.output_buffer_ptr {
      o_prot.write_field_begin(&TFieldIdentifier::new("output_buffer_ptr", TType::I64, 7))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.output_offsets_ptr {
      o_prot.write_field_begin(&TFieldIdentifier::new("output_offsets_ptr", TType::I64, 8))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.output_intermediate_state_ptr {
      o_prot.write_field_begin(&TFieldIdentifier::new("output_intermediate_state_ptr", TType::I64, 9))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.batch_size_ptr {
      o_prot.write_field_begin(&TFieldIdentifier::new("batch_size_ptr", TType::I64, 10))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.input_places_ptr {
      o_prot.write_field_begin(&TFieldIdentifier::new("input_places_ptr", TType::I64, 11))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.input_array_nulls_buffer_ptr {
      o_prot.write_field_begin(&TFieldIdentifier::new("input_array_nulls_buffer_ptr", TType::I64, 12))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.input_array_string_offsets_ptrs {
      o_prot.write_field_begin(&TFieldIdentifier::new("input_array_string_offsets_ptrs", TType::I64, 13))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.output_array_null_ptr {
      o_prot.write_field_begin(&TFieldIdentifier::new("output_array_null_ptr", TType::I64, 14))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.output_array_string_offsets_ptr {
      o_prot.write_field_begin(&TFieldIdentifier::new("output_array_string_offsets_ptr", TType::I64, 15))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TJvmMemoryPool
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TJvmMemoryPool {
  pub committed: i64,
  pub init: i64,
  pub max: i64,
  pub used: i64,
  pub peak_committed: i64,
  pub peak_init: i64,
  pub peak_max: i64,
  pub peak_used: i64,
  pub name: String,
}

impl TJvmMemoryPool {
  pub fn new(committed: i64, init: i64, max: i64, used: i64, peak_committed: i64, peak_init: i64, peak_max: i64, peak_used: i64, name: String) -> TJvmMemoryPool {
    TJvmMemoryPool {
      committed,
      init,
      max,
      used,
      peak_committed,
      peak_init,
      peak_max,
      peak_used,
      name,
    }
  }
}

impl TSerializable for TJvmMemoryPool {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TJvmMemoryPool> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<i64> = None;
    let mut f_5: Option<i64> = None;
    let mut f_6: Option<i64> = None;
    let mut f_7: Option<i64> = None;
    let mut f_8: Option<i64> = None;
    let mut f_9: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i64()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i64()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i64()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_string()?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TJvmMemoryPool.committed", &f_1)?;
    verify_required_field_exists("TJvmMemoryPool.init", &f_2)?;
    verify_required_field_exists("TJvmMemoryPool.max", &f_3)?;
    verify_required_field_exists("TJvmMemoryPool.used", &f_4)?;
    verify_required_field_exists("TJvmMemoryPool.peak_committed", &f_5)?;
    verify_required_field_exists("TJvmMemoryPool.peak_init", &f_6)?;
    verify_required_field_exists("TJvmMemoryPool.peak_max", &f_7)?;
    verify_required_field_exists("TJvmMemoryPool.peak_used", &f_8)?;
    verify_required_field_exists("TJvmMemoryPool.name", &f_9)?;
    let ret = TJvmMemoryPool {
      committed: f_1.expect("auto-generated code should have checked for presence of required fields"),
      init: f_2.expect("auto-generated code should have checked for presence of required fields"),
      max: f_3.expect("auto-generated code should have checked for presence of required fields"),
      used: f_4.expect("auto-generated code should have checked for presence of required fields"),
      peak_committed: f_5.expect("auto-generated code should have checked for presence of required fields"),
      peak_init: f_6.expect("auto-generated code should have checked for presence of required fields"),
      peak_max: f_7.expect("auto-generated code should have checked for presence of required fields"),
      peak_used: f_8.expect("auto-generated code should have checked for presence of required fields"),
      name: f_9.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TJvmMemoryPool");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("committed", TType::I64, 1))?;
    o_prot.write_i64(self.committed)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("init", TType::I64, 2))?;
    o_prot.write_i64(self.init)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("max", TType::I64, 3))?;
    o_prot.write_i64(self.max)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("used", TType::I64, 4))?;
    o_prot.write_i64(self.used)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("peak_committed", TType::I64, 5))?;
    o_prot.write_i64(self.peak_committed)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("peak_init", TType::I64, 6))?;
    o_prot.write_i64(self.peak_init)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("peak_max", TType::I64, 7))?;
    o_prot.write_i64(self.peak_max)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("peak_used", TType::I64, 8))?;
    o_prot.write_i64(self.peak_used)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 9))?;
    o_prot.write_string(&self.name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TGetJvmMemoryMetricsResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TGetJvmMemoryMetricsResponse {
  pub memory_pools: Vec<TJvmMemoryPool>,
  pub gc_num_warn_threshold_exceeded: i64,
  pub gc_num_info_threshold_exceeded: i64,
  pub gc_total_extra_sleep_time_millis: i64,
  pub gc_count: i64,
  pub gc_time_millis: i64,
}

impl TGetJvmMemoryMetricsResponse {
  pub fn new(memory_pools: Vec<TJvmMemoryPool>, gc_num_warn_threshold_exceeded: i64, gc_num_info_threshold_exceeded: i64, gc_total_extra_sleep_time_millis: i64, gc_count: i64, gc_time_millis: i64) -> TGetJvmMemoryMetricsResponse {
    TGetJvmMemoryMetricsResponse {
      memory_pools,
      gc_num_warn_threshold_exceeded,
      gc_num_info_threshold_exceeded,
      gc_total_extra_sleep_time_millis,
      gc_count,
      gc_time_millis,
    }
  }
}

impl TSerializable for TGetJvmMemoryMetricsResponse {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TGetJvmMemoryMetricsResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<TJvmMemoryPool>> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<i64> = None;
    let mut f_5: Option<i64> = None;
    let mut f_6: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TJvmMemoryPool> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_5 = TJvmMemoryPool::read_from_in_protocol(i_prot)?;
            val.push(list_elem_5);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i64()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TGetJvmMemoryMetricsResponse.memory_pools", &f_1)?;
    verify_required_field_exists("TGetJvmMemoryMetricsResponse.gc_num_warn_threshold_exceeded", &f_2)?;
    verify_required_field_exists("TGetJvmMemoryMetricsResponse.gc_num_info_threshold_exceeded", &f_3)?;
    verify_required_field_exists("TGetJvmMemoryMetricsResponse.gc_total_extra_sleep_time_millis", &f_4)?;
    verify_required_field_exists("TGetJvmMemoryMetricsResponse.gc_count", &f_5)?;
    verify_required_field_exists("TGetJvmMemoryMetricsResponse.gc_time_millis", &f_6)?;
    let ret = TGetJvmMemoryMetricsResponse {
      memory_pools: f_1.expect("auto-generated code should have checked for presence of required fields"),
      gc_num_warn_threshold_exceeded: f_2.expect("auto-generated code should have checked for presence of required fields"),
      gc_num_info_threshold_exceeded: f_3.expect("auto-generated code should have checked for presence of required fields"),
      gc_total_extra_sleep_time_millis: f_4.expect("auto-generated code should have checked for presence of required fields"),
      gc_count: f_5.expect("auto-generated code should have checked for presence of required fields"),
      gc_time_millis: f_6.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TGetJvmMemoryMetricsResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("memory_pools", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.memory_pools.len() as i32))?;
    for e in &self.memory_pools {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("gc_num_warn_threshold_exceeded", TType::I64, 2))?;
    o_prot.write_i64(self.gc_num_warn_threshold_exceeded)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("gc_num_info_threshold_exceeded", TType::I64, 3))?;
    o_prot.write_i64(self.gc_num_info_threshold_exceeded)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("gc_total_extra_sleep_time_millis", TType::I64, 4))?;
    o_prot.write_i64(self.gc_total_extra_sleep_time_millis)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("gc_count", TType::I64, 5))?;
    o_prot.write_i64(self.gc_count)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("gc_time_millis", TType::I64, 6))?;
    o_prot.write_i64(self.gc_time_millis)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TJvmThreadInfo
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TJvmThreadInfo {
  pub summary: String,
  pub cpu_time_in_ns: i64,
  pub user_time_in_ns: i64,
  pub blocked_count: i64,
  pub blocked_time_in_ms: i64,
  pub is_in_native: bool,
}

impl TJvmThreadInfo {
  pub fn new(summary: String, cpu_time_in_ns: i64, user_time_in_ns: i64, blocked_count: i64, blocked_time_in_ms: i64, is_in_native: bool) -> TJvmThreadInfo {
    TJvmThreadInfo {
      summary,
      cpu_time_in_ns,
      user_time_in_ns,
      blocked_count,
      blocked_time_in_ms,
      is_in_native,
    }
  }
}

impl TSerializable for TJvmThreadInfo {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TJvmThreadInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<i64> = None;
    let mut f_5: Option<i64> = None;
    let mut f_6: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TJvmThreadInfo.summary", &f_1)?;
    verify_required_field_exists("TJvmThreadInfo.cpu_time_in_ns", &f_2)?;
    verify_required_field_exists("TJvmThreadInfo.user_time_in_ns", &f_3)?;
    verify_required_field_exists("TJvmThreadInfo.blocked_count", &f_4)?;
    verify_required_field_exists("TJvmThreadInfo.blocked_time_in_ms", &f_5)?;
    verify_required_field_exists("TJvmThreadInfo.is_in_native", &f_6)?;
    let ret = TJvmThreadInfo {
      summary: f_1.expect("auto-generated code should have checked for presence of required fields"),
      cpu_time_in_ns: f_2.expect("auto-generated code should have checked for presence of required fields"),
      user_time_in_ns: f_3.expect("auto-generated code should have checked for presence of required fields"),
      blocked_count: f_4.expect("auto-generated code should have checked for presence of required fields"),
      blocked_time_in_ms: f_5.expect("auto-generated code should have checked for presence of required fields"),
      is_in_native: f_6.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TJvmThreadInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("summary", TType::String, 1))?;
    o_prot.write_string(&self.summary)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("cpu_time_in_ns", TType::I64, 2))?;
    o_prot.write_i64(self.cpu_time_in_ns)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("user_time_in_ns", TType::I64, 3))?;
    o_prot.write_i64(self.user_time_in_ns)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("blocked_count", TType::I64, 4))?;
    o_prot.write_i64(self.blocked_count)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("blocked_time_in_ms", TType::I64, 5))?;
    o_prot.write_i64(self.blocked_time_in_ms)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("is_in_native", TType::Bool, 6))?;
    o_prot.write_bool(self.is_in_native)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TGetJvmThreadsInfoRequest
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TGetJvmThreadsInfoRequest {
  pub get_complete_info: bool,
}

impl TGetJvmThreadsInfoRequest {
  pub fn new(get_complete_info: bool) -> TGetJvmThreadsInfoRequest {
    TGetJvmThreadsInfoRequest {
      get_complete_info,
    }
  }
}

impl TSerializable for TGetJvmThreadsInfoRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TGetJvmThreadsInfoRequest> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TGetJvmThreadsInfoRequest.get_complete_info", &f_1)?;
    let ret = TGetJvmThreadsInfoRequest {
      get_complete_info: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TGetJvmThreadsInfoRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("get_complete_info", TType::Bool, 1))?;
    o_prot.write_bool(self.get_complete_info)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TGetJvmThreadsInfoResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TGetJvmThreadsInfoResponse {
  pub total_thread_count: i32,
  pub daemon_thread_count: i32,
  pub peak_thread_count: i32,
  pub threads: Option<Vec<TJvmThreadInfo>>,
}

impl TGetJvmThreadsInfoResponse {
  pub fn new<F4>(total_thread_count: i32, daemon_thread_count: i32, peak_thread_count: i32, threads: F4) -> TGetJvmThreadsInfoResponse where F4: Into<Option<Vec<TJvmThreadInfo>>> {
    TGetJvmThreadsInfoResponse {
      total_thread_count,
      daemon_thread_count,
      peak_thread_count,
      threads: threads.into(),
    }
  }
}

impl TSerializable for TGetJvmThreadsInfoResponse {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TGetJvmThreadsInfoResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<Vec<TJvmThreadInfo>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TJvmThreadInfo> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_6 = TJvmThreadInfo::read_from_in_protocol(i_prot)?;
            val.push(list_elem_6);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TGetJvmThreadsInfoResponse.total_thread_count", &f_1)?;
    verify_required_field_exists("TGetJvmThreadsInfoResponse.daemon_thread_count", &f_2)?;
    verify_required_field_exists("TGetJvmThreadsInfoResponse.peak_thread_count", &f_3)?;
    let ret = TGetJvmThreadsInfoResponse {
      total_thread_count: f_1.expect("auto-generated code should have checked for presence of required fields"),
      daemon_thread_count: f_2.expect("auto-generated code should have checked for presence of required fields"),
      peak_thread_count: f_3.expect("auto-generated code should have checked for presence of required fields"),
      threads: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TGetJvmThreadsInfoResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("total_thread_count", TType::I32, 1))?;
    o_prot.write_i32(self.total_thread_count)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("daemon_thread_count", TType::I32, 2))?;
    o_prot.write_i32(self.daemon_thread_count)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("peak_thread_count", TType::I32, 3))?;
    o_prot.write_i32(self.peak_thread_count)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.threads {
      o_prot.write_field_begin(&TFieldIdentifier::new("threads", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TGetJMXJsonResponse
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TGetJMXJsonResponse {
  pub jmx_json: String,
}

impl TGetJMXJsonResponse {
  pub fn new(jmx_json: String) -> TGetJMXJsonResponse {
    TGetJMXJsonResponse {
      jmx_json,
    }
  }
}

impl TSerializable for TGetJMXJsonResponse {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TGetJMXJsonResponse> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TGetJMXJsonResponse.jmx_json", &f_1)?;
    let ret = TGetJMXJsonResponse {
      jmx_json: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TGetJMXJsonResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jmx_json", TType::String, 1))?;
    o_prot.write_string(&self.jmx_json)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TBackend
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TBackend {
  pub host: String,
  pub be_port: TPort,
  pub http_port: TPort,
  pub brpc_port: Option<TPort>,
  pub is_alive: Option<bool>,
  pub id: Option<i64>,
}

impl TBackend {
  pub fn new<F4, F5, F6>(host: String, be_port: TPort, http_port: TPort, brpc_port: F4, is_alive: F5, id: F6) -> TBackend where F4: Into<Option<TPort>>, F5: Into<Option<bool>>, F6: Into<Option<i64>> {
    TBackend {
      host,
      be_port,
      http_port,
      brpc_port: brpc_port.into(),
      is_alive: is_alive.into(),
      id: id.into(),
    }
  }
}

impl TSerializable for TBackend {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TBackend> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<TPort> = None;
    let mut f_3: Option<TPort> = None;
    let mut f_4: Option<TPort> = None;
    let mut f_5: Option<bool> = None;
    let mut f_6: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i64()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TBackend.host", &f_1)?;
    verify_required_field_exists("TBackend.be_port", &f_2)?;
    verify_required_field_exists("TBackend.http_port", &f_3)?;
    let ret = TBackend {
      host: f_1.expect("auto-generated code should have checked for presence of required fields"),
      be_port: f_2.expect("auto-generated code should have checked for presence of required fields"),
      http_port: f_3.expect("auto-generated code should have checked for presence of required fields"),
      brpc_port: f_4,
      is_alive: f_5,
      id: f_6,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TBackend");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("host", TType::String, 1))?;
    o_prot.write_string(&self.host)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("be_port", TType::I32, 2))?;
    o_prot.write_i32(self.be_port)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("http_port", TType::I32, 3))?;
    o_prot.write_i32(self.http_port)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.brpc_port {
      o_prot.write_field_begin(&TFieldIdentifier::new("brpc_port", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_alive {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_alive", TType::Bool, 5))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.id {
      o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::I64, 6))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TReplicaInfo
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TReplicaInfo {
  pub host: String,
  pub be_port: TPort,
  pub http_port: TPort,
  pub brpc_port: TPort,
  pub replica_id: TReplicaId,
  pub is_alive: Option<bool>,
  pub backend_id: Option<i64>,
}

impl TReplicaInfo {
  pub fn new<F6, F7>(host: String, be_port: TPort, http_port: TPort, brpc_port: TPort, replica_id: TReplicaId, is_alive: F6, backend_id: F7) -> TReplicaInfo where F6: Into<Option<bool>>, F7: Into<Option<i64>> {
    TReplicaInfo {
      host,
      be_port,
      http_port,
      brpc_port,
      replica_id,
      is_alive: is_alive.into(),
      backend_id: backend_id.into(),
    }
  }
}

impl TSerializable for TReplicaInfo {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TReplicaInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<TPort> = None;
    let mut f_3: Option<TPort> = None;
    let mut f_4: Option<TPort> = None;
    let mut f_5: Option<TReplicaId> = None;
    let mut f_6: Option<bool> = None;
    let mut f_7: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i64()?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TReplicaInfo.host", &f_1)?;
    verify_required_field_exists("TReplicaInfo.be_port", &f_2)?;
    verify_required_field_exists("TReplicaInfo.http_port", &f_3)?;
    verify_required_field_exists("TReplicaInfo.brpc_port", &f_4)?;
    verify_required_field_exists("TReplicaInfo.replica_id", &f_5)?;
    let ret = TReplicaInfo {
      host: f_1.expect("auto-generated code should have checked for presence of required fields"),
      be_port: f_2.expect("auto-generated code should have checked for presence of required fields"),
      http_port: f_3.expect("auto-generated code should have checked for presence of required fields"),
      brpc_port: f_4.expect("auto-generated code should have checked for presence of required fields"),
      replica_id: f_5.expect("auto-generated code should have checked for presence of required fields"),
      is_alive: f_6,
      backend_id: f_7,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TReplicaInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("host", TType::String, 1))?;
    o_prot.write_string(&self.host)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("be_port", TType::I32, 2))?;
    o_prot.write_i32(self.be_port)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("http_port", TType::I32, 3))?;
    o_prot.write_i32(self.http_port)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("brpc_port", TType::I32, 4))?;
    o_prot.write_i32(self.brpc_port)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("replica_id", TType::I64, 5))?;
    o_prot.write_i64(self.replica_id)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.is_alive {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_alive", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.backend_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("backend_id", TType::I64, 7))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TResourceInfo
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TResourceInfo {
  pub user: String,
  pub group: String,
}

impl TResourceInfo {
  pub fn new(user: String, group: String) -> TResourceInfo {
    TResourceInfo {
      user,
      group,
    }
  }
}

impl TSerializable for TResourceInfo {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TResourceInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TResourceInfo.user", &f_1)?;
    verify_required_field_exists("TResourceInfo.group", &f_2)?;
    let ret = TResourceInfo {
      user: f_1.expect("auto-generated code should have checked for presence of required fields"),
      group: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TResourceInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("user", TType::String, 1))?;
    o_prot.write_string(&self.user)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("group", TType::String, 2))?;
    o_prot.write_string(&self.group)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TTabletCommitInfo
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTabletCommitInfo {
  pub tablet_id: i64,
  pub backend_id: i64,
  pub invalid_dict_cols: Option<Vec<String>>,
}

impl TTabletCommitInfo {
  pub fn new<F3>(tablet_id: i64, backend_id: i64, invalid_dict_cols: F3) -> TTabletCommitInfo where F3: Into<Option<Vec<String>>> {
    TTabletCommitInfo {
      tablet_id,
      backend_id,
      invalid_dict_cols: invalid_dict_cols.into(),
    }
  }
}

impl TSerializable for TTabletCommitInfo {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTabletCommitInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_7 = i_prot.read_string()?;
            val.push(list_elem_7);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TTabletCommitInfo.tablet_id", &f_1)?;
    verify_required_field_exists("TTabletCommitInfo.backend_id", &f_2)?;
    let ret = TTabletCommitInfo {
      tablet_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      backend_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      invalid_dict_cols: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TTabletCommitInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tabletId", TType::I64, 1))?;
    o_prot.write_i64(self.tablet_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("backendId", TType::I64, 2))?;
    o_prot.write_i64(self.backend_id)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.invalid_dict_cols {
      o_prot.write_field_begin(&TFieldIdentifier::new("invalid_dict_cols", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TErrorTabletInfo
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TErrorTabletInfo {
  pub tablet_id: Option<i64>,
  pub msg: Option<String>,
}

impl TErrorTabletInfo {
  pub fn new<F1, F2>(tablet_id: F1, msg: F2) -> TErrorTabletInfo where F1: Into<Option<i64>>, F2: Into<Option<String>> {
    TErrorTabletInfo {
      tablet_id: tablet_id.into(),
      msg: msg.into(),
    }
  }
}

impl TSerializable for TErrorTabletInfo {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TErrorTabletInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TErrorTabletInfo {
      tablet_id: f_1,
      msg: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TErrorTabletInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.tablet_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("tabletId", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.msg {
      o_prot.write_field_begin(&TFieldIdentifier::new("msg", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TUserIdentity
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TUserIdentity {
  pub username: Option<String>,
  pub host: Option<String>,
  pub is_domain: Option<bool>,
}

impl TUserIdentity {
  pub fn new<F1, F2, F3>(username: F1, host: F2, is_domain: F3) -> TUserIdentity where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<bool>> {
    TUserIdentity {
      username: username.into(),
      host: host.into(),
      is_domain: is_domain.into(),
    }
  }
}

impl TSerializable for TUserIdentity {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TUserIdentity> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TUserIdentity {
      username: f_1,
      host: f_2,
      is_domain: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TUserIdentity");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.username {
      o_prot.write_field_begin(&TFieldIdentifier::new("username", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.host {
      o_prot.write_field_begin(&TFieldIdentifier::new("host", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_domain", TType::Bool, 3))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

pub const TSNAPSHOT_REQ_VERSION1: i32 = 3;

pub const TSNAPSHOT_REQ_VERSION2: i32 = 4;

pub const TPREFER_SNAPSHOT_REQ_VERSION: i32 = 4;

