// Autogenerated by Thrift Compiler (0.22.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(dead_code)]
#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![allow(clippy::too_many_arguments, clippy::type_complexity, clippy::vec_box, clippy::wrong_self_convention)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;

use thrift::OrderedFloat;
use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSerializable, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

use crate::exprs;
use crate::partitions;
use crate::types;

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TPatternType(pub i32);

impl TPatternType {
  pub const MATCH_NAME: TPatternType = TPatternType(1);
  pub const MATCH_NAME_GLOB: TPatternType = TPatternType(2);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::MATCH_NAME,
    Self::MATCH_NAME_GLOB,
  ];
}

impl TSerializable for TPatternType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TPatternType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TPatternType::from(enum_value))
  }
}

impl From<i32> for TPatternType {
  fn from(i: i32) -> Self {
    match i {
      1 => TPatternType::MATCH_NAME,
      2 => TPatternType::MATCH_NAME_GLOB,
      _ => TPatternType(i)
    }
  }
}

impl From<&i32> for TPatternType {
  fn from(i: &i32) -> Self {
    TPatternType::from(*i)
  }
}

impl From<TPatternType> for i32 {
  fn from(e: TPatternType) -> i32 {
    e.0
  }
}

impl From<&TPatternType> for i32 {
  fn from(e: &TPatternType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct THdfsFileFormat(pub i32);

impl THdfsFileFormat {
  pub const TEXT: THdfsFileFormat = THdfsFileFormat(0);
  pub const LZO_TEXT: THdfsFileFormat = THdfsFileFormat(1);
  pub const RC_FILE: THdfsFileFormat = THdfsFileFormat(2);
  pub const SEQUENCE_FILE: THdfsFileFormat = THdfsFileFormat(3);
  pub const AVRO: THdfsFileFormat = THdfsFileFormat(4);
  pub const PARQUET: THdfsFileFormat = THdfsFileFormat(5);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::TEXT,
    Self::LZO_TEXT,
    Self::RC_FILE,
    Self::SEQUENCE_FILE,
    Self::AVRO,
    Self::PARQUET,
  ];
}

impl TSerializable for THdfsFileFormat {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<THdfsFileFormat> {
    let enum_value = i_prot.read_i32()?;
    Ok(THdfsFileFormat::from(enum_value))
  }
}

impl From<i32> for THdfsFileFormat {
  fn from(i: i32) -> Self {
    match i {
      0 => THdfsFileFormat::TEXT,
      1 => THdfsFileFormat::LZO_TEXT,
      2 => THdfsFileFormat::RC_FILE,
      3 => THdfsFileFormat::SEQUENCE_FILE,
      4 => THdfsFileFormat::AVRO,
      5 => THdfsFileFormat::PARQUET,
      _ => THdfsFileFormat(i)
    }
  }
}

impl From<&i32> for THdfsFileFormat {
  fn from(i: &i32) -> Self {
    THdfsFileFormat::from(*i)
  }
}

impl From<THdfsFileFormat> for i32 {
  fn from(e: THdfsFileFormat) -> i32 {
    e.0
  }
}

impl From<&THdfsFileFormat> for i32 {
  fn from(e: &THdfsFileFormat) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSchemaTableType(pub i32);

impl TSchemaTableType {
  pub const SCH_AUTHORS: TSchemaTableType = TSchemaTableType(0);
  pub const SCH_CHARSETS: TSchemaTableType = TSchemaTableType(1);
  pub const SCH_COLLATIONS: TSchemaTableType = TSchemaTableType(2);
  pub const SCH_COLLATION_CHARACTER_SET_APPLICABILITY: TSchemaTableType = TSchemaTableType(3);
  pub const SCH_COLUMNS: TSchemaTableType = TSchemaTableType(4);
  pub const SCH_COLUMN_PRIVILEGES: TSchemaTableType = TSchemaTableType(5);
  pub const SCH_CREATE_TABLE: TSchemaTableType = TSchemaTableType(6);
  pub const SCH_ENGINES: TSchemaTableType = TSchemaTableType(7);
  pub const SCH_EVENTS: TSchemaTableType = TSchemaTableType(8);
  pub const SCH_FILES: TSchemaTableType = TSchemaTableType(9);
  pub const SCH_GLOBAL_STATUS: TSchemaTableType = TSchemaTableType(10);
  pub const SCH_GLOBAL_VARIABLES: TSchemaTableType = TSchemaTableType(11);
  pub const SCH_KEY_COLUMN_USAGE: TSchemaTableType = TSchemaTableType(12);
  pub const SCH_OPEN_TABLES: TSchemaTableType = TSchemaTableType(13);
  pub const SCH_PARTITIONS: TSchemaTableType = TSchemaTableType(14);
  pub const SCH_PLUGINS: TSchemaTableType = TSchemaTableType(15);
  pub const SCH_PROCESSLIST: TSchemaTableType = TSchemaTableType(16);
  pub const SCH_PROFILES: TSchemaTableType = TSchemaTableType(17);
  pub const SCH_REFERENTIAL_CONSTRAINTS: TSchemaTableType = TSchemaTableType(18);
  pub const SCH_PROCEDURES: TSchemaTableType = TSchemaTableType(19);
  pub const SCH_SCHEMATA: TSchemaTableType = TSchemaTableType(20);
  pub const SCH_SCHEMA_PRIVILEGES: TSchemaTableType = TSchemaTableType(21);
  pub const SCH_SESSION_STATUS: TSchemaTableType = TSchemaTableType(22);
  pub const SCH_SESSION_VARIABLES: TSchemaTableType = TSchemaTableType(23);
  pub const SCH_STATISTICS: TSchemaTableType = TSchemaTableType(24);
  pub const SCH_STATUS: TSchemaTableType = TSchemaTableType(25);
  pub const SCH_TABLES: TSchemaTableType = TSchemaTableType(26);
  pub const SCH_TABLE_CONSTRAINTS: TSchemaTableType = TSchemaTableType(27);
  pub const SCH_TABLE_NAMES: TSchemaTableType = TSchemaTableType(28);
  pub const SCH_TABLE_PRIVILEGES: TSchemaTableType = TSchemaTableType(29);
  pub const SCH_TRIGGERS: TSchemaTableType = TSchemaTableType(30);
  pub const SCH_USER_PRIVILEGES: TSchemaTableType = TSchemaTableType(31);
  pub const SCH_VARIABLES: TSchemaTableType = TSchemaTableType(32);
  pub const SCH_VIEWS: TSchemaTableType = TSchemaTableType(33);
  pub const SCH_INVALID: TSchemaTableType = TSchemaTableType(34);
  pub const SCH_ROWSETS: TSchemaTableType = TSchemaTableType(35);
  pub const SCH_BACKENDS: TSchemaTableType = TSchemaTableType(36);
  pub const SCH_COLUMN_STATISTICS: TSchemaTableType = TSchemaTableType(37);
  pub const SCH_PARAMETERS: TSchemaTableType = TSchemaTableType(38);
  pub const SCH_METADATA_NAME_IDS: TSchemaTableType = TSchemaTableType(39);
  pub const SCH_PROFILING: TSchemaTableType = TSchemaTableType(40);
  pub const SCH_BACKEND_ACTIVE_TASKS: TSchemaTableType = TSchemaTableType(41);
  pub const SCH_ACTIVE_QUERIES: TSchemaTableType = TSchemaTableType(42);
  pub const SCH_WORKLOAD_GROUPS: TSchemaTableType = TSchemaTableType(43);
  pub const SCH_USER: TSchemaTableType = TSchemaTableType(44);
  pub const SCH_PROCS_PRIV: TSchemaTableType = TSchemaTableType(45);
  pub const SCH_WORKLOAD_POLICY: TSchemaTableType = TSchemaTableType(46);
  pub const SCH_TABLE_OPTIONS: TSchemaTableType = TSchemaTableType(47);
  pub const SCH_WORKLOAD_GROUP_PRIVILEGES: TSchemaTableType = TSchemaTableType(48);
  pub const SCH_WORKLOAD_GROUP_RESOURCE_USAGE: TSchemaTableType = TSchemaTableType(49);
  pub const SCH_TABLE_PROPERTIES: TSchemaTableType = TSchemaTableType(50);
  pub const SCH_FILE_CACHE_STATISTICS: TSchemaTableType = TSchemaTableType(51);
  pub const SCH_CATALOG_META_CACHE_STATISTICS: TSchemaTableType = TSchemaTableType(52);
  pub const SCH_BACKEND_KERBEROS_TICKET_CACHE: TSchemaTableType = TSchemaTableType(53);
  pub const SCH_ROUTINE_LOAD_JOBS: TSchemaTableType = TSchemaTableType(54);
  pub const SCH_BACKEND_CONFIGURATION: TSchemaTableType = TSchemaTableType(55);
  pub const SCH_BACKEND_TABLETS: TSchemaTableType = TSchemaTableType(56);
  pub const SCH_VIEW_DEPENDENCY: TSchemaTableType = TSchemaTableType(57);
  pub const SCH_ENCRYPTION_KEYS: TSchemaTableType = TSchemaTableType(58);
  pub const SCH_SQL_BLOCK_RULE_STATUS: TSchemaTableType = TSchemaTableType(59);
  pub const SCH_CLUSTER_SNAPSHOTS: TSchemaTableType = TSchemaTableType(60);
  pub const SCH_CLUSTER_SNAPSHOT_PROPERTIES: TSchemaTableType = TSchemaTableType(61);
  pub const SCH_BLACKHOLE: TSchemaTableType = TSchemaTableType(62);
  pub const SCH_COLUMN_DATA_SIZES: TSchemaTableType = TSchemaTableType(63);
  pub const SCH_LOAD_JOBS: TSchemaTableType = TSchemaTableType(64);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::SCH_AUTHORS,
    Self::SCH_CHARSETS,
    Self::SCH_COLLATIONS,
    Self::SCH_COLLATION_CHARACTER_SET_APPLICABILITY,
    Self::SCH_COLUMNS,
    Self::SCH_COLUMN_PRIVILEGES,
    Self::SCH_CREATE_TABLE,
    Self::SCH_ENGINES,
    Self::SCH_EVENTS,
    Self::SCH_FILES,
    Self::SCH_GLOBAL_STATUS,
    Self::SCH_GLOBAL_VARIABLES,
    Self::SCH_KEY_COLUMN_USAGE,
    Self::SCH_OPEN_TABLES,
    Self::SCH_PARTITIONS,
    Self::SCH_PLUGINS,
    Self::SCH_PROCESSLIST,
    Self::SCH_PROFILES,
    Self::SCH_REFERENTIAL_CONSTRAINTS,
    Self::SCH_PROCEDURES,
    Self::SCH_SCHEMATA,
    Self::SCH_SCHEMA_PRIVILEGES,
    Self::SCH_SESSION_STATUS,
    Self::SCH_SESSION_VARIABLES,
    Self::SCH_STATISTICS,
    Self::SCH_STATUS,
    Self::SCH_TABLES,
    Self::SCH_TABLE_CONSTRAINTS,
    Self::SCH_TABLE_NAMES,
    Self::SCH_TABLE_PRIVILEGES,
    Self::SCH_TRIGGERS,
    Self::SCH_USER_PRIVILEGES,
    Self::SCH_VARIABLES,
    Self::SCH_VIEWS,
    Self::SCH_INVALID,
    Self::SCH_ROWSETS,
    Self::SCH_BACKENDS,
    Self::SCH_COLUMN_STATISTICS,
    Self::SCH_PARAMETERS,
    Self::SCH_METADATA_NAME_IDS,
    Self::SCH_PROFILING,
    Self::SCH_BACKEND_ACTIVE_TASKS,
    Self::SCH_ACTIVE_QUERIES,
    Self::SCH_WORKLOAD_GROUPS,
    Self::SCH_USER,
    Self::SCH_PROCS_PRIV,
    Self::SCH_WORKLOAD_POLICY,
    Self::SCH_TABLE_OPTIONS,
    Self::SCH_WORKLOAD_GROUP_PRIVILEGES,
    Self::SCH_WORKLOAD_GROUP_RESOURCE_USAGE,
    Self::SCH_TABLE_PROPERTIES,
    Self::SCH_FILE_CACHE_STATISTICS,
    Self::SCH_CATALOG_META_CACHE_STATISTICS,
    Self::SCH_BACKEND_KERBEROS_TICKET_CACHE,
    Self::SCH_ROUTINE_LOAD_JOBS,
    Self::SCH_BACKEND_CONFIGURATION,
    Self::SCH_BACKEND_TABLETS,
    Self::SCH_VIEW_DEPENDENCY,
    Self::SCH_ENCRYPTION_KEYS,
    Self::SCH_SQL_BLOCK_RULE_STATUS,
    Self::SCH_CLUSTER_SNAPSHOTS,
    Self::SCH_CLUSTER_SNAPSHOT_PROPERTIES,
    Self::SCH_BLACKHOLE,
    Self::SCH_COLUMN_DATA_SIZES,
    Self::SCH_LOAD_JOBS,
  ];
}

impl TSerializable for TSchemaTableType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSchemaTableType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TSchemaTableType::from(enum_value))
  }
}

impl From<i32> for TSchemaTableType {
  fn from(i: i32) -> Self {
    match i {
      0 => TSchemaTableType::SCH_AUTHORS,
      1 => TSchemaTableType::SCH_CHARSETS,
      2 => TSchemaTableType::SCH_COLLATIONS,
      3 => TSchemaTableType::SCH_COLLATION_CHARACTER_SET_APPLICABILITY,
      4 => TSchemaTableType::SCH_COLUMNS,
      5 => TSchemaTableType::SCH_COLUMN_PRIVILEGES,
      6 => TSchemaTableType::SCH_CREATE_TABLE,
      7 => TSchemaTableType::SCH_ENGINES,
      8 => TSchemaTableType::SCH_EVENTS,
      9 => TSchemaTableType::SCH_FILES,
      10 => TSchemaTableType::SCH_GLOBAL_STATUS,
      11 => TSchemaTableType::SCH_GLOBAL_VARIABLES,
      12 => TSchemaTableType::SCH_KEY_COLUMN_USAGE,
      13 => TSchemaTableType::SCH_OPEN_TABLES,
      14 => TSchemaTableType::SCH_PARTITIONS,
      15 => TSchemaTableType::SCH_PLUGINS,
      16 => TSchemaTableType::SCH_PROCESSLIST,
      17 => TSchemaTableType::SCH_PROFILES,
      18 => TSchemaTableType::SCH_REFERENTIAL_CONSTRAINTS,
      19 => TSchemaTableType::SCH_PROCEDURES,
      20 => TSchemaTableType::SCH_SCHEMATA,
      21 => TSchemaTableType::SCH_SCHEMA_PRIVILEGES,
      22 => TSchemaTableType::SCH_SESSION_STATUS,
      23 => TSchemaTableType::SCH_SESSION_VARIABLES,
      24 => TSchemaTableType::SCH_STATISTICS,
      25 => TSchemaTableType::SCH_STATUS,
      26 => TSchemaTableType::SCH_TABLES,
      27 => TSchemaTableType::SCH_TABLE_CONSTRAINTS,
      28 => TSchemaTableType::SCH_TABLE_NAMES,
      29 => TSchemaTableType::SCH_TABLE_PRIVILEGES,
      30 => TSchemaTableType::SCH_TRIGGERS,
      31 => TSchemaTableType::SCH_USER_PRIVILEGES,
      32 => TSchemaTableType::SCH_VARIABLES,
      33 => TSchemaTableType::SCH_VIEWS,
      34 => TSchemaTableType::SCH_INVALID,
      35 => TSchemaTableType::SCH_ROWSETS,
      36 => TSchemaTableType::SCH_BACKENDS,
      37 => TSchemaTableType::SCH_COLUMN_STATISTICS,
      38 => TSchemaTableType::SCH_PARAMETERS,
      39 => TSchemaTableType::SCH_METADATA_NAME_IDS,
      40 => TSchemaTableType::SCH_PROFILING,
      41 => TSchemaTableType::SCH_BACKEND_ACTIVE_TASKS,
      42 => TSchemaTableType::SCH_ACTIVE_QUERIES,
      43 => TSchemaTableType::SCH_WORKLOAD_GROUPS,
      44 => TSchemaTableType::SCH_USER,
      45 => TSchemaTableType::SCH_PROCS_PRIV,
      46 => TSchemaTableType::SCH_WORKLOAD_POLICY,
      47 => TSchemaTableType::SCH_TABLE_OPTIONS,
      48 => TSchemaTableType::SCH_WORKLOAD_GROUP_PRIVILEGES,
      49 => TSchemaTableType::SCH_WORKLOAD_GROUP_RESOURCE_USAGE,
      50 => TSchemaTableType::SCH_TABLE_PROPERTIES,
      51 => TSchemaTableType::SCH_FILE_CACHE_STATISTICS,
      52 => TSchemaTableType::SCH_CATALOG_META_CACHE_STATISTICS,
      53 => TSchemaTableType::SCH_BACKEND_KERBEROS_TICKET_CACHE,
      54 => TSchemaTableType::SCH_ROUTINE_LOAD_JOBS,
      55 => TSchemaTableType::SCH_BACKEND_CONFIGURATION,
      56 => TSchemaTableType::SCH_BACKEND_TABLETS,
      57 => TSchemaTableType::SCH_VIEW_DEPENDENCY,
      58 => TSchemaTableType::SCH_ENCRYPTION_KEYS,
      59 => TSchemaTableType::SCH_SQL_BLOCK_RULE_STATUS,
      60 => TSchemaTableType::SCH_CLUSTER_SNAPSHOTS,
      61 => TSchemaTableType::SCH_CLUSTER_SNAPSHOT_PROPERTIES,
      62 => TSchemaTableType::SCH_BLACKHOLE,
      63 => TSchemaTableType::SCH_COLUMN_DATA_SIZES,
      64 => TSchemaTableType::SCH_LOAD_JOBS,
      _ => TSchemaTableType(i)
    }
  }
}

impl From<&i32> for TSchemaTableType {
  fn from(i: &i32) -> Self {
    TSchemaTableType::from(*i)
  }
}

impl From<TSchemaTableType> for i32 {
  fn from(e: TSchemaTableType) -> i32 {
    e.0
  }
}

impl From<&TSchemaTableType> for i32 {
  fn from(e: &TSchemaTableType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct THdfsCompression(pub i32);

impl THdfsCompression {
  pub const NONE: THdfsCompression = THdfsCompression(0);
  pub const DEFAULT: THdfsCompression = THdfsCompression(1);
  pub const GZIP: THdfsCompression = THdfsCompression(2);
  pub const DEFLATE: THdfsCompression = THdfsCompression(3);
  pub const BZIP2: THdfsCompression = THdfsCompression(4);
  pub const SNAPPY: THdfsCompression = THdfsCompression(5);
  pub const SNAPPY_BLOCKED: THdfsCompression = THdfsCompression(6);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::DEFAULT,
    Self::GZIP,
    Self::DEFLATE,
    Self::BZIP2,
    Self::SNAPPY,
    Self::SNAPPY_BLOCKED,
  ];
}

impl TSerializable for THdfsCompression {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<THdfsCompression> {
    let enum_value = i_prot.read_i32()?;
    Ok(THdfsCompression::from(enum_value))
  }
}

impl From<i32> for THdfsCompression {
  fn from(i: i32) -> Self {
    match i {
      0 => THdfsCompression::NONE,
      1 => THdfsCompression::DEFAULT,
      2 => THdfsCompression::GZIP,
      3 => THdfsCompression::DEFLATE,
      4 => THdfsCompression::BZIP2,
      5 => THdfsCompression::SNAPPY,
      6 => THdfsCompression::SNAPPY_BLOCKED,
      _ => THdfsCompression(i)
    }
  }
}

impl From<&i32> for THdfsCompression {
  fn from(i: &i32) -> Self {
    THdfsCompression::from(*i)
  }
}

impl From<THdfsCompression> for i32 {
  fn from(e: THdfsCompression) -> i32 {
    e.0
  }
}

impl From<&THdfsCompression> for i32 {
  fn from(e: &THdfsCompression) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TIndexType(pub i32);

impl TIndexType {
  pub const BITMAP: TIndexType = TIndexType(0);
  pub const INVERTED: TIndexType = TIndexType(1);
  pub const BLOOMFILTER: TIndexType = TIndexType(2);
  pub const NGRAM_BF: TIndexType = TIndexType(3);
  pub const ANN: TIndexType = TIndexType(4);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::BITMAP,
    Self::INVERTED,
    Self::BLOOMFILTER,
    Self::NGRAM_BF,
    Self::ANN,
  ];
}

impl TSerializable for TIndexType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TIndexType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TIndexType::from(enum_value))
  }
}

impl From<i32> for TIndexType {
  fn from(i: i32) -> Self {
    match i {
      0 => TIndexType::BITMAP,
      1 => TIndexType::INVERTED,
      2 => TIndexType::BLOOMFILTER,
      3 => TIndexType::NGRAM_BF,
      4 => TIndexType::ANN,
      _ => TIndexType(i)
    }
  }
}

impl From<&i32> for TIndexType {
  fn from(i: &i32) -> Self {
    TIndexType::from(*i)
  }
}

impl From<TIndexType> for i32 {
  fn from(e: TIndexType) -> i32 {
    e.0
  }
}

impl From<&TIndexType> for i32 {
  fn from(e: &TIndexType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TPartialUpdateNewRowPolicy(pub i32);

impl TPartialUpdateNewRowPolicy {
  pub const APPEND: TPartialUpdateNewRowPolicy = TPartialUpdateNewRowPolicy(0);
  pub const ERROR: TPartialUpdateNewRowPolicy = TPartialUpdateNewRowPolicy(1);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::APPEND,
    Self::ERROR,
  ];
}

impl TSerializable for TPartialUpdateNewRowPolicy {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TPartialUpdateNewRowPolicy> {
    let enum_value = i_prot.read_i32()?;
    Ok(TPartialUpdateNewRowPolicy::from(enum_value))
  }
}

impl From<i32> for TPartialUpdateNewRowPolicy {
  fn from(i: i32) -> Self {
    match i {
      0 => TPartialUpdateNewRowPolicy::APPEND,
      1 => TPartialUpdateNewRowPolicy::ERROR,
      _ => TPartialUpdateNewRowPolicy(i)
    }
  }
}

impl From<&i32> for TPartialUpdateNewRowPolicy {
  fn from(i: &i32) -> Self {
    TPartialUpdateNewRowPolicy::from(*i)
  }
}

impl From<TPartialUpdateNewRowPolicy> for i32 {
  fn from(e: TPartialUpdateNewRowPolicy) -> i32 {
    e.0
  }
}

impl From<&TPartialUpdateNewRowPolicy> for i32 {
  fn from(e: &TPartialUpdateNewRowPolicy) -> i32 {
    e.0
  }
}

//
// TColumn
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TColumn {
  pub column_name: String,
  pub column_type: types::TColumnType,
  pub aggregation_type: Option<types::TAggregationType>,
  pub is_key: Option<bool>,
  pub is_allow_null: Option<bool>,
  pub default_value: Option<String>,
  pub is_bloom_filter_column: Option<bool>,
  pub define_expr: Option<exprs::TExpr>,
  pub visible: Option<bool>,
  pub children_column: Option<Vec<Box<TColumn>>>,
  pub col_unique_id: Option<i32>,
  pub has_bitmap_index: Option<bool>,
  pub has_ngram_bf_index: Option<bool>,
  pub gram_size: Option<i32>,
  pub gram_bf_size: Option<i32>,
  pub aggregation: Option<String>,
  pub result_is_nullable: Option<bool>,
  pub is_auto_increment: Option<bool>,
  pub cluster_key_id: Option<i32>,
  pub be_exec_version: Option<i32>,
  pub pattern_type: Option<TPatternType>,
  pub variant_enable_typed_paths_to_sparse: Option<bool>,
  pub is_on_update_current_timestamp: Option<bool>,
  pub variant_max_sparse_column_statistics_size: Option<i32>,
  pub variant_sparse_hash_shard_count: Option<i32>,
}

impl TColumn {
  pub fn new<F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15, F16, F17, F18, F19, F20, F21, F22, F23, F24, F25>(column_name: String, column_type: types::TColumnType, aggregation_type: F3, is_key: F4, is_allow_null: F5, default_value: F6, is_bloom_filter_column: F7, define_expr: F8, visible: F9, children_column: F10, col_unique_id: F11, has_bitmap_index: F12, has_ngram_bf_index: F13, gram_size: F14, gram_bf_size: F15, aggregation: F16, result_is_nullable: F17, is_auto_increment: F18, cluster_key_id: F19, be_exec_version: F20, pattern_type: F21, variant_enable_typed_paths_to_sparse: F22, is_on_update_current_timestamp: F23, variant_max_sparse_column_statistics_size: F24, variant_sparse_hash_shard_count: F25) -> TColumn where F3: Into<Option<types::TAggregationType>>, F4: Into<Option<bool>>, F5: Into<Option<bool>>, F6: Into<Option<String>>, F7: Into<Option<bool>>, F8: Into<Option<exprs::TExpr>>, F9: Into<Option<bool>>, F10: Into<Option<Vec<Box<TColumn>>>>, F11: Into<Option<i32>>, F12: Into<Option<bool>>, F13: Into<Option<bool>>, F14: Into<Option<i32>>, F15: Into<Option<i32>>, F16: Into<Option<String>>, F17: Into<Option<bool>>, F18: Into<Option<bool>>, F19: Into<Option<i32>>, F20: Into<Option<i32>>, F21: Into<Option<TPatternType>>, F22: Into<Option<bool>>, F23: Into<Option<bool>>, F24: Into<Option<i32>>, F25: Into<Option<i32>> {
    TColumn {
      column_name,
      column_type,
      aggregation_type: aggregation_type.into(),
      is_key: is_key.into(),
      is_allow_null: is_allow_null.into(),
      default_value: default_value.into(),
      is_bloom_filter_column: is_bloom_filter_column.into(),
      define_expr: define_expr.into(),
      visible: visible.into(),
      children_column: children_column.into(),
      col_unique_id: col_unique_id.into(),
      has_bitmap_index: has_bitmap_index.into(),
      has_ngram_bf_index: has_ngram_bf_index.into(),
      gram_size: gram_size.into(),
      gram_bf_size: gram_bf_size.into(),
      aggregation: aggregation.into(),
      result_is_nullable: result_is_nullable.into(),
      is_auto_increment: is_auto_increment.into(),
      cluster_key_id: cluster_key_id.into(),
      be_exec_version: be_exec_version.into(),
      pattern_type: pattern_type.into(),
      variant_enable_typed_paths_to_sparse: variant_enable_typed_paths_to_sparse.into(),
      is_on_update_current_timestamp: is_on_update_current_timestamp.into(),
      variant_max_sparse_column_statistics_size: variant_max_sparse_column_statistics_size.into(),
      variant_sparse_hash_shard_count: variant_sparse_hash_shard_count.into(),
    }
  }
}

impl TSerializable for TColumn {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TColumn> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::TColumnType> = None;
    let mut f_3: Option<types::TAggregationType> = None;
    let mut f_4: Option<bool> = None;
    let mut f_5: Option<bool> = None;
    let mut f_6: Option<String> = None;
    let mut f_7: Option<bool> = None;
    let mut f_8: Option<exprs::TExpr> = None;
    let mut f_9: Option<bool> = None;
    let mut f_10: Option<Vec<Box<TColumn>>> = None;
    let mut f_11: Option<i32> = None;
    let mut f_12: Option<bool> = None;
    let mut f_13: Option<bool> = None;
    let mut f_14: Option<i32> = None;
    let mut f_15: Option<i32> = None;
    let mut f_16: Option<String> = None;
    let mut f_17: Option<bool> = None;
    let mut f_18: Option<bool> = None;
    let mut f_19: Option<i32> = None;
    let mut f_20: Option<i32> = None;
    let mut f_21: Option<TPatternType> = None;
    let mut f_22: Option<bool> = None;
    let mut f_23: Option<bool> = None;
    let mut f_24: Option<i32> = None;
    let mut f_25: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = types::TColumnType::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = types::TAggregationType::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bool()?;
          f_7 = Some(val);
        },
        8 => {
          let val = exprs::TExpr::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_bool()?;
          f_9 = Some(val);
        },
        10 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Box<TColumn>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_0 = Box::new(TColumn::read_from_in_protocol(i_prot)?);
            val.push(list_elem_0);
          }
          i_prot.read_list_end()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_i32()?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_bool()?;
          f_12 = Some(val);
        },
        13 => {
          let val = i_prot.read_bool()?;
          f_13 = Some(val);
        },
        14 => {
          let val = i_prot.read_i32()?;
          f_14 = Some(val);
        },
        15 => {
          let val = i_prot.read_i32()?;
          f_15 = Some(val);
        },
        16 => {
          let val = i_prot.read_string()?;
          f_16 = Some(val);
        },
        17 => {
          let val = i_prot.read_bool()?;
          f_17 = Some(val);
        },
        18 => {
          let val = i_prot.read_bool()?;
          f_18 = Some(val);
        },
        19 => {
          let val = i_prot.read_i32()?;
          f_19 = Some(val);
        },
        20 => {
          let val = i_prot.read_i32()?;
          f_20 = Some(val);
        },
        21 => {
          let val = TPatternType::read_from_in_protocol(i_prot)?;
          f_21 = Some(val);
        },
        22 => {
          let val = i_prot.read_bool()?;
          f_22 = Some(val);
        },
        23 => {
          let val = i_prot.read_bool()?;
          f_23 = Some(val);
        },
        24 => {
          let val = i_prot.read_i32()?;
          f_24 = Some(val);
        },
        25 => {
          let val = i_prot.read_i32()?;
          f_25 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TColumn.column_name", &f_1)?;
    verify_required_field_exists("TColumn.column_type", &f_2)?;
    let ret = TColumn {
      column_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      column_type: f_2.expect("auto-generated code should have checked for presence of required fields"),
      aggregation_type: f_3,
      is_key: f_4,
      is_allow_null: f_5,
      default_value: f_6,
      is_bloom_filter_column: f_7,
      define_expr: f_8,
      visible: f_9,
      children_column: f_10,
      col_unique_id: f_11,
      has_bitmap_index: f_12,
      has_ngram_bf_index: f_13,
      gram_size: f_14,
      gram_bf_size: f_15,
      aggregation: f_16,
      result_is_nullable: f_17,
      is_auto_increment: f_18,
      cluster_key_id: f_19,
      be_exec_version: f_20,
      pattern_type: f_21,
      variant_enable_typed_paths_to_sparse: f_22,
      is_on_update_current_timestamp: f_23,
      variant_max_sparse_column_statistics_size: f_24,
      variant_sparse_hash_shard_count: f_25,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TColumn");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("column_name", TType::String, 1))?;
    o_prot.write_string(&self.column_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("column_type", TType::Struct, 2))?;
    self.column_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.aggregation_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("aggregation_type", TType::I32, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_key {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_key", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_allow_null {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_allow_null", TType::Bool, 5))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.default_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("default_value", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_bloom_filter_column {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_bloom_filter_column", TType::Bool, 7))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.define_expr {
      o_prot.write_field_begin(&TFieldIdentifier::new("define_expr", TType::Struct, 8))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.visible {
      o_prot.write_field_begin(&TFieldIdentifier::new("visible", TType::Bool, 9))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.children_column {
      o_prot.write_field_begin(&TFieldIdentifier::new("children_column", TType::List, 10))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.col_unique_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("col_unique_id", TType::I32, 11))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.has_bitmap_index {
      o_prot.write_field_begin(&TFieldIdentifier::new("has_bitmap_index", TType::Bool, 12))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.has_ngram_bf_index {
      o_prot.write_field_begin(&TFieldIdentifier::new("has_ngram_bf_index", TType::Bool, 13))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.gram_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("gram_size", TType::I32, 14))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.gram_bf_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("gram_bf_size", TType::I32, 15))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.aggregation {
      o_prot.write_field_begin(&TFieldIdentifier::new("aggregation", TType::String, 16))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.result_is_nullable {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_is_nullable", TType::Bool, 17))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_auto_increment {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_auto_increment", TType::Bool, 18))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.cluster_key_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("cluster_key_id", TType::I32, 19))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.be_exec_version {
      o_prot.write_field_begin(&TFieldIdentifier::new("be_exec_version", TType::I32, 20))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.pattern_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("pattern_type", TType::I32, 21))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.variant_enable_typed_paths_to_sparse {
      o_prot.write_field_begin(&TFieldIdentifier::new("variant_enable_typed_paths_to_sparse", TType::Bool, 22))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_on_update_current_timestamp {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_on_update_current_timestamp", TType::Bool, 23))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.variant_max_sparse_column_statistics_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("variant_max_sparse_column_statistics_size", TType::I32, 24))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.variant_sparse_hash_shard_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("variant_sparse_hash_shard_count", TType::I32, 25))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSlotDescriptor
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSlotDescriptor {
  pub id: types::TSlotId,
  pub parent: types::TTupleId,
  pub slot_type: types::TTypeDesc,
  pub column_pos: i32,
  pub byte_offset: i32,
  pub null_indicator_byte: i32,
  pub null_indicator_bit: i32,
  pub col_name: String,
  pub slot_idx: i32,
  pub is_materialized: bool,
  pub col_unique_id: Option<i32>,
  pub is_key: Option<bool>,
  pub need_materialize: Option<bool>,
  pub is_auto_increment: Option<bool>,
  pub column_paths: Option<Vec<String>>,
  pub col_default_value: Option<String>,
  pub primitive_type: Option<types::TPrimitiveType>,
  pub virtual_column_expr: Option<exprs::TExpr>,
}

impl TSlotDescriptor {
  pub fn new<F11, F12, F13, F14, F15, F16, F17, F18>(id: types::TSlotId, parent: types::TTupleId, slot_type: types::TTypeDesc, column_pos: i32, byte_offset: i32, null_indicator_byte: i32, null_indicator_bit: i32, col_name: String, slot_idx: i32, is_materialized: bool, col_unique_id: F11, is_key: F12, need_materialize: F13, is_auto_increment: F14, column_paths: F15, col_default_value: F16, primitive_type: F17, virtual_column_expr: F18) -> TSlotDescriptor where F11: Into<Option<i32>>, F12: Into<Option<bool>>, F13: Into<Option<bool>>, F14: Into<Option<bool>>, F15: Into<Option<Vec<String>>>, F16: Into<Option<String>>, F17: Into<Option<types::TPrimitiveType>>, F18: Into<Option<exprs::TExpr>> {
    TSlotDescriptor {
      id,
      parent,
      slot_type,
      column_pos,
      byte_offset,
      null_indicator_byte,
      null_indicator_bit,
      col_name,
      slot_idx,
      is_materialized,
      col_unique_id: col_unique_id.into(),
      is_key: is_key.into(),
      need_materialize: need_materialize.into(),
      is_auto_increment: is_auto_increment.into(),
      column_paths: column_paths.into(),
      col_default_value: col_default_value.into(),
      primitive_type: primitive_type.into(),
      virtual_column_expr: virtual_column_expr.into(),
    }
  }
}

impl TSerializable for TSlotDescriptor {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSlotDescriptor> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<types::TSlotId> = None;
    let mut f_2: Option<types::TTupleId> = None;
    let mut f_3: Option<types::TTypeDesc> = None;
    let mut f_4: Option<i32> = None;
    let mut f_5: Option<i32> = None;
    let mut f_6: Option<i32> = None;
    let mut f_7: Option<i32> = None;
    let mut f_8: Option<String> = None;
    let mut f_9: Option<i32> = None;
    let mut f_10: Option<bool> = None;
    let mut f_11: Option<i32> = None;
    let mut f_12: Option<bool> = None;
    let mut f_13: Option<bool> = None;
    let mut f_14: Option<bool> = None;
    let mut f_15: Option<Vec<String>> = None;
    let mut f_16: Option<String> = None;
    let mut f_17: Option<types::TPrimitiveType> = None;
    let mut f_18: Option<exprs::TExpr> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = types::TTypeDesc::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i32()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_string()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_i32()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_bool()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_i32()?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_bool()?;
          f_12 = Some(val);
        },
        13 => {
          let val = i_prot.read_bool()?;
          f_13 = Some(val);
        },
        14 => {
          let val = i_prot.read_bool()?;
          f_14 = Some(val);
        },
        15 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_1 = i_prot.read_string()?;
            val.push(list_elem_1);
          }
          i_prot.read_list_end()?;
          f_15 = Some(val);
        },
        16 => {
          let val = i_prot.read_string()?;
          f_16 = Some(val);
        },
        17 => {
          let val = types::TPrimitiveType::read_from_in_protocol(i_prot)?;
          f_17 = Some(val);
        },
        18 => {
          let val = exprs::TExpr::read_from_in_protocol(i_prot)?;
          f_18 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSlotDescriptor.id", &f_1)?;
    verify_required_field_exists("TSlotDescriptor.parent", &f_2)?;
    verify_required_field_exists("TSlotDescriptor.slot_type", &f_3)?;
    verify_required_field_exists("TSlotDescriptor.column_pos", &f_4)?;
    verify_required_field_exists("TSlotDescriptor.byte_offset", &f_5)?;
    verify_required_field_exists("TSlotDescriptor.null_indicator_byte", &f_6)?;
    verify_required_field_exists("TSlotDescriptor.null_indicator_bit", &f_7)?;
    verify_required_field_exists("TSlotDescriptor.col_name", &f_8)?;
    verify_required_field_exists("TSlotDescriptor.slot_idx", &f_9)?;
    verify_required_field_exists("TSlotDescriptor.is_materialized", &f_10)?;
    let ret = TSlotDescriptor {
      id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      parent: f_2.expect("auto-generated code should have checked for presence of required fields"),
      slot_type: f_3.expect("auto-generated code should have checked for presence of required fields"),
      column_pos: f_4.expect("auto-generated code should have checked for presence of required fields"),
      byte_offset: f_5.expect("auto-generated code should have checked for presence of required fields"),
      null_indicator_byte: f_6.expect("auto-generated code should have checked for presence of required fields"),
      null_indicator_bit: f_7.expect("auto-generated code should have checked for presence of required fields"),
      col_name: f_8.expect("auto-generated code should have checked for presence of required fields"),
      slot_idx: f_9.expect("auto-generated code should have checked for presence of required fields"),
      is_materialized: f_10.expect("auto-generated code should have checked for presence of required fields"),
      col_unique_id: f_11,
      is_key: f_12,
      need_materialize: f_13,
      is_auto_increment: f_14,
      column_paths: f_15,
      col_default_value: f_16,
      primitive_type: f_17,
      virtual_column_expr: f_18,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSlotDescriptor");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::I32, 1))?;
    o_prot.write_i32(self.id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("parent", TType::I32, 2))?;
    o_prot.write_i32(self.parent)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("slotType", TType::Struct, 3))?;
    self.slot_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("columnPos", TType::I32, 4))?;
    o_prot.write_i32(self.column_pos)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("byteOffset", TType::I32, 5))?;
    o_prot.write_i32(self.byte_offset)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("nullIndicatorByte", TType::I32, 6))?;
    o_prot.write_i32(self.null_indicator_byte)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("nullIndicatorBit", TType::I32, 7))?;
    o_prot.write_i32(self.null_indicator_bit)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("colName", TType::String, 8))?;
    o_prot.write_string(&self.col_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("slotIdx", TType::I32, 9))?;
    o_prot.write_i32(self.slot_idx)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("isMaterialized", TType::Bool, 10))?;
    o_prot.write_bool(self.is_materialized)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.col_unique_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("col_unique_id", TType::I32, 11))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_key {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_key", TType::Bool, 12))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.need_materialize {
      o_prot.write_field_begin(&TFieldIdentifier::new("need_materialize", TType::Bool, 13))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_auto_increment {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_auto_increment", TType::Bool, 14))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.column_paths {
      o_prot.write_field_begin(&TFieldIdentifier::new("column_paths", TType::List, 15))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.col_default_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("col_default_value", TType::String, 16))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.primitive_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("primitive_type", TType::I32, 17))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.virtual_column_expr {
      o_prot.write_field_begin(&TFieldIdentifier::new("virtual_column_expr", TType::Struct, 18))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TTupleDescriptor
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTupleDescriptor {
  pub id: types::TTupleId,
  pub byte_size: i32,
  pub num_null_bytes: i32,
  pub table_id: Option<types::TTableId>,
  pub num_null_slots: Option<i32>,
}

impl TTupleDescriptor {
  pub fn new<F4, F5>(id: types::TTupleId, byte_size: i32, num_null_bytes: i32, table_id: F4, num_null_slots: F5) -> TTupleDescriptor where F4: Into<Option<types::TTableId>>, F5: Into<Option<i32>> {
    TTupleDescriptor {
      id,
      byte_size,
      num_null_bytes,
      table_id: table_id.into(),
      num_null_slots: num_null_slots.into(),
    }
  }
}

impl TSerializable for TTupleDescriptor {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTupleDescriptor> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<types::TTupleId> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<types::TTableId> = None;
    let mut f_5: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TTupleDescriptor.id", &f_1)?;
    verify_required_field_exists("TTupleDescriptor.byte_size", &f_2)?;
    verify_required_field_exists("TTupleDescriptor.num_null_bytes", &f_3)?;
    let ret = TTupleDescriptor {
      id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      byte_size: f_2.expect("auto-generated code should have checked for presence of required fields"),
      num_null_bytes: f_3.expect("auto-generated code should have checked for presence of required fields"),
      table_id: f_4,
      num_null_slots: f_5,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TTupleDescriptor");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::I32, 1))?;
    o_prot.write_i32(self.id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("byteSize", TType::I32, 2))?;
    o_prot.write_i32(self.byte_size)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("numNullBytes", TType::I32, 3))?;
    o_prot.write_i32(self.num_null_bytes)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.table_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("tableId", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.num_null_slots {
      o_prot.write_field_begin(&TFieldIdentifier::new("numNullSlots", TType::I32, 5))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TOlapTableIndexTablets
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TOlapTableIndexTablets {
  pub index_id: i64,
  pub tablets: Vec<i64>,
}

impl TOlapTableIndexTablets {
  pub fn new(index_id: i64, tablets: Vec<i64>) -> TOlapTableIndexTablets {
    TOlapTableIndexTablets {
      index_id,
      tablets,
    }
  }
}

impl TSerializable for TOlapTableIndexTablets {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TOlapTableIndexTablets> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<Vec<i64>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i64> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_2 = i_prot.read_i64()?;
            val.push(list_elem_2);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TOlapTableIndexTablets.index_id", &f_1)?;
    verify_required_field_exists("TOlapTableIndexTablets.tablets", &f_2)?;
    let ret = TOlapTableIndexTablets {
      index_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tablets: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TOlapTableIndexTablets");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("index_id", TType::I64, 1))?;
    o_prot.write_i64(self.index_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tablets", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I64, self.tablets.len() as i32))?;
    for e in &self.tablets {
      o_prot.write_i64(*e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TOlapTablePartition
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TOlapTablePartition {
  pub id: i64,
  pub start_key: Option<exprs::TExprNode>,
  pub end_key: Option<exprs::TExprNode>,
  pub num_buckets: i32,
  pub indexes: Vec<TOlapTableIndexTablets>,
  pub start_keys: Option<Vec<exprs::TExprNode>>,
  pub end_keys: Option<Vec<exprs::TExprNode>>,
  pub in_keys: Option<Vec<Vec<exprs::TExprNode>>>,
  pub is_mutable: Option<bool>,
  pub is_default_partition: Option<bool>,
  pub load_tablet_idx: Option<i64>,
  pub total_replica_num: Option<i32>,
  pub load_required_replica_num: Option<i32>,
}

impl TOlapTablePartition {
  pub fn new<F2, F3, F6, F7, F8, F9, F10, F11, F12, F13>(id: i64, start_key: F2, end_key: F3, num_buckets: i32, indexes: Vec<TOlapTableIndexTablets>, start_keys: F6, end_keys: F7, in_keys: F8, is_mutable: F9, is_default_partition: F10, load_tablet_idx: F11, total_replica_num: F12, load_required_replica_num: F13) -> TOlapTablePartition where F2: Into<Option<exprs::TExprNode>>, F3: Into<Option<exprs::TExprNode>>, F6: Into<Option<Vec<exprs::TExprNode>>>, F7: Into<Option<Vec<exprs::TExprNode>>>, F8: Into<Option<Vec<Vec<exprs::TExprNode>>>>, F9: Into<Option<bool>>, F10: Into<Option<bool>>, F11: Into<Option<i64>>, F12: Into<Option<i32>>, F13: Into<Option<i32>> {
    TOlapTablePartition {
      id,
      start_key: start_key.into(),
      end_key: end_key.into(),
      num_buckets,
      indexes,
      start_keys: start_keys.into(),
      end_keys: end_keys.into(),
      in_keys: in_keys.into(),
      is_mutable: is_mutable.into(),
      is_default_partition: is_default_partition.into(),
      load_tablet_idx: load_tablet_idx.into(),
      total_replica_num: total_replica_num.into(),
      load_required_replica_num: load_required_replica_num.into(),
    }
  }
}

impl TSerializable for TOlapTablePartition {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TOlapTablePartition> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<exprs::TExprNode> = None;
    let mut f_3: Option<exprs::TExprNode> = None;
    let mut f_4: Option<i32> = None;
    let mut f_5: Option<Vec<TOlapTableIndexTablets>> = None;
    let mut f_6: Option<Vec<exprs::TExprNode>> = None;
    let mut f_7: Option<Vec<exprs::TExprNode>> = None;
    let mut f_8: Option<Vec<Vec<exprs::TExprNode>>> = None;
    let mut f_9: Option<bool> = None;
    let mut f_10: Option<bool> = None;
    let mut f_11: Option<i64> = None;
    let mut f_12: Option<i32> = None;
    let mut f_13: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = exprs::TExprNode::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = exprs::TExprNode::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TOlapTableIndexTablets> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_3 = TOlapTableIndexTablets::read_from_in_protocol(i_prot)?;
            val.push(list_elem_3);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<exprs::TExprNode> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_4 = exprs::TExprNode::read_from_in_protocol(i_prot)?;
            val.push(list_elem_4);
          }
          i_prot.read_list_end()?;
          f_6 = Some(val);
        },
        7 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<exprs::TExprNode> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_5 = exprs::TExprNode::read_from_in_protocol(i_prot)?;
            val.push(list_elem_5);
          }
          i_prot.read_list_end()?;
          f_7 = Some(val);
        },
        8 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<exprs::TExprNode>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_ident = i_prot.read_list_begin()?;
            let mut list_elem_6: Vec<exprs::TExprNode> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_7 = exprs::TExprNode::read_from_in_protocol(i_prot)?;
              list_elem_6.push(list_elem_7);
            }
            i_prot.read_list_end()?;
            val.push(list_elem_6);
          }
          i_prot.read_list_end()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_bool()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_bool()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_i64()?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_i32()?;
          f_12 = Some(val);
        },
        13 => {
          let val = i_prot.read_i32()?;
          f_13 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TOlapTablePartition.id", &f_1)?;
    verify_required_field_exists("TOlapTablePartition.num_buckets", &f_4)?;
    verify_required_field_exists("TOlapTablePartition.indexes", &f_5)?;
    let ret = TOlapTablePartition {
      id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      start_key: f_2,
      end_key: f_3,
      num_buckets: f_4.expect("auto-generated code should have checked for presence of required fields"),
      indexes: f_5.expect("auto-generated code should have checked for presence of required fields"),
      start_keys: f_6,
      end_keys: f_7,
      in_keys: f_8,
      is_mutable: f_9,
      is_default_partition: f_10,
      load_tablet_idx: f_11,
      total_replica_num: f_12,
      load_required_replica_num: f_13,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TOlapTablePartition");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::I64, 1))?;
    o_prot.write_i64(self.id)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.start_key {
      o_prot.write_field_begin(&TFieldIdentifier::new("start_key", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.end_key {
      o_prot.write_field_begin(&TFieldIdentifier::new("end_key", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_begin(&TFieldIdentifier::new("num_buckets", TType::I32, 4))?;
    o_prot.write_i32(self.num_buckets)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("indexes", TType::List, 5))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.indexes.len() as i32))?;
    for e in &self.indexes {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.start_keys {
      o_prot.write_field_begin(&TFieldIdentifier::new("start_keys", TType::List, 6))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.end_keys {
      o_prot.write_field_begin(&TFieldIdentifier::new("end_keys", TType::List, 7))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.in_keys {
      o_prot.write_field_begin(&TFieldIdentifier::new("in_keys", TType::List, 8))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::List, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, e.len() as i32))?;
        for e in e {
          e.write_to_out_protocol(o_prot)?;
        }
        o_prot.write_list_end()?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_mutable {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_mutable", TType::Bool, 9))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_default_partition {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_default_partition", TType::Bool, 10))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.load_tablet_idx {
      o_prot.write_field_begin(&TFieldIdentifier::new("load_tablet_idx", TType::I64, 11))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.total_replica_num {
      o_prot.write_field_begin(&TFieldIdentifier::new("total_replica_num", TType::I32, 12))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.load_required_replica_num {
      o_prot.write_field_begin(&TFieldIdentifier::new("load_required_replica_num", TType::I32, 13))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TOlapTablePartitionParam
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TOlapTablePartitionParam {
  pub db_id: i64,
  pub table_id: i64,
  pub version: i64,
  pub partition_column: Option<String>,
  pub distributed_columns: Option<Vec<String>>,
  pub partitions: Vec<TOlapTablePartition>,
  pub partition_columns: Option<Vec<String>>,
  pub partition_function_exprs: Option<Vec<exprs::TExpr>>,
  pub enable_automatic_partition: Option<bool>,
  pub partition_type: Option<partitions::TPartitionType>,
  pub enable_auto_detect_overwrite: Option<bool>,
  pub overwrite_group_id: Option<i64>,
  pub partitions_is_fake: Option<bool>,
}

impl TOlapTablePartitionParam {
  pub fn new<F4, F5, F7, F8, F9, F10, F11, F12, F13>(db_id: i64, table_id: i64, version: i64, partition_column: F4, distributed_columns: F5, partitions: Vec<TOlapTablePartition>, partition_columns: F7, partition_function_exprs: F8, enable_automatic_partition: F9, partition_type: F10, enable_auto_detect_overwrite: F11, overwrite_group_id: F12, partitions_is_fake: F13) -> TOlapTablePartitionParam where F4: Into<Option<String>>, F5: Into<Option<Vec<String>>>, F7: Into<Option<Vec<String>>>, F8: Into<Option<Vec<exprs::TExpr>>>, F9: Into<Option<bool>>, F10: Into<Option<partitions::TPartitionType>>, F11: Into<Option<bool>>, F12: Into<Option<i64>>, F13: Into<Option<bool>> {
    TOlapTablePartitionParam {
      db_id,
      table_id,
      version,
      partition_column: partition_column.into(),
      distributed_columns: distributed_columns.into(),
      partitions,
      partition_columns: partition_columns.into(),
      partition_function_exprs: partition_function_exprs.into(),
      enable_automatic_partition: enable_automatic_partition.into(),
      partition_type: partition_type.into(),
      enable_auto_detect_overwrite: enable_auto_detect_overwrite.into(),
      overwrite_group_id: overwrite_group_id.into(),
      partitions_is_fake: partitions_is_fake.into(),
    }
  }
}

impl TSerializable for TOlapTablePartitionParam {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TOlapTablePartitionParam> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<Vec<String>> = None;
    let mut f_6: Option<Vec<TOlapTablePartition>> = None;
    let mut f_7: Option<Vec<String>> = None;
    let mut f_8: Option<Vec<exprs::TExpr>> = None;
    let mut f_9: Option<bool> = None;
    let mut f_10: Option<partitions::TPartitionType> = None;
    let mut f_11: Option<bool> = None;
    let mut f_12: Option<i64> = None;
    let mut f_13: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_8 = i_prot.read_string()?;
            val.push(list_elem_8);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TOlapTablePartition> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_9 = TOlapTablePartition::read_from_in_protocol(i_prot)?;
            val.push(list_elem_9);
          }
          i_prot.read_list_end()?;
          f_6 = Some(val);
        },
        7 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_10 = i_prot.read_string()?;
            val.push(list_elem_10);
          }
          i_prot.read_list_end()?;
          f_7 = Some(val);
        },
        8 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<exprs::TExpr> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_11 = exprs::TExpr::read_from_in_protocol(i_prot)?;
            val.push(list_elem_11);
          }
          i_prot.read_list_end()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_bool()?;
          f_9 = Some(val);
        },
        10 => {
          let val = partitions::TPartitionType::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_bool()?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_i64()?;
          f_12 = Some(val);
        },
        13 => {
          let val = i_prot.read_bool()?;
          f_13 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TOlapTablePartitionParam.db_id", &f_1)?;
    verify_required_field_exists("TOlapTablePartitionParam.table_id", &f_2)?;
    verify_required_field_exists("TOlapTablePartitionParam.version", &f_3)?;
    verify_required_field_exists("TOlapTablePartitionParam.partitions", &f_6)?;
    let ret = TOlapTablePartitionParam {
      db_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      version: f_3.expect("auto-generated code should have checked for presence of required fields"),
      partition_column: f_4,
      distributed_columns: f_5,
      partitions: f_6.expect("auto-generated code should have checked for presence of required fields"),
      partition_columns: f_7,
      partition_function_exprs: f_8,
      enable_automatic_partition: f_9,
      partition_type: f_10,
      enable_auto_detect_overwrite: f_11,
      overwrite_group_id: f_12,
      partitions_is_fake: f_13,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TOlapTablePartitionParam");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_id", TType::I64, 1))?;
    o_prot.write_i64(self.db_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_id", TType::I64, 2))?;
    o_prot.write_i64(self.table_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("version", TType::I64, 3))?;
    o_prot.write_i64(self.version)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.partition_column {
      o_prot.write_field_begin(&TFieldIdentifier::new("partition_column", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.distributed_columns {
      o_prot.write_field_begin(&TFieldIdentifier::new("distributed_columns", TType::List, 5))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_begin(&TFieldIdentifier::new("partitions", TType::List, 6))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.partitions.len() as i32))?;
    for e in &self.partitions {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.partition_columns {
      o_prot.write_field_begin(&TFieldIdentifier::new("partition_columns", TType::List, 7))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.partition_function_exprs {
      o_prot.write_field_begin(&TFieldIdentifier::new("partition_function_exprs", TType::List, 8))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_automatic_partition {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_automatic_partition", TType::Bool, 9))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.partition_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("partition_type", TType::I32, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_auto_detect_overwrite {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_auto_detect_overwrite", TType::Bool, 11))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.overwrite_group_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("overwrite_group_id", TType::I64, 12))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.partitions_is_fake {
      o_prot.write_field_begin(&TFieldIdentifier::new("partitions_is_fake", TType::Bool, 13))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TOlapTableIndex
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TOlapTableIndex {
  pub index_name: Option<String>,
  pub columns: Option<Vec<String>>,
  pub index_type: Option<TIndexType>,
  pub comment: Option<String>,
  pub index_id: Option<i64>,
  pub properties: Option<BTreeMap<String, String>>,
  pub column_unique_ids: Option<Vec<i32>>,
}

impl TOlapTableIndex {
  pub fn new<F1, F2, F3, F4, F5, F6, F7>(index_name: F1, columns: F2, index_type: F3, comment: F4, index_id: F5, properties: F6, column_unique_ids: F7) -> TOlapTableIndex where F1: Into<Option<String>>, F2: Into<Option<Vec<String>>>, F3: Into<Option<TIndexType>>, F4: Into<Option<String>>, F5: Into<Option<i64>>, F6: Into<Option<BTreeMap<String, String>>>, F7: Into<Option<Vec<i32>>> {
    TOlapTableIndex {
      index_name: index_name.into(),
      columns: columns.into(),
      index_type: index_type.into(),
      comment: comment.into(),
      index_id: index_id.into(),
      properties: properties.into(),
      column_unique_ids: column_unique_ids.into(),
    }
  }
}

impl TSerializable for TOlapTableIndex {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TOlapTableIndex> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<Vec<String>> = None;
    let mut f_3: Option<TIndexType> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<i64> = None;
    let mut f_6: Option<BTreeMap<String, String>> = None;
    let mut f_7: Option<Vec<i32>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_12 = i_prot.read_string()?;
            val.push(list_elem_12);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = TIndexType::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        6 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_13 = i_prot.read_string()?;
            let map_val_14 = i_prot.read_string()?;
            val.insert(map_key_13, map_val_14);
          }
          i_prot.read_map_end()?;
          f_6 = Some(val);
        },
        7 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_15 = i_prot.read_i32()?;
            val.push(list_elem_15);
          }
          i_prot.read_list_end()?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TOlapTableIndex {
      index_name: f_1,
      columns: f_2,
      index_type: f_3,
      comment: f_4,
      index_id: f_5,
      properties: f_6,
      column_unique_ids: f_7,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TOlapTableIndex");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.index_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("index_name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.columns {
      o_prot.write_field_begin(&TFieldIdentifier::new("columns", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.index_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("index_type", TType::I32, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.comment {
      o_prot.write_field_begin(&TFieldIdentifier::new("comment", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.index_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("index_id", TType::I64, 5))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.properties {
      o_prot.write_field_begin(&TFieldIdentifier::new("properties", TType::Map, 6))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.column_unique_ids {
      o_prot.write_field_begin(&TFieldIdentifier::new("column_unique_ids", TType::List, 7))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I32, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i32(*e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TOlapTableIndexSchema
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TOlapTableIndexSchema {
  pub id: i64,
  pub columns: Vec<String>,
  pub schema_hash: i32,
  pub columns_desc: Option<Vec<TColumn>>,
  pub indexes_desc: Option<Vec<TOlapTableIndex>>,
  pub where_clause: Option<exprs::TExpr>,
}

impl TOlapTableIndexSchema {
  pub fn new<F4, F5, F6>(id: i64, columns: Vec<String>, schema_hash: i32, columns_desc: F4, indexes_desc: F5, where_clause: F6) -> TOlapTableIndexSchema where F4: Into<Option<Vec<TColumn>>>, F5: Into<Option<Vec<TOlapTableIndex>>>, F6: Into<Option<exprs::TExpr>> {
    TOlapTableIndexSchema {
      id,
      columns,
      schema_hash,
      columns_desc: columns_desc.into(),
      indexes_desc: indexes_desc.into(),
      where_clause: where_clause.into(),
    }
  }
}

impl TSerializable for TOlapTableIndexSchema {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TOlapTableIndexSchema> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<Vec<String>> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<Vec<TColumn>> = None;
    let mut f_5: Option<Vec<TOlapTableIndex>> = None;
    let mut f_6: Option<exprs::TExpr> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_16 = i_prot.read_string()?;
            val.push(list_elem_16);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TColumn> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_17 = TColumn::read_from_in_protocol(i_prot)?;
            val.push(list_elem_17);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TOlapTableIndex> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_18 = TOlapTableIndex::read_from_in_protocol(i_prot)?;
            val.push(list_elem_18);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let val = exprs::TExpr::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TOlapTableIndexSchema.id", &f_1)?;
    verify_required_field_exists("TOlapTableIndexSchema.columns", &f_2)?;
    verify_required_field_exists("TOlapTableIndexSchema.schema_hash", &f_3)?;
    let ret = TOlapTableIndexSchema {
      id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      columns: f_2.expect("auto-generated code should have checked for presence of required fields"),
      schema_hash: f_3.expect("auto-generated code should have checked for presence of required fields"),
      columns_desc: f_4,
      indexes_desc: f_5,
      where_clause: f_6,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TOlapTableIndexSchema");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::I64, 1))?;
    o_prot.write_i64(self.id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("columns", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.columns.len() as i32))?;
    for e in &self.columns {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("schema_hash", TType::I32, 3))?;
    o_prot.write_i32(self.schema_hash)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.columns_desc {
      o_prot.write_field_begin(&TFieldIdentifier::new("columns_desc", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.indexes_desc {
      o_prot.write_field_begin(&TFieldIdentifier::new("indexes_desc", TType::List, 5))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.where_clause {
      o_prot.write_field_begin(&TFieldIdentifier::new("where_clause", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TOlapTableSchemaParam
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TOlapTableSchemaParam {
  pub db_id: i64,
  pub table_id: i64,
  pub version: i64,
  pub slot_descs: Vec<TSlotDescriptor>,
  pub tuple_desc: TTupleDescriptor,
  pub indexes: Vec<TOlapTableIndexSchema>,
  pub is_dynamic_schema: Option<bool>,
  pub is_partial_update: Option<bool>,
  pub partial_update_input_columns: Option<Vec<String>>,
  pub is_strict_mode: Option<bool>,
  pub auto_increment_column: Option<String>,
  pub auto_increment_column_unique_id: Option<i32>,
  pub inverted_index_file_storage_format: Option<types::TInvertedIndexFileStorageFormat>,
  pub unique_key_update_mode: Option<types::TUniqueKeyUpdateMode>,
  pub sequence_map_col_unique_id: Option<i32>,
  pub partial_update_new_key_policy: Option<TPartialUpdateNewRowPolicy>,
}

impl TOlapTableSchemaParam {
  pub fn new<F7, F8, F9, F10, F11, F12, F13, F14, F15, F16>(db_id: i64, table_id: i64, version: i64, slot_descs: Vec<TSlotDescriptor>, tuple_desc: TTupleDescriptor, indexes: Vec<TOlapTableIndexSchema>, is_dynamic_schema: F7, is_partial_update: F8, partial_update_input_columns: F9, is_strict_mode: F10, auto_increment_column: F11, auto_increment_column_unique_id: F12, inverted_index_file_storage_format: F13, unique_key_update_mode: F14, sequence_map_col_unique_id: F15, partial_update_new_key_policy: F16) -> TOlapTableSchemaParam where F7: Into<Option<bool>>, F8: Into<Option<bool>>, F9: Into<Option<Vec<String>>>, F10: Into<Option<bool>>, F11: Into<Option<String>>, F12: Into<Option<i32>>, F13: Into<Option<types::TInvertedIndexFileStorageFormat>>, F14: Into<Option<types::TUniqueKeyUpdateMode>>, F15: Into<Option<i32>>, F16: Into<Option<TPartialUpdateNewRowPolicy>> {
    TOlapTableSchemaParam {
      db_id,
      table_id,
      version,
      slot_descs,
      tuple_desc,
      indexes,
      is_dynamic_schema: is_dynamic_schema.into(),
      is_partial_update: is_partial_update.into(),
      partial_update_input_columns: partial_update_input_columns.into(),
      is_strict_mode: is_strict_mode.into(),
      auto_increment_column: auto_increment_column.into(),
      auto_increment_column_unique_id: auto_increment_column_unique_id.into(),
      inverted_index_file_storage_format: inverted_index_file_storage_format.into(),
      unique_key_update_mode: unique_key_update_mode.into(),
      sequence_map_col_unique_id: sequence_map_col_unique_id.into(),
      partial_update_new_key_policy: partial_update_new_key_policy.into(),
    }
  }
}

impl TSerializable for TOlapTableSchemaParam {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TOlapTableSchemaParam> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<Vec<TSlotDescriptor>> = None;
    let mut f_5: Option<TTupleDescriptor> = None;
    let mut f_6: Option<Vec<TOlapTableIndexSchema>> = None;
    let mut f_7: Option<bool> = None;
    let mut f_8: Option<bool> = None;
    let mut f_9: Option<Vec<String>> = None;
    let mut f_10: Option<bool> = None;
    let mut f_11: Option<String> = None;
    let mut f_12: Option<i32> = None;
    let mut f_13: Option<types::TInvertedIndexFileStorageFormat> = None;
    let mut f_14: Option<types::TUniqueKeyUpdateMode> = None;
    let mut f_15: Option<i32> = None;
    let mut f_16: Option<TPartialUpdateNewRowPolicy> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TSlotDescriptor> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_19 = TSlotDescriptor::read_from_in_protocol(i_prot)?;
            val.push(list_elem_19);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let val = TTupleDescriptor::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TOlapTableIndexSchema> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_20 = TOlapTableIndexSchema::read_from_in_protocol(i_prot)?;
            val.push(list_elem_20);
          }
          i_prot.read_list_end()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bool()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_bool()?;
          f_8 = Some(val);
        },
        9 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_21 = i_prot.read_string()?;
            val.push(list_elem_21);
          }
          i_prot.read_list_end()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_bool()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_string()?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_i32()?;
          f_12 = Some(val);
        },
        13 => {
          let val = types::TInvertedIndexFileStorageFormat::read_from_in_protocol(i_prot)?;
          f_13 = Some(val);
        },
        14 => {
          let val = types::TUniqueKeyUpdateMode::read_from_in_protocol(i_prot)?;
          f_14 = Some(val);
        },
        15 => {
          let val = i_prot.read_i32()?;
          f_15 = Some(val);
        },
        16 => {
          let val = TPartialUpdateNewRowPolicy::read_from_in_protocol(i_prot)?;
          f_16 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TOlapTableSchemaParam.db_id", &f_1)?;
    verify_required_field_exists("TOlapTableSchemaParam.table_id", &f_2)?;
    verify_required_field_exists("TOlapTableSchemaParam.version", &f_3)?;
    verify_required_field_exists("TOlapTableSchemaParam.slot_descs", &f_4)?;
    verify_required_field_exists("TOlapTableSchemaParam.tuple_desc", &f_5)?;
    verify_required_field_exists("TOlapTableSchemaParam.indexes", &f_6)?;
    let ret = TOlapTableSchemaParam {
      db_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      version: f_3.expect("auto-generated code should have checked for presence of required fields"),
      slot_descs: f_4.expect("auto-generated code should have checked for presence of required fields"),
      tuple_desc: f_5.expect("auto-generated code should have checked for presence of required fields"),
      indexes: f_6.expect("auto-generated code should have checked for presence of required fields"),
      is_dynamic_schema: f_7,
      is_partial_update: f_8,
      partial_update_input_columns: f_9,
      is_strict_mode: f_10,
      auto_increment_column: f_11,
      auto_increment_column_unique_id: f_12,
      inverted_index_file_storage_format: f_13,
      unique_key_update_mode: f_14,
      sequence_map_col_unique_id: f_15,
      partial_update_new_key_policy: f_16,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TOlapTableSchemaParam");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_id", TType::I64, 1))?;
    o_prot.write_i64(self.db_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_id", TType::I64, 2))?;
    o_prot.write_i64(self.table_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("version", TType::I64, 3))?;
    o_prot.write_i64(self.version)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("slot_descs", TType::List, 4))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.slot_descs.len() as i32))?;
    for e in &self.slot_descs {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tuple_desc", TType::Struct, 5))?;
    self.tuple_desc.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("indexes", TType::List, 6))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.indexes.len() as i32))?;
    for e in &self.indexes {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.is_dynamic_schema {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_dynamic_schema", TType::Bool, 7))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_partial_update {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_partial_update", TType::Bool, 8))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.partial_update_input_columns {
      o_prot.write_field_begin(&TFieldIdentifier::new("partial_update_input_columns", TType::List, 9))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_strict_mode {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_strict_mode", TType::Bool, 10))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.auto_increment_column {
      o_prot.write_field_begin(&TFieldIdentifier::new("auto_increment_column", TType::String, 11))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.auto_increment_column_unique_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("auto_increment_column_unique_id", TType::I32, 12))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.inverted_index_file_storage_format {
      o_prot.write_field_begin(&TFieldIdentifier::new("inverted_index_file_storage_format", TType::I32, 13))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.unique_key_update_mode {
      o_prot.write_field_begin(&TFieldIdentifier::new("unique_key_update_mode", TType::I32, 14))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.sequence_map_col_unique_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("sequence_map_col_unique_id", TType::I32, 15))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.partial_update_new_key_policy {
      o_prot.write_field_begin(&TFieldIdentifier::new("partial_update_new_key_policy", TType::I32, 16))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TTabletLocation
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTabletLocation {
  pub tablet_id: i64,
  pub node_ids: Vec<i64>,
}

impl TTabletLocation {
  pub fn new(tablet_id: i64, node_ids: Vec<i64>) -> TTabletLocation {
    TTabletLocation {
      tablet_id,
      node_ids,
    }
  }
}

impl TSerializable for TTabletLocation {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTabletLocation> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<Vec<i64>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i64> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_22 = i_prot.read_i64()?;
            val.push(list_elem_22);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TTabletLocation.tablet_id", &f_1)?;
    verify_required_field_exists("TTabletLocation.node_ids", &f_2)?;
    let ret = TTabletLocation {
      tablet_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      node_ids: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TTabletLocation");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tablet_id", TType::I64, 1))?;
    o_prot.write_i64(self.tablet_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("node_ids", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I64, self.node_ids.len() as i32))?;
    for e in &self.node_ids {
      o_prot.write_i64(*e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TOlapTableLocationParam
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TOlapTableLocationParam {
  pub db_id: i64,
  pub table_id: i64,
  pub version: i64,
  pub tablets: Vec<TTabletLocation>,
}

impl TOlapTableLocationParam {
  pub fn new(db_id: i64, table_id: i64, version: i64, tablets: Vec<TTabletLocation>) -> TOlapTableLocationParam {
    TOlapTableLocationParam {
      db_id,
      table_id,
      version,
      tablets,
    }
  }
}

impl TSerializable for TOlapTableLocationParam {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TOlapTableLocationParam> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<Vec<TTabletLocation>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TTabletLocation> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_23 = TTabletLocation::read_from_in_protocol(i_prot)?;
            val.push(list_elem_23);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TOlapTableLocationParam.db_id", &f_1)?;
    verify_required_field_exists("TOlapTableLocationParam.table_id", &f_2)?;
    verify_required_field_exists("TOlapTableLocationParam.version", &f_3)?;
    verify_required_field_exists("TOlapTableLocationParam.tablets", &f_4)?;
    let ret = TOlapTableLocationParam {
      db_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      version: f_3.expect("auto-generated code should have checked for presence of required fields"),
      tablets: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TOlapTableLocationParam");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_id", TType::I64, 1))?;
    o_prot.write_i64(self.db_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_id", TType::I64, 2))?;
    o_prot.write_i64(self.table_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("version", TType::I64, 3))?;
    o_prot.write_i64(self.version)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tablets", TType::List, 4))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.tablets.len() as i32))?;
    for e in &self.tablets {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TNodeInfo
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TNodeInfo {
  pub id: i64,
  pub option: i64,
  pub host: String,
  pub async_internal_port: i32,
}

impl TNodeInfo {
  pub fn new(id: i64, option: i64, host: String, async_internal_port: i32) -> TNodeInfo {
    TNodeInfo {
      id,
      option,
      host,
      async_internal_port,
    }
  }
}

impl TSerializable for TNodeInfo {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TNodeInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TNodeInfo.id", &f_1)?;
    verify_required_field_exists("TNodeInfo.option", &f_2)?;
    verify_required_field_exists("TNodeInfo.host", &f_3)?;
    verify_required_field_exists("TNodeInfo.async_internal_port", &f_4)?;
    let ret = TNodeInfo {
      id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      option: f_2.expect("auto-generated code should have checked for presence of required fields"),
      host: f_3.expect("auto-generated code should have checked for presence of required fields"),
      async_internal_port: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TNodeInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::I64, 1))?;
    o_prot.write_i64(self.id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("option", TType::I64, 2))?;
    o_prot.write_i64(self.option)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("host", TType::String, 3))?;
    o_prot.write_string(&self.host)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("async_internal_port", TType::I32, 4))?;
    o_prot.write_i32(self.async_internal_port)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TPaloNodesInfo
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TPaloNodesInfo {
  pub version: i64,
  pub nodes: Vec<TNodeInfo>,
}

impl TPaloNodesInfo {
  pub fn new(version: i64, nodes: Vec<TNodeInfo>) -> TPaloNodesInfo {
    TPaloNodesInfo {
      version,
      nodes,
    }
  }
}

impl TSerializable for TPaloNodesInfo {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TPaloNodesInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<Vec<TNodeInfo>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TNodeInfo> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_24 = TNodeInfo::read_from_in_protocol(i_prot)?;
            val.push(list_elem_24);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TPaloNodesInfo.version", &f_1)?;
    verify_required_field_exists("TPaloNodesInfo.nodes", &f_2)?;
    let ret = TPaloNodesInfo {
      version: f_1.expect("auto-generated code should have checked for presence of required fields"),
      nodes: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TPaloNodesInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("version", TType::I64, 1))?;
    o_prot.write_i64(self.version)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("nodes", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.nodes.len() as i32))?;
    for e in &self.nodes {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TOlapTable
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TOlapTable {
  pub table_name: String,
}

impl TOlapTable {
  pub fn new(table_name: String) -> TOlapTable {
    TOlapTable {
      table_name,
    }
  }
}

impl TSerializable for TOlapTable {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TOlapTable> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TOlapTable.table_name", &f_1)?;
    let ret = TOlapTable {
      table_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TOlapTable");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tableName", TType::String, 1))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TMySQLTable
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TMySQLTable {
  pub host: String,
  pub port: String,
  pub user: String,
  pub passwd: String,
  pub db: String,
  pub table: String,
  pub charset: String,
}

impl TMySQLTable {
  pub fn new(host: String, port: String, user: String, passwd: String, db: String, table: String, charset: String) -> TMySQLTable {
    TMySQLTable {
      host,
      port,
      user,
      passwd,
      db,
      table,
      charset,
    }
  }
}

impl TSerializable for TMySQLTable {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TMySQLTable> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<String> = None;
    let mut f_7: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TMySQLTable.host", &f_1)?;
    verify_required_field_exists("TMySQLTable.port", &f_2)?;
    verify_required_field_exists("TMySQLTable.user", &f_3)?;
    verify_required_field_exists("TMySQLTable.passwd", &f_4)?;
    verify_required_field_exists("TMySQLTable.db", &f_5)?;
    verify_required_field_exists("TMySQLTable.table", &f_6)?;
    verify_required_field_exists("TMySQLTable.charset", &f_7)?;
    let ret = TMySQLTable {
      host: f_1.expect("auto-generated code should have checked for presence of required fields"),
      port: f_2.expect("auto-generated code should have checked for presence of required fields"),
      user: f_3.expect("auto-generated code should have checked for presence of required fields"),
      passwd: f_4.expect("auto-generated code should have checked for presence of required fields"),
      db: f_5.expect("auto-generated code should have checked for presence of required fields"),
      table: f_6.expect("auto-generated code should have checked for presence of required fields"),
      charset: f_7.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TMySQLTable");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("host", TType::String, 1))?;
    o_prot.write_string(&self.host)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("port", TType::String, 2))?;
    o_prot.write_string(&self.port)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("user", TType::String, 3))?;
    o_prot.write_string(&self.user)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("passwd", TType::String, 4))?;
    o_prot.write_string(&self.passwd)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db", TType::String, 5))?;
    o_prot.write_string(&self.db)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table", TType::String, 6))?;
    o_prot.write_string(&self.table)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("charset", TType::String, 7))?;
    o_prot.write_string(&self.charset)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TOdbcTable
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TOdbcTable {
  pub host: Option<String>,
  pub port: Option<String>,
  pub user: Option<String>,
  pub passwd: Option<String>,
  pub db: Option<String>,
  pub table: Option<String>,
  pub driver: Option<String>,
  pub type_: Option<types::TOdbcTableType>,
}

impl TOdbcTable {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8>(host: F1, port: F2, user: F3, passwd: F4, db: F5, table: F6, driver: F7, type_: F8) -> TOdbcTable where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<String>>, F6: Into<Option<String>>, F7: Into<Option<String>>, F8: Into<Option<types::TOdbcTableType>> {
    TOdbcTable {
      host: host.into(),
      port: port.into(),
      user: user.into(),
      passwd: passwd.into(),
      db: db.into(),
      table: table.into(),
      driver: driver.into(),
      type_: type_.into(),
    }
  }
}

impl TSerializable for TOdbcTable {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TOdbcTable> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<String> = None;
    let mut f_7: Option<String> = None;
    let mut f_8: Option<types::TOdbcTableType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        8 => {
          let val = types::TOdbcTableType::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TOdbcTable {
      host: f_1,
      port: f_2,
      user: f_3,
      passwd: f_4,
      db: f_5,
      table: f_6,
      driver: f_7,
      type_: f_8,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TOdbcTable");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.host {
      o_prot.write_field_begin(&TFieldIdentifier::new("host", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.port {
      o_prot.write_field_begin(&TFieldIdentifier::new("port", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user {
      o_prot.write_field_begin(&TFieldIdentifier::new("user", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.passwd {
      o_prot.write_field_begin(&TFieldIdentifier::new("passwd", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.db {
      o_prot.write_field_begin(&TFieldIdentifier::new("db", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.table {
      o_prot.write_field_begin(&TFieldIdentifier::new("table", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.driver {
      o_prot.write_field_begin(&TFieldIdentifier::new("driver", TType::String, 7))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.type_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 8))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TEsTable
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TEsTable {
}

impl TEsTable {
  pub fn new() -> TEsTable {
    TEsTable {}
  }
}

impl TSerializable for TEsTable {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TEsTable> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      i_prot.skip(field_ident.field_type)?;
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TEsTable {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TEsTable");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSchemaTable
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSchemaTable {
  pub table_type: TSchemaTableType,
}

impl TSchemaTable {
  pub fn new(table_type: TSchemaTableType) -> TSchemaTable {
    TSchemaTable {
      table_type,
    }
  }
}

impl TSerializable for TSchemaTable {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSchemaTable> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSchemaTableType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSchemaTableType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSchemaTable.table_type", &f_1)?;
    let ret = TSchemaTable {
      table_type: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSchemaTable");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tableType", TType::I32, 1))?;
    self.table_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TBrokerTable
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TBrokerTable {
}

impl TBrokerTable {
  pub fn new() -> TBrokerTable {
    TBrokerTable {}
  }
}

impl TSerializable for TBrokerTable {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TBrokerTable> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      i_prot.skip(field_ident.field_type)?;
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TBrokerTable {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TBrokerTable");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// THiveTable
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct THiveTable {
  pub db_name: String,
  pub table_name: String,
  pub properties: BTreeMap<String, String>,
}

impl THiveTable {
  pub fn new(db_name: String, table_name: String, properties: BTreeMap<String, String>) -> THiveTable {
    THiveTable {
      db_name,
      table_name,
      properties,
    }
  }
}

impl TSerializable for THiveTable {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<THiveTable> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<BTreeMap<String, String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_25 = i_prot.read_string()?;
            let map_val_26 = i_prot.read_string()?;
            val.insert(map_key_25, map_val_26);
          }
          i_prot.read_map_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("THiveTable.db_name", &f_1)?;
    verify_required_field_exists("THiveTable.table_name", &f_2)?;
    verify_required_field_exists("THiveTable.properties", &f_3)?;
    let ret = THiveTable {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      properties: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("THiveTable");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 2))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("properties", TType::Map, 3))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, self.properties.len() as i32))?;
    for (k, v) in &self.properties {
      o_prot.write_string(k)?;
      o_prot.write_string(v)?;
    }
    o_prot.write_map_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TIcebergTable
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TIcebergTable {
  pub db_name: String,
  pub table_name: String,
  pub properties: BTreeMap<String, String>,
}

impl TIcebergTable {
  pub fn new(db_name: String, table_name: String, properties: BTreeMap<String, String>) -> TIcebergTable {
    TIcebergTable {
      db_name,
      table_name,
      properties,
    }
  }
}

impl TSerializable for TIcebergTable {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TIcebergTable> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<BTreeMap<String, String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_27 = i_prot.read_string()?;
            let map_val_28 = i_prot.read_string()?;
            val.insert(map_key_27, map_val_28);
          }
          i_prot.read_map_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TIcebergTable.db_name", &f_1)?;
    verify_required_field_exists("TIcebergTable.table_name", &f_2)?;
    verify_required_field_exists("TIcebergTable.properties", &f_3)?;
    let ret = TIcebergTable {
      db_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      properties: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TIcebergTable");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 1))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 2))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("properties", TType::Map, 3))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, self.properties.len() as i32))?;
    for (k, v) in &self.properties {
      o_prot.write_string(k)?;
      o_prot.write_string(v)?;
    }
    o_prot.write_map_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// THudiTable
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct THudiTable {
  pub db_name: Option<String>,
  pub table_name: Option<String>,
  pub properties: Option<BTreeMap<String, String>>,
}

impl THudiTable {
  pub fn new<F1, F2, F3>(db_name: F1, table_name: F2, properties: F3) -> THudiTable where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<BTreeMap<String, String>>> {
    THudiTable {
      db_name: db_name.into(),
      table_name: table_name.into(),
      properties: properties.into(),
    }
  }
}

impl TSerializable for THudiTable {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<THudiTable> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<BTreeMap<String, String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_29 = i_prot.read_string()?;
            let map_val_30 = i_prot.read_string()?;
            val.insert(map_key_29, map_val_30);
          }
          i_prot.read_map_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = THudiTable {
      db_name: f_1,
      table_name: f_2,
      properties: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("THudiTable");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.db_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("dbName", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.table_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("tableName", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.properties {
      o_prot.write_field_begin(&TFieldIdentifier::new("properties", TType::Map, 3))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TJdbcTable
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TJdbcTable {
  pub jdbc_url: Option<String>,
  pub jdbc_table_name: Option<String>,
  pub jdbc_user: Option<String>,
  pub jdbc_password: Option<String>,
  pub jdbc_driver_url: Option<String>,
  pub jdbc_resource_name: Option<String>,
  pub jdbc_driver_class: Option<String>,
  pub jdbc_driver_checksum: Option<String>,
  pub connection_pool_min_size: Option<i32>,
  pub connection_pool_max_size: Option<i32>,
  pub connection_pool_max_wait_time: Option<i32>,
  pub connection_pool_max_life_time: Option<i32>,
  pub connection_pool_keep_alive: Option<bool>,
  pub catalog_id: Option<i64>,
}

impl TJdbcTable {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14>(jdbc_url: F1, jdbc_table_name: F2, jdbc_user: F3, jdbc_password: F4, jdbc_driver_url: F5, jdbc_resource_name: F6, jdbc_driver_class: F7, jdbc_driver_checksum: F8, connection_pool_min_size: F9, connection_pool_max_size: F10, connection_pool_max_wait_time: F11, connection_pool_max_life_time: F12, connection_pool_keep_alive: F13, catalog_id: F14) -> TJdbcTable where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<String>>, F6: Into<Option<String>>, F7: Into<Option<String>>, F8: Into<Option<String>>, F9: Into<Option<i32>>, F10: Into<Option<i32>>, F11: Into<Option<i32>>, F12: Into<Option<i32>>, F13: Into<Option<bool>>, F14: Into<Option<i64>> {
    TJdbcTable {
      jdbc_url: jdbc_url.into(),
      jdbc_table_name: jdbc_table_name.into(),
      jdbc_user: jdbc_user.into(),
      jdbc_password: jdbc_password.into(),
      jdbc_driver_url: jdbc_driver_url.into(),
      jdbc_resource_name: jdbc_resource_name.into(),
      jdbc_driver_class: jdbc_driver_class.into(),
      jdbc_driver_checksum: jdbc_driver_checksum.into(),
      connection_pool_min_size: connection_pool_min_size.into(),
      connection_pool_max_size: connection_pool_max_size.into(),
      connection_pool_max_wait_time: connection_pool_max_wait_time.into(),
      connection_pool_max_life_time: connection_pool_max_life_time.into(),
      connection_pool_keep_alive: connection_pool_keep_alive.into(),
      catalog_id: catalog_id.into(),
    }
  }
}

impl TSerializable for TJdbcTable {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TJdbcTable> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<String> = None;
    let mut f_7: Option<String> = None;
    let mut f_8: Option<String> = None;
    let mut f_9: Option<i32> = None;
    let mut f_10: Option<i32> = None;
    let mut f_11: Option<i32> = None;
    let mut f_12: Option<i32> = None;
    let mut f_13: Option<bool> = None;
    let mut f_14: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_string()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_i32()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_i32()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_i32()?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_i32()?;
          f_12 = Some(val);
        },
        13 => {
          let val = i_prot.read_bool()?;
          f_13 = Some(val);
        },
        14 => {
          let val = i_prot.read_i64()?;
          f_14 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TJdbcTable {
      jdbc_url: f_1,
      jdbc_table_name: f_2,
      jdbc_user: f_3,
      jdbc_password: f_4,
      jdbc_driver_url: f_5,
      jdbc_resource_name: f_6,
      jdbc_driver_class: f_7,
      jdbc_driver_checksum: f_8,
      connection_pool_min_size: f_9,
      connection_pool_max_size: f_10,
      connection_pool_max_wait_time: f_11,
      connection_pool_max_life_time: f_12,
      connection_pool_keep_alive: f_13,
      catalog_id: f_14,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TJdbcTable");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.jdbc_url {
      o_prot.write_field_begin(&TFieldIdentifier::new("jdbc_url", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.jdbc_table_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("jdbc_table_name", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.jdbc_user {
      o_prot.write_field_begin(&TFieldIdentifier::new("jdbc_user", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.jdbc_password {
      o_prot.write_field_begin(&TFieldIdentifier::new("jdbc_password", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.jdbc_driver_url {
      o_prot.write_field_begin(&TFieldIdentifier::new("jdbc_driver_url", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.jdbc_resource_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("jdbc_resource_name", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.jdbc_driver_class {
      o_prot.write_field_begin(&TFieldIdentifier::new("jdbc_driver_class", TType::String, 7))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.jdbc_driver_checksum {
      o_prot.write_field_begin(&TFieldIdentifier::new("jdbc_driver_checksum", TType::String, 8))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.connection_pool_min_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("connection_pool_min_size", TType::I32, 9))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.connection_pool_max_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("connection_pool_max_size", TType::I32, 10))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.connection_pool_max_wait_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("connection_pool_max_wait_time", TType::I32, 11))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.connection_pool_max_life_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("connection_pool_max_life_time", TType::I32, 12))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.connection_pool_keep_alive {
      o_prot.write_field_begin(&TFieldIdentifier::new("connection_pool_keep_alive", TType::Bool, 13))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.catalog_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("catalog_id", TType::I64, 14))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TMCTable
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TMCTable {
  pub region: Option<String>,
  pub project: Option<String>,
  pub table: Option<String>,
  pub access_key: Option<String>,
  pub secret_key: Option<String>,
  pub public_access: Option<String>,
  pub odps_url: Option<String>,
  pub tunnel_url: Option<String>,
  pub endpoint: Option<String>,
  pub quota: Option<String>,
}

impl TMCTable {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10>(region: F1, project: F2, table: F3, access_key: F4, secret_key: F5, public_access: F6, odps_url: F7, tunnel_url: F8, endpoint: F9, quota: F10) -> TMCTable where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<String>>, F6: Into<Option<String>>, F7: Into<Option<String>>, F8: Into<Option<String>>, F9: Into<Option<String>>, F10: Into<Option<String>> {
    TMCTable {
      region: region.into(),
      project: project.into(),
      table: table.into(),
      access_key: access_key.into(),
      secret_key: secret_key.into(),
      public_access: public_access.into(),
      odps_url: odps_url.into(),
      tunnel_url: tunnel_url.into(),
      endpoint: endpoint.into(),
      quota: quota.into(),
    }
  }
}

impl TSerializable for TMCTable {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TMCTable> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<String> = None;
    let mut f_7: Option<String> = None;
    let mut f_8: Option<String> = None;
    let mut f_9: Option<String> = None;
    let mut f_10: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_string()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_string()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TMCTable {
      region: f_1,
      project: f_2,
      table: f_3,
      access_key: f_4,
      secret_key: f_5,
      public_access: f_6,
      odps_url: f_7,
      tunnel_url: f_8,
      endpoint: f_9,
      quota: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TMCTable");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.region {
      o_prot.write_field_begin(&TFieldIdentifier::new("region", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.project {
      o_prot.write_field_begin(&TFieldIdentifier::new("project", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.table {
      o_prot.write_field_begin(&TFieldIdentifier::new("table", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.access_key {
      o_prot.write_field_begin(&TFieldIdentifier::new("access_key", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.secret_key {
      o_prot.write_field_begin(&TFieldIdentifier::new("secret_key", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.public_access {
      o_prot.write_field_begin(&TFieldIdentifier::new("public_access", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.odps_url {
      o_prot.write_field_begin(&TFieldIdentifier::new("odps_url", TType::String, 7))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.tunnel_url {
      o_prot.write_field_begin(&TFieldIdentifier::new("tunnel_url", TType::String, 8))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.endpoint {
      o_prot.write_field_begin(&TFieldIdentifier::new("endpoint", TType::String, 9))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.quota {
      o_prot.write_field_begin(&TFieldIdentifier::new("quota", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TTrinoConnectorTable
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTrinoConnectorTable {
  pub db_name: Option<String>,
  pub table_name: Option<String>,
  pub properties: Option<BTreeMap<String, String>>,
}

impl TTrinoConnectorTable {
  pub fn new<F1, F2, F3>(db_name: F1, table_name: F2, properties: F3) -> TTrinoConnectorTable where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<BTreeMap<String, String>>> {
    TTrinoConnectorTable {
      db_name: db_name.into(),
      table_name: table_name.into(),
      properties: properties.into(),
    }
  }
}

impl TSerializable for TTrinoConnectorTable {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTrinoConnectorTable> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<BTreeMap<String, String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_31 = i_prot.read_string()?;
            let map_val_32 = i_prot.read_string()?;
            val.insert(map_key_31, map_val_32);
          }
          i_prot.read_map_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TTrinoConnectorTable {
      db_name: f_1,
      table_name: f_2,
      properties: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TTrinoConnectorTable");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.db_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.table_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.properties {
      o_prot.write_field_begin(&TFieldIdentifier::new("properties", TType::Map, 3))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TLakeSoulTable
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TLakeSoulTable {
  pub db_name: Option<String>,
  pub table_name: Option<String>,
  pub properties: Option<BTreeMap<String, String>>,
}

impl TLakeSoulTable {
  pub fn new<F1, F2, F3>(db_name: F1, table_name: F2, properties: F3) -> TLakeSoulTable where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<BTreeMap<String, String>>> {
    TLakeSoulTable {
      db_name: db_name.into(),
      table_name: table_name.into(),
      properties: properties.into(),
    }
  }
}

impl TSerializable for TLakeSoulTable {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TLakeSoulTable> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<BTreeMap<String, String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_33 = i_prot.read_string()?;
            let map_val_34 = i_prot.read_string()?;
            val.insert(map_key_33, map_val_34);
          }
          i_prot.read_map_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TLakeSoulTable {
      db_name: f_1,
      table_name: f_2,
      properties: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TLakeSoulTable");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.db_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.table_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.properties {
      o_prot.write_field_begin(&TFieldIdentifier::new("properties", TType::Map, 3))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TDictionaryTable
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDictionaryTable {
}

impl TDictionaryTable {
  pub fn new() -> TDictionaryTable {
    TDictionaryTable {}
  }
}

impl TSerializable for TDictionaryTable {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDictionaryTable> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      i_prot.skip(field_ident.field_type)?;
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TDictionaryTable {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDictionaryTable");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TRemoteDorisTable
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TRemoteDorisTable {
  pub db_name: Option<String>,
  pub table_name: Option<String>,
  pub properties: Option<BTreeMap<String, String>>,
}

impl TRemoteDorisTable {
  pub fn new<F1, F2, F3>(db_name: F1, table_name: F2, properties: F3) -> TRemoteDorisTable where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<BTreeMap<String, String>>> {
    TRemoteDorisTable {
      db_name: db_name.into(),
      table_name: table_name.into(),
      properties: properties.into(),
    }
  }
}

impl TSerializable for TRemoteDorisTable {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TRemoteDorisTable> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<BTreeMap<String, String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_35 = i_prot.read_string()?;
            let map_val_36 = i_prot.read_string()?;
            val.insert(map_key_35, map_val_36);
          }
          i_prot.read_map_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TRemoteDorisTable {
      db_name: f_1,
      table_name: f_2,
      properties: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TRemoteDorisTable");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.db_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.table_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.properties {
      o_prot.write_field_begin(&TFieldIdentifier::new("properties", TType::Map, 3))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TTableDescriptor
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTableDescriptor {
  pub id: types::TTableId,
  pub table_type: types::TTableType,
  pub num_cols: i32,
  pub num_clustering_cols: i32,
  pub table_name: String,
  pub db_name: String,
  pub mysql_table: Option<TMySQLTable>,
  pub olap_table: Option<TOlapTable>,
  pub schema_table: Option<TSchemaTable>,
  pub broker_table: Option<TBrokerTable>,
  pub es_table: Option<TEsTable>,
  pub odbc_table: Option<TOdbcTable>,
  pub hive_table: Option<THiveTable>,
  pub iceberg_table: Option<TIcebergTable>,
  pub hudi_table: Option<THudiTable>,
  pub jdbc_table: Option<TJdbcTable>,
  pub mc_table: Option<TMCTable>,
  pub trino_connector_table: Option<TTrinoConnectorTable>,
  pub lakesoul_table: Option<TLakeSoulTable>,
  pub dictionary_table: Option<TDictionaryTable>,
  pub remote_doris_table: Option<TRemoteDorisTable>,
}

impl TTableDescriptor {
  pub fn new<F10, F11, F12, F14, F15, F16, F17, F18, F19, F20, F21, F22, F23, F24, F25>(id: types::TTableId, table_type: types::TTableType, num_cols: i32, num_clustering_cols: i32, table_name: String, db_name: String, mysql_table: F10, olap_table: F11, schema_table: F12, broker_table: F14, es_table: F15, odbc_table: F16, hive_table: F17, iceberg_table: F18, hudi_table: F19, jdbc_table: F20, mc_table: F21, trino_connector_table: F22, lakesoul_table: F23, dictionary_table: F24, remote_doris_table: F25) -> TTableDescriptor where F10: Into<Option<TMySQLTable>>, F11: Into<Option<TOlapTable>>, F12: Into<Option<TSchemaTable>>, F14: Into<Option<TBrokerTable>>, F15: Into<Option<TEsTable>>, F16: Into<Option<TOdbcTable>>, F17: Into<Option<THiveTable>>, F18: Into<Option<TIcebergTable>>, F19: Into<Option<THudiTable>>, F20: Into<Option<TJdbcTable>>, F21: Into<Option<TMCTable>>, F22: Into<Option<TTrinoConnectorTable>>, F23: Into<Option<TLakeSoulTable>>, F24: Into<Option<TDictionaryTable>>, F25: Into<Option<TRemoteDorisTable>> {
    TTableDescriptor {
      id,
      table_type,
      num_cols,
      num_clustering_cols,
      table_name,
      db_name,
      mysql_table: mysql_table.into(),
      olap_table: olap_table.into(),
      schema_table: schema_table.into(),
      broker_table: broker_table.into(),
      es_table: es_table.into(),
      odbc_table: odbc_table.into(),
      hive_table: hive_table.into(),
      iceberg_table: iceberg_table.into(),
      hudi_table: hudi_table.into(),
      jdbc_table: jdbc_table.into(),
      mc_table: mc_table.into(),
      trino_connector_table: trino_connector_table.into(),
      lakesoul_table: lakesoul_table.into(),
      dictionary_table: dictionary_table.into(),
      remote_doris_table: remote_doris_table.into(),
    }
  }
}

impl TSerializable for TTableDescriptor {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTableDescriptor> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<types::TTableId> = None;
    let mut f_2: Option<types::TTableType> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<i32> = None;
    let mut f_7: Option<String> = None;
    let mut f_8: Option<String> = None;
    let mut f_10: Option<TMySQLTable> = None;
    let mut f_11: Option<TOlapTable> = None;
    let mut f_12: Option<TSchemaTable> = None;
    let mut f_14: Option<TBrokerTable> = None;
    let mut f_15: Option<TEsTable> = None;
    let mut f_16: Option<TOdbcTable> = None;
    let mut f_17: Option<THiveTable> = None;
    let mut f_18: Option<TIcebergTable> = None;
    let mut f_19: Option<THudiTable> = None;
    let mut f_20: Option<TJdbcTable> = None;
    let mut f_21: Option<TMCTable> = None;
    let mut f_22: Option<TTrinoConnectorTable> = None;
    let mut f_23: Option<TLakeSoulTable> = None;
    let mut f_24: Option<TDictionaryTable> = None;
    let mut f_25: Option<TRemoteDorisTable> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = types::TTableType::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_string()?;
          f_8 = Some(val);
        },
        10 => {
          let val = TMySQLTable::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        11 => {
          let val = TOlapTable::read_from_in_protocol(i_prot)?;
          f_11 = Some(val);
        },
        12 => {
          let val = TSchemaTable::read_from_in_protocol(i_prot)?;
          f_12 = Some(val);
        },
        14 => {
          let val = TBrokerTable::read_from_in_protocol(i_prot)?;
          f_14 = Some(val);
        },
        15 => {
          let val = TEsTable::read_from_in_protocol(i_prot)?;
          f_15 = Some(val);
        },
        16 => {
          let val = TOdbcTable::read_from_in_protocol(i_prot)?;
          f_16 = Some(val);
        },
        17 => {
          let val = THiveTable::read_from_in_protocol(i_prot)?;
          f_17 = Some(val);
        },
        18 => {
          let val = TIcebergTable::read_from_in_protocol(i_prot)?;
          f_18 = Some(val);
        },
        19 => {
          let val = THudiTable::read_from_in_protocol(i_prot)?;
          f_19 = Some(val);
        },
        20 => {
          let val = TJdbcTable::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        21 => {
          let val = TMCTable::read_from_in_protocol(i_prot)?;
          f_21 = Some(val);
        },
        22 => {
          let val = TTrinoConnectorTable::read_from_in_protocol(i_prot)?;
          f_22 = Some(val);
        },
        23 => {
          let val = TLakeSoulTable::read_from_in_protocol(i_prot)?;
          f_23 = Some(val);
        },
        24 => {
          let val = TDictionaryTable::read_from_in_protocol(i_prot)?;
          f_24 = Some(val);
        },
        25 => {
          let val = TRemoteDorisTable::read_from_in_protocol(i_prot)?;
          f_25 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TTableDescriptor.id", &f_1)?;
    verify_required_field_exists("TTableDescriptor.table_type", &f_2)?;
    verify_required_field_exists("TTableDescriptor.num_cols", &f_3)?;
    verify_required_field_exists("TTableDescriptor.num_clustering_cols", &f_4)?;
    verify_required_field_exists("TTableDescriptor.table_name", &f_7)?;
    verify_required_field_exists("TTableDescriptor.db_name", &f_8)?;
    let ret = TTableDescriptor {
      id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_type: f_2.expect("auto-generated code should have checked for presence of required fields"),
      num_cols: f_3.expect("auto-generated code should have checked for presence of required fields"),
      num_clustering_cols: f_4.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_7.expect("auto-generated code should have checked for presence of required fields"),
      db_name: f_8.expect("auto-generated code should have checked for presence of required fields"),
      mysql_table: f_10,
      olap_table: f_11,
      schema_table: f_12,
      broker_table: f_14,
      es_table: f_15,
      odbc_table: f_16,
      hive_table: f_17,
      iceberg_table: f_18,
      hudi_table: f_19,
      jdbc_table: f_20,
      mc_table: f_21,
      trino_connector_table: f_22,
      lakesoul_table: f_23,
      dictionary_table: f_24,
      remote_doris_table: f_25,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TTableDescriptor");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::I64, 1))?;
    o_prot.write_i64(self.id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tableType", TType::I32, 2))?;
    self.table_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("numCols", TType::I32, 3))?;
    o_prot.write_i32(self.num_cols)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("numClusteringCols", TType::I32, 4))?;
    o_prot.write_i32(self.num_clustering_cols)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tableName", TType::String, 7))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dbName", TType::String, 8))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.mysql_table {
      o_prot.write_field_begin(&TFieldIdentifier::new("mysqlTable", TType::Struct, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.olap_table {
      o_prot.write_field_begin(&TFieldIdentifier::new("olapTable", TType::Struct, 11))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.schema_table {
      o_prot.write_field_begin(&TFieldIdentifier::new("schemaTable", TType::Struct, 12))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.broker_table {
      o_prot.write_field_begin(&TFieldIdentifier::new("BrokerTable", TType::Struct, 14))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.es_table {
      o_prot.write_field_begin(&TFieldIdentifier::new("esTable", TType::Struct, 15))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.odbc_table {
      o_prot.write_field_begin(&TFieldIdentifier::new("odbcTable", TType::Struct, 16))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.hive_table {
      o_prot.write_field_begin(&TFieldIdentifier::new("hiveTable", TType::Struct, 17))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.iceberg_table {
      o_prot.write_field_begin(&TFieldIdentifier::new("icebergTable", TType::Struct, 18))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.hudi_table {
      o_prot.write_field_begin(&TFieldIdentifier::new("hudiTable", TType::Struct, 19))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.jdbc_table {
      o_prot.write_field_begin(&TFieldIdentifier::new("jdbcTable", TType::Struct, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.mc_table {
      o_prot.write_field_begin(&TFieldIdentifier::new("mcTable", TType::Struct, 21))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.trino_connector_table {
      o_prot.write_field_begin(&TFieldIdentifier::new("trinoConnectorTable", TType::Struct, 22))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.lakesoul_table {
      o_prot.write_field_begin(&TFieldIdentifier::new("lakesoulTable", TType::Struct, 23))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.dictionary_table {
      o_prot.write_field_begin(&TFieldIdentifier::new("dictionaryTable", TType::Struct, 24))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.remote_doris_table {
      o_prot.write_field_begin(&TFieldIdentifier::new("remoteDorisTable", TType::Struct, 25))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TDescriptorTable
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDescriptorTable {
  pub slot_descriptors: Option<Vec<TSlotDescriptor>>,
  pub tuple_descriptors: Vec<TTupleDescriptor>,
  pub table_descriptors: Option<Vec<TTableDescriptor>>,
}

impl TDescriptorTable {
  pub fn new<F1, F3>(slot_descriptors: F1, tuple_descriptors: Vec<TTupleDescriptor>, table_descriptors: F3) -> TDescriptorTable where F1: Into<Option<Vec<TSlotDescriptor>>>, F3: Into<Option<Vec<TTableDescriptor>>> {
    TDescriptorTable {
      slot_descriptors: slot_descriptors.into(),
      tuple_descriptors,
      table_descriptors: table_descriptors.into(),
    }
  }
}

impl TSerializable for TDescriptorTable {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDescriptorTable> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<TSlotDescriptor>> = None;
    let mut f_2: Option<Vec<TTupleDescriptor>> = None;
    let mut f_3: Option<Vec<TTableDescriptor>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TSlotDescriptor> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_37 = TSlotDescriptor::read_from_in_protocol(i_prot)?;
            val.push(list_elem_37);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TTupleDescriptor> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_38 = TTupleDescriptor::read_from_in_protocol(i_prot)?;
            val.push(list_elem_38);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TTableDescriptor> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_39 = TTableDescriptor::read_from_in_protocol(i_prot)?;
            val.push(list_elem_39);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TDescriptorTable.tuple_descriptors", &f_2)?;
    let ret = TDescriptorTable {
      slot_descriptors: f_1,
      tuple_descriptors: f_2.expect("auto-generated code should have checked for presence of required fields"),
      table_descriptors: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDescriptorTable");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.slot_descriptors {
      o_prot.write_field_begin(&TFieldIdentifier::new("slotDescriptors", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_begin(&TFieldIdentifier::new("tupleDescriptors", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.tuple_descriptors.len() as i32))?;
    for e in &self.tuple_descriptors {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.table_descriptors {
      o_prot.write_field_begin(&TFieldIdentifier::new("tableDescriptors", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

pub struct ConstCOMPRESSIONMAP;
impl ConstCOMPRESSIONMAP {
  pub fn const_value() -> BTreeMap<String, THdfsCompression> {
    BTreeMap::from([
      (
        "".to_owned(),
        {
          THdfsCompression::from(0)
        },
      ),
      (
        "bzip2".to_owned(),
        {
          THdfsCompression::from(4)
        },
      ),
      (
        "deflate".to_owned(),
        {
          THdfsCompression::from(1)
        },
      ),
      (
        "gzip".to_owned(),
        {
          THdfsCompression::from(2)
        },
      ),
      (
        "none".to_owned(),
        {
          THdfsCompression::from(0)
        },
      ),
      (
        "snappy".to_owned(),
        {
          THdfsCompression::from(5)
        },
      ),
    ])
  }
}

