// Autogenerated by Thrift Compiler (0.19.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(dead_code)]
#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![allow(clippy::too_many_arguments, clippy::type_complexity, clippy::vec_box, clippy::wrong_self_convention)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;

use thrift::OrderedFloat;
use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSerializable, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TUnit(pub i32);

impl TUnit {
  pub const UNIT: TUnit = TUnit(0);
  pub const UNIT_PER_SECOND: TUnit = TUnit(1);
  pub const CPU_TICKS: TUnit = TUnit(2);
  pub const BYTES: TUnit = TUnit(3);
  pub const BYTES_PER_SECOND: TUnit = TUnit(4);
  pub const TIME_NS: TUnit = TUnit(5);
  pub const DOUBLE_VALUE: TUnit = TUnit(6);
  pub const NONE: TUnit = TUnit(7);
  pub const TIME_MS: TUnit = TUnit(8);
  pub const TIME_S: TUnit = TUnit(9);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::UNIT,
    Self::UNIT_PER_SECOND,
    Self::CPU_TICKS,
    Self::BYTES,
    Self::BYTES_PER_SECOND,
    Self::TIME_NS,
    Self::DOUBLE_VALUE,
    Self::NONE,
    Self::TIME_MS,
    Self::TIME_S,
  ];
}

impl TSerializable for TUnit {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TUnit> {
    let enum_value = i_prot.read_i32()?;
    Ok(TUnit::from(enum_value))
  }
}

impl From<i32> for TUnit {
  fn from(i: i32) -> Self {
    match i {
      0 => TUnit::UNIT,
      1 => TUnit::UNIT_PER_SECOND,
      2 => TUnit::CPU_TICKS,
      3 => TUnit::BYTES,
      4 => TUnit::BYTES_PER_SECOND,
      5 => TUnit::TIME_NS,
      6 => TUnit::DOUBLE_VALUE,
      7 => TUnit::NONE,
      8 => TUnit::TIME_MS,
      9 => TUnit::TIME_S,
      _ => TUnit(i)
    }
  }
}

impl From<&i32> for TUnit {
  fn from(i: &i32) -> Self {
    TUnit::from(*i)
  }
}

impl From<TUnit> for i32 {
  fn from(e: TUnit) -> i32 {
    e.0
  }
}

impl From<&TUnit> for i32 {
  fn from(e: &TUnit) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TMetricKind(pub i32);

impl TMetricKind {
  pub const GAUGE: TMetricKind = TMetricKind(0);
  pub const COUNTER: TMetricKind = TMetricKind(1);
  pub const PROPERTY: TMetricKind = TMetricKind(2);
  pub const STATS: TMetricKind = TMetricKind(3);
  pub const SET: TMetricKind = TMetricKind(4);
  pub const HISTOGRAM: TMetricKind = TMetricKind(5);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::GAUGE,
    Self::COUNTER,
    Self::PROPERTY,
    Self::STATS,
    Self::SET,
    Self::HISTOGRAM,
  ];
}

impl TSerializable for TMetricKind {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TMetricKind> {
    let enum_value = i_prot.read_i32()?;
    Ok(TMetricKind::from(enum_value))
  }
}

impl From<i32> for TMetricKind {
  fn from(i: i32) -> Self {
    match i {
      0 => TMetricKind::GAUGE,
      1 => TMetricKind::COUNTER,
      2 => TMetricKind::PROPERTY,
      3 => TMetricKind::STATS,
      4 => TMetricKind::SET,
      5 => TMetricKind::HISTOGRAM,
      _ => TMetricKind(i)
    }
  }
}

impl From<&i32> for TMetricKind {
  fn from(i: &i32) -> Self {
    TMetricKind::from(*i)
  }
}

impl From<TMetricKind> for i32 {
  fn from(e: TMetricKind) -> i32 {
    e.0
  }
}

impl From<&TMetricKind> for i32 {
  fn from(e: &TMetricKind) -> i32 {
    e.0
  }
}

