// Autogenerated by Thrift Compiler (0.19.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(dead_code)]
#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![allow(clippy::too_many_arguments, clippy::type_complexity, clippy::vec_box, clippy::wrong_self_convention)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;

use thrift::OrderedFloat;
use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSerializable, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

use crate::exprs;
use crate::types;

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TPartitionType(pub i32);

impl TPartitionType {
  pub const UNPARTITIONED: TPartitionType = TPartitionType(0);
  pub const RANDOM: TPartitionType = TPartitionType(1);
  pub const HASH_PARTITIONED: TPartitionType = TPartitionType(2);
  pub const RANGE_PARTITIONED: TPartitionType = TPartitionType(3);
  pub const LIST_PARTITIONED: TPartitionType = TPartitionType(4);
  pub const BUCKET_SHFFULE_HASH_PARTITIONED: TPartitionType = TPartitionType(5);
  pub const OLAP_TABLE_SINK_HASH_PARTITIONED: TPartitionType = TPartitionType(6);
  pub const HIVE_TABLE_SINK_HASH_PARTITIONED: TPartitionType = TPartitionType(7);
  pub const HIVE_TABLE_SINK_UNPARTITIONED: TPartitionType = TPartitionType(8);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::UNPARTITIONED,
    Self::RANDOM,
    Self::HASH_PARTITIONED,
    Self::RANGE_PARTITIONED,
    Self::LIST_PARTITIONED,
    Self::BUCKET_SHFFULE_HASH_PARTITIONED,
    Self::OLAP_TABLE_SINK_HASH_PARTITIONED,
    Self::HIVE_TABLE_SINK_HASH_PARTITIONED,
    Self::HIVE_TABLE_SINK_UNPARTITIONED,
  ];
}

impl TSerializable for TPartitionType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TPartitionType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TPartitionType::from(enum_value))
  }
}

impl From<i32> for TPartitionType {
  fn from(i: i32) -> Self {
    match i {
      0 => TPartitionType::UNPARTITIONED,
      1 => TPartitionType::RANDOM,
      2 => TPartitionType::HASH_PARTITIONED,
      3 => TPartitionType::RANGE_PARTITIONED,
      4 => TPartitionType::LIST_PARTITIONED,
      5 => TPartitionType::BUCKET_SHFFULE_HASH_PARTITIONED,
      6 => TPartitionType::OLAP_TABLE_SINK_HASH_PARTITIONED,
      7 => TPartitionType::HIVE_TABLE_SINK_HASH_PARTITIONED,
      8 => TPartitionType::HIVE_TABLE_SINK_UNPARTITIONED,
      _ => TPartitionType(i)
    }
  }
}

impl From<&i32> for TPartitionType {
  fn from(i: &i32) -> Self {
    TPartitionType::from(*i)
  }
}

impl From<TPartitionType> for i32 {
  fn from(e: TPartitionType) -> i32 {
    e.0
  }
}

impl From<&TPartitionType> for i32 {
  fn from(e: &TPartitionType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDistributionType(pub i32);

impl TDistributionType {
  pub const UNPARTITIONED: TDistributionType = TDistributionType(0);
  pub const RANDOM: TDistributionType = TDistributionType(1);
  pub const HASH_PARTITIONED: TDistributionType = TDistributionType(2);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::UNPARTITIONED,
    Self::RANDOM,
    Self::HASH_PARTITIONED,
  ];
}

impl TSerializable for TDistributionType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDistributionType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TDistributionType::from(enum_value))
  }
}

impl From<i32> for TDistributionType {
  fn from(i: i32) -> Self {
    match i {
      0 => TDistributionType::UNPARTITIONED,
      1 => TDistributionType::RANDOM,
      2 => TDistributionType::HASH_PARTITIONED,
      _ => TDistributionType(i)
    }
  }
}

impl From<&i32> for TDistributionType {
  fn from(i: &i32) -> Self {
    TDistributionType::from(*i)
  }
}

impl From<TDistributionType> for i32 {
  fn from(e: TDistributionType) -> i32 {
    e.0
  }
}

impl From<&TDistributionType> for i32 {
  fn from(e: &TDistributionType) -> i32 {
    e.0
  }
}

//
// TPartitionKey
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TPartitionKey {
  pub sign: i16,
  pub type_: Option<types::TPrimitiveType>,
  pub key: Option<String>,
}

impl TPartitionKey {
  pub fn new<F2, F3>(sign: i16, type_: F2, key: F3) -> TPartitionKey where F2: Into<Option<types::TPrimitiveType>>, F3: Into<Option<String>> {
    TPartitionKey {
      sign,
      type_: type_.into(),
      key: key.into(),
    }
  }
}

impl TSerializable for TPartitionKey {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TPartitionKey> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i16> = None;
    let mut f_2: Option<types::TPrimitiveType> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i16()?;
          f_1 = Some(val);
        },
        2 => {
          let val = types::TPrimitiveType::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TPartitionKey.sign", &f_1)?;
    let ret = TPartitionKey {
      sign: f_1.expect("auto-generated code should have checked for presence of required fields"),
      type_: f_2,
      key: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TPartitionKey");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sign", TType::I16, 1))?;
    o_prot.write_i16(self.sign)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.type_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.key {
      o_prot.write_field_begin(&TFieldIdentifier::new("key", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TPartitionRange
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TPartitionRange {
  pub start_key: TPartitionKey,
  pub end_key: TPartitionKey,
  pub include_start_key: bool,
  pub include_end_key: bool,
}

impl TPartitionRange {
  pub fn new(start_key: TPartitionKey, end_key: TPartitionKey, include_start_key: bool, include_end_key: bool) -> TPartitionRange {
    TPartitionRange {
      start_key,
      end_key,
      include_start_key,
      include_end_key,
    }
  }
}

impl TSerializable for TPartitionRange {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TPartitionRange> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TPartitionKey> = None;
    let mut f_2: Option<TPartitionKey> = None;
    let mut f_3: Option<bool> = None;
    let mut f_4: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TPartitionKey::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = TPartitionKey::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TPartitionRange.start_key", &f_1)?;
    verify_required_field_exists("TPartitionRange.end_key", &f_2)?;
    verify_required_field_exists("TPartitionRange.include_start_key", &f_3)?;
    verify_required_field_exists("TPartitionRange.include_end_key", &f_4)?;
    let ret = TPartitionRange {
      start_key: f_1.expect("auto-generated code should have checked for presence of required fields"),
      end_key: f_2.expect("auto-generated code should have checked for presence of required fields"),
      include_start_key: f_3.expect("auto-generated code should have checked for presence of required fields"),
      include_end_key: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TPartitionRange");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("start_key", TType::Struct, 1))?;
    self.start_key.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("end_key", TType::Struct, 2))?;
    self.end_key.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("include_start_key", TType::Bool, 3))?;
    o_prot.write_bool(self.include_start_key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("include_end_key", TType::Bool, 4))?;
    o_prot.write_bool(self.include_end_key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TRangePartition
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TRangePartition {
  pub partition_id: i64,
  pub range: TPartitionRange,
  pub distributed_exprs: Option<Vec<exprs::TExpr>>,
  pub distribute_bucket: Option<i32>,
}

impl TRangePartition {
  pub fn new<F3, F4>(partition_id: i64, range: TPartitionRange, distributed_exprs: F3, distribute_bucket: F4) -> TRangePartition where F3: Into<Option<Vec<exprs::TExpr>>>, F4: Into<Option<i32>> {
    TRangePartition {
      partition_id,
      range,
      distributed_exprs: distributed_exprs.into(),
      distribute_bucket: distribute_bucket.into(),
    }
  }
}

impl TSerializable for TRangePartition {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TRangePartition> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<TPartitionRange> = None;
    let mut f_3: Option<Vec<exprs::TExpr>> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = TPartitionRange::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<exprs::TExpr> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_0 = exprs::TExpr::read_from_in_protocol(i_prot)?;
            val.push(list_elem_0);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TRangePartition.partition_id", &f_1)?;
    verify_required_field_exists("TRangePartition.range", &f_2)?;
    let ret = TRangePartition {
      partition_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      range: f_2.expect("auto-generated code should have checked for presence of required fields"),
      distributed_exprs: f_3,
      distribute_bucket: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TRangePartition");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("partition_id", TType::I64, 1))?;
    o_prot.write_i64(self.partition_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("range", TType::Struct, 2))?;
    self.range.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.distributed_exprs {
      o_prot.write_field_begin(&TFieldIdentifier::new("distributed_exprs", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.distribute_bucket {
      o_prot.write_field_begin(&TFieldIdentifier::new("distribute_bucket", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TDataPartition
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDataPartition {
  pub type_: TPartitionType,
  pub partition_exprs: Option<Vec<exprs::TExpr>>,
  pub partition_infos: Option<Vec<TRangePartition>>,
}

impl TDataPartition {
  pub fn new<F2, F3>(type_: TPartitionType, partition_exprs: F2, partition_infos: F3) -> TDataPartition where F2: Into<Option<Vec<exprs::TExpr>>>, F3: Into<Option<Vec<TRangePartition>>> {
    TDataPartition {
      type_,
      partition_exprs: partition_exprs.into(),
      partition_infos: partition_infos.into(),
    }
  }
}

impl TSerializable for TDataPartition {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDataPartition> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TPartitionType> = None;
    let mut f_2: Option<Vec<exprs::TExpr>> = None;
    let mut f_3: Option<Vec<TRangePartition>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TPartitionType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<exprs::TExpr> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_1 = exprs::TExpr::read_from_in_protocol(i_prot)?;
            val.push(list_elem_1);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TRangePartition> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_2 = TRangePartition::read_from_in_protocol(i_prot)?;
            val.push(list_elem_2);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TDataPartition.type_", &f_1)?;
    let ret = TDataPartition {
      type_: f_1.expect("auto-generated code should have checked for presence of required fields"),
      partition_exprs: f_2,
      partition_infos: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDataPartition");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 1))?;
    self.type_.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.partition_exprs {
      o_prot.write_field_begin(&TFieldIdentifier::new("partition_exprs", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.partition_infos {
      o_prot.write_field_begin(&TFieldIdentifier::new("partition_infos", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

