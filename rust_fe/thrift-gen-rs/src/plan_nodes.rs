// Autogenerated by Thrift Compiler (0.19.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(dead_code)]
#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![allow(clippy::too_many_arguments, clippy::type_complexity, clippy::vec_box, clippy::wrong_self_convention)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;

use thrift::OrderedFloat;
use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSerializable, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

use crate::descriptors;
use crate::exprs;
use crate::external_table_schema;
use crate::opcodes;
use crate::partitions;
use crate::types;

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TPlanNodeType(pub i32);

impl TPlanNodeType {
  pub const OLAP_SCAN_NODE: TPlanNodeType = TPlanNodeType(0);
  pub const MYSQL_SCAN_NODE: TPlanNodeType = TPlanNodeType(1);
  pub const CSV_SCAN_NODE: TPlanNodeType = TPlanNodeType(2);
  pub const SCHEMA_SCAN_NODE: TPlanNodeType = TPlanNodeType(3);
  pub const HASH_JOIN_NODE: TPlanNodeType = TPlanNodeType(4);
  pub const MERGE_JOIN_NODE: TPlanNodeType = TPlanNodeType(5);
  pub const AGGREGATION_NODE: TPlanNodeType = TPlanNodeType(6);
  pub const PRE_AGGREGATION_NODE: TPlanNodeType = TPlanNodeType(7);
  pub const SORT_NODE: TPlanNodeType = TPlanNodeType(8);
  pub const EXCHANGE_NODE: TPlanNodeType = TPlanNodeType(9);
  pub const MERGE_NODE: TPlanNodeType = TPlanNodeType(10);
  pub const SELECT_NODE: TPlanNodeType = TPlanNodeType(11);
  pub const CROSS_JOIN_NODE: TPlanNodeType = TPlanNodeType(12);
  pub const META_SCAN_NODE: TPlanNodeType = TPlanNodeType(13);
  pub const ANALYTIC_EVAL_NODE: TPlanNodeType = TPlanNodeType(14);
  pub const OLAP_REWRITE_NODE: TPlanNodeType = TPlanNodeType(15);
  pub const KUDU_SCAN_NODE: TPlanNodeType = TPlanNodeType(16);
  pub const BROKER_SCAN_NODE: TPlanNodeType = TPlanNodeType(17);
  pub const EMPTY_SET_NODE: TPlanNodeType = TPlanNodeType(18);
  pub const UNION_NODE: TPlanNodeType = TPlanNodeType(19);
  pub const ES_SCAN_NODE: TPlanNodeType = TPlanNodeType(20);
  pub const ES_HTTP_SCAN_NODE: TPlanNodeType = TPlanNodeType(21);
  pub const REPEAT_NODE: TPlanNodeType = TPlanNodeType(22);
  pub const ASSERT_NUM_ROWS_NODE: TPlanNodeType = TPlanNodeType(23);
  pub const INTERSECT_NODE: TPlanNodeType = TPlanNodeType(24);
  pub const EXCEPT_NODE: TPlanNodeType = TPlanNodeType(25);
  pub const ODBC_SCAN_NODE: TPlanNodeType = TPlanNodeType(26);
  pub const TABLE_FUNCTION_NODE: TPlanNodeType = TPlanNodeType(27);
  pub const DATA_GEN_SCAN_NODE: TPlanNodeType = TPlanNodeType(28);
  pub const FILE_SCAN_NODE: TPlanNodeType = TPlanNodeType(29);
  pub const JDBC_SCAN_NODE: TPlanNodeType = TPlanNodeType(30);
  pub const TEST_EXTERNAL_SCAN_NODE: TPlanNodeType = TPlanNodeType(31);
  pub const PARTITION_SORT_NODE: TPlanNodeType = TPlanNodeType(32);
  pub const GROUP_COMMIT_SCAN_NODE: TPlanNodeType = TPlanNodeType(33);
  pub const MATERIALIZATION_NODE: TPlanNodeType = TPlanNodeType(34);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::OLAP_SCAN_NODE,
    Self::MYSQL_SCAN_NODE,
    Self::CSV_SCAN_NODE,
    Self::SCHEMA_SCAN_NODE,
    Self::HASH_JOIN_NODE,
    Self::MERGE_JOIN_NODE,
    Self::AGGREGATION_NODE,
    Self::PRE_AGGREGATION_NODE,
    Self::SORT_NODE,
    Self::EXCHANGE_NODE,
    Self::MERGE_NODE,
    Self::SELECT_NODE,
    Self::CROSS_JOIN_NODE,
    Self::META_SCAN_NODE,
    Self::ANALYTIC_EVAL_NODE,
    Self::OLAP_REWRITE_NODE,
    Self::KUDU_SCAN_NODE,
    Self::BROKER_SCAN_NODE,
    Self::EMPTY_SET_NODE,
    Self::UNION_NODE,
    Self::ES_SCAN_NODE,
    Self::ES_HTTP_SCAN_NODE,
    Self::REPEAT_NODE,
    Self::ASSERT_NUM_ROWS_NODE,
    Self::INTERSECT_NODE,
    Self::EXCEPT_NODE,
    Self::ODBC_SCAN_NODE,
    Self::TABLE_FUNCTION_NODE,
    Self::DATA_GEN_SCAN_NODE,
    Self::FILE_SCAN_NODE,
    Self::JDBC_SCAN_NODE,
    Self::TEST_EXTERNAL_SCAN_NODE,
    Self::PARTITION_SORT_NODE,
    Self::GROUP_COMMIT_SCAN_NODE,
    Self::MATERIALIZATION_NODE,
  ];
}

impl TSerializable for TPlanNodeType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TPlanNodeType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TPlanNodeType::from(enum_value))
  }
}

impl From<i32> for TPlanNodeType {
  fn from(i: i32) -> Self {
    match i {
      0 => TPlanNodeType::OLAP_SCAN_NODE,
      1 => TPlanNodeType::MYSQL_SCAN_NODE,
      2 => TPlanNodeType::CSV_SCAN_NODE,
      3 => TPlanNodeType::SCHEMA_SCAN_NODE,
      4 => TPlanNodeType::HASH_JOIN_NODE,
      5 => TPlanNodeType::MERGE_JOIN_NODE,
      6 => TPlanNodeType::AGGREGATION_NODE,
      7 => TPlanNodeType::PRE_AGGREGATION_NODE,
      8 => TPlanNodeType::SORT_NODE,
      9 => TPlanNodeType::EXCHANGE_NODE,
      10 => TPlanNodeType::MERGE_NODE,
      11 => TPlanNodeType::SELECT_NODE,
      12 => TPlanNodeType::CROSS_JOIN_NODE,
      13 => TPlanNodeType::META_SCAN_NODE,
      14 => TPlanNodeType::ANALYTIC_EVAL_NODE,
      15 => TPlanNodeType::OLAP_REWRITE_NODE,
      16 => TPlanNodeType::KUDU_SCAN_NODE,
      17 => TPlanNodeType::BROKER_SCAN_NODE,
      18 => TPlanNodeType::EMPTY_SET_NODE,
      19 => TPlanNodeType::UNION_NODE,
      20 => TPlanNodeType::ES_SCAN_NODE,
      21 => TPlanNodeType::ES_HTTP_SCAN_NODE,
      22 => TPlanNodeType::REPEAT_NODE,
      23 => TPlanNodeType::ASSERT_NUM_ROWS_NODE,
      24 => TPlanNodeType::INTERSECT_NODE,
      25 => TPlanNodeType::EXCEPT_NODE,
      26 => TPlanNodeType::ODBC_SCAN_NODE,
      27 => TPlanNodeType::TABLE_FUNCTION_NODE,
      28 => TPlanNodeType::DATA_GEN_SCAN_NODE,
      29 => TPlanNodeType::FILE_SCAN_NODE,
      30 => TPlanNodeType::JDBC_SCAN_NODE,
      31 => TPlanNodeType::TEST_EXTERNAL_SCAN_NODE,
      32 => TPlanNodeType::PARTITION_SORT_NODE,
      33 => TPlanNodeType::GROUP_COMMIT_SCAN_NODE,
      34 => TPlanNodeType::MATERIALIZATION_NODE,
      _ => TPlanNodeType(i)
    }
  }
}

impl From<&i32> for TPlanNodeType {
  fn from(i: &i32) -> Self {
    TPlanNodeType::from(*i)
  }
}

impl From<TPlanNodeType> for i32 {
  fn from(e: TPlanNodeType) -> i32 {
    e.0
  }
}

impl From<&TPlanNodeType> for i32 {
  fn from(e: &TPlanNodeType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TFileFormatType(pub i32);

impl TFileFormatType {
  pub const FORMAT_UNKNOWN: TFileFormatType = TFileFormatType(-1);
  pub const FORMAT_CSV_PLAIN: TFileFormatType = TFileFormatType(0);
  pub const FORMAT_CSV_GZ: TFileFormatType = TFileFormatType(1);
  pub const FORMAT_CSV_LZO: TFileFormatType = TFileFormatType(2);
  pub const FORMAT_CSV_BZ2: TFileFormatType = TFileFormatType(3);
  pub const FORMAT_CSV_LZ4FRAME: TFileFormatType = TFileFormatType(4);
  pub const FORMAT_CSV_LZOP: TFileFormatType = TFileFormatType(5);
  pub const FORMAT_PARQUET: TFileFormatType = TFileFormatType(6);
  pub const FORMAT_CSV_DEFLATE: TFileFormatType = TFileFormatType(7);
  pub const FORMAT_ORC: TFileFormatType = TFileFormatType(8);
  pub const FORMAT_JSON: TFileFormatType = TFileFormatType(9);
  pub const FORMAT_PROTO: TFileFormatType = TFileFormatType(10);
  pub const FORMAT_JNI: TFileFormatType = TFileFormatType(11);
  pub const FORMAT_AVRO: TFileFormatType = TFileFormatType(12);
  pub const FORMAT_CSV_LZ4BLOCK: TFileFormatType = TFileFormatType(13);
  pub const FORMAT_CSV_SNAPPYBLOCK: TFileFormatType = TFileFormatType(14);
  pub const FORMAT_WAL: TFileFormatType = TFileFormatType(15);
  pub const FORMAT_ARROW: TFileFormatType = TFileFormatType(16);
  pub const FORMAT_TEXT: TFileFormatType = TFileFormatType(17);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::FORMAT_UNKNOWN,
    Self::FORMAT_CSV_PLAIN,
    Self::FORMAT_CSV_GZ,
    Self::FORMAT_CSV_LZO,
    Self::FORMAT_CSV_BZ2,
    Self::FORMAT_CSV_LZ4FRAME,
    Self::FORMAT_CSV_LZOP,
    Self::FORMAT_PARQUET,
    Self::FORMAT_CSV_DEFLATE,
    Self::FORMAT_ORC,
    Self::FORMAT_JSON,
    Self::FORMAT_PROTO,
    Self::FORMAT_JNI,
    Self::FORMAT_AVRO,
    Self::FORMAT_CSV_LZ4BLOCK,
    Self::FORMAT_CSV_SNAPPYBLOCK,
    Self::FORMAT_WAL,
    Self::FORMAT_ARROW,
    Self::FORMAT_TEXT,
  ];
}

impl TSerializable for TFileFormatType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TFileFormatType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TFileFormatType::from(enum_value))
  }
}

impl From<i32> for TFileFormatType {
  fn from(i: i32) -> Self {
    match i {
      -1 => TFileFormatType::FORMAT_UNKNOWN,
      0 => TFileFormatType::FORMAT_CSV_PLAIN,
      1 => TFileFormatType::FORMAT_CSV_GZ,
      2 => TFileFormatType::FORMAT_CSV_LZO,
      3 => TFileFormatType::FORMAT_CSV_BZ2,
      4 => TFileFormatType::FORMAT_CSV_LZ4FRAME,
      5 => TFileFormatType::FORMAT_CSV_LZOP,
      6 => TFileFormatType::FORMAT_PARQUET,
      7 => TFileFormatType::FORMAT_CSV_DEFLATE,
      8 => TFileFormatType::FORMAT_ORC,
      9 => TFileFormatType::FORMAT_JSON,
      10 => TFileFormatType::FORMAT_PROTO,
      11 => TFileFormatType::FORMAT_JNI,
      12 => TFileFormatType::FORMAT_AVRO,
      13 => TFileFormatType::FORMAT_CSV_LZ4BLOCK,
      14 => TFileFormatType::FORMAT_CSV_SNAPPYBLOCK,
      15 => TFileFormatType::FORMAT_WAL,
      16 => TFileFormatType::FORMAT_ARROW,
      17 => TFileFormatType::FORMAT_TEXT,
      _ => TFileFormatType(i)
    }
  }
}

impl From<&i32> for TFileFormatType {
  fn from(i: &i32) -> Self {
    TFileFormatType::from(*i)
  }
}

impl From<TFileFormatType> for i32 {
  fn from(e: TFileFormatType) -> i32 {
    e.0
  }
}

impl From<&TFileFormatType> for i32 {
  fn from(e: &TFileFormatType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TFileCompressType(pub i32);

impl TFileCompressType {
  pub const UNKNOWN: TFileCompressType = TFileCompressType(0);
  pub const PLAIN: TFileCompressType = TFileCompressType(1);
  pub const GZ: TFileCompressType = TFileCompressType(2);
  pub const LZO: TFileCompressType = TFileCompressType(3);
  pub const BZ2: TFileCompressType = TFileCompressType(4);
  pub const LZ4FRAME: TFileCompressType = TFileCompressType(5);
  pub const DEFLATE: TFileCompressType = TFileCompressType(6);
  pub const LZOP: TFileCompressType = TFileCompressType(7);
  pub const LZ4BLOCK: TFileCompressType = TFileCompressType(8);
  pub const SNAPPYBLOCK: TFileCompressType = TFileCompressType(9);
  pub const ZLIB: TFileCompressType = TFileCompressType(10);
  pub const ZSTD: TFileCompressType = TFileCompressType(11);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::UNKNOWN,
    Self::PLAIN,
    Self::GZ,
    Self::LZO,
    Self::BZ2,
    Self::LZ4FRAME,
    Self::DEFLATE,
    Self::LZOP,
    Self::LZ4BLOCK,
    Self::SNAPPYBLOCK,
    Self::ZLIB,
    Self::ZSTD,
  ];
}

impl TSerializable for TFileCompressType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TFileCompressType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TFileCompressType::from(enum_value))
  }
}

impl From<i32> for TFileCompressType {
  fn from(i: i32) -> Self {
    match i {
      0 => TFileCompressType::UNKNOWN,
      1 => TFileCompressType::PLAIN,
      2 => TFileCompressType::GZ,
      3 => TFileCompressType::LZO,
      4 => TFileCompressType::BZ2,
      5 => TFileCompressType::LZ4FRAME,
      6 => TFileCompressType::DEFLATE,
      7 => TFileCompressType::LZOP,
      8 => TFileCompressType::LZ4BLOCK,
      9 => TFileCompressType::SNAPPYBLOCK,
      10 => TFileCompressType::ZLIB,
      11 => TFileCompressType::ZSTD,
      _ => TFileCompressType(i)
    }
  }
}

impl From<&i32> for TFileCompressType {
  fn from(i: &i32) -> Self {
    TFileCompressType::from(*i)
  }
}

impl From<TFileCompressType> for i32 {
  fn from(e: TFileCompressType) -> i32 {
    e.0
  }
}

impl From<&TFileCompressType> for i32 {
  fn from(e: &TFileCompressType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTextSerdeType(pub i32);

impl TTextSerdeType {
  pub const JSON_TEXT_SERDE: TTextSerdeType = TTextSerdeType(0);
  pub const HIVE_TEXT_SERDE: TTextSerdeType = TTextSerdeType(1);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::JSON_TEXT_SERDE,
    Self::HIVE_TEXT_SERDE,
  ];
}

impl TSerializable for TTextSerdeType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTextSerdeType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TTextSerdeType::from(enum_value))
  }
}

impl From<i32> for TTextSerdeType {
  fn from(i: i32) -> Self {
    match i {
      0 => TTextSerdeType::JSON_TEXT_SERDE,
      1 => TTextSerdeType::HIVE_TEXT_SERDE,
      _ => TTextSerdeType(i)
    }
  }
}

impl From<&i32> for TTextSerdeType {
  fn from(i: &i32) -> Self {
    TTextSerdeType::from(*i)
  }
}

impl From<TTextSerdeType> for i32 {
  fn from(e: TTextSerdeType) -> i32 {
    e.0
  }
}

impl From<&TTextSerdeType> for i32 {
  fn from(e: &TTextSerdeType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDataGenFunctionName(pub i32);

impl TDataGenFunctionName {
  pub const NUMBERS: TDataGenFunctionName = TDataGenFunctionName(0);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NUMBERS,
  ];
}

impl TSerializable for TDataGenFunctionName {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDataGenFunctionName> {
    let enum_value = i_prot.read_i32()?;
    Ok(TDataGenFunctionName::from(enum_value))
  }
}

impl From<i32> for TDataGenFunctionName {
  fn from(i: i32) -> Self {
    match i {
      0 => TDataGenFunctionName::NUMBERS,
      _ => TDataGenFunctionName(i)
    }
  }
}

impl From<&i32> for TDataGenFunctionName {
  fn from(i: &i32) -> Self {
    TDataGenFunctionName::from(*i)
  }
}

impl From<TDataGenFunctionName> for i32 {
  fn from(e: TDataGenFunctionName) -> i32 {
    e.0
  }
}

impl From<&TDataGenFunctionName> for i32 {
  fn from(e: &TDataGenFunctionName) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TPushAggOp(pub i32);

impl TPushAggOp {
  pub const NONE: TPushAggOp = TPushAggOp(0);
  pub const MINMAX: TPushAggOp = TPushAggOp(1);
  pub const COUNT: TPushAggOp = TPushAggOp(2);
  pub const MIX: TPushAggOp = TPushAggOp(3);
  pub const COUNT_ON_INDEX: TPushAggOp = TPushAggOp(4);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::MINMAX,
    Self::COUNT,
    Self::MIX,
    Self::COUNT_ON_INDEX,
  ];
}

impl TSerializable for TPushAggOp {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TPushAggOp> {
    let enum_value = i_prot.read_i32()?;
    Ok(TPushAggOp::from(enum_value))
  }
}

impl From<i32> for TPushAggOp {
  fn from(i: i32) -> Self {
    match i {
      0 => TPushAggOp::NONE,
      1 => TPushAggOp::MINMAX,
      2 => TPushAggOp::COUNT,
      3 => TPushAggOp::MIX,
      4 => TPushAggOp::COUNT_ON_INDEX,
      _ => TPushAggOp(i)
    }
  }
}

impl From<&i32> for TPushAggOp {
  fn from(i: &i32) -> Self {
    TPushAggOp::from(*i)
  }
}

impl From<TPushAggOp> for i32 {
  fn from(e: TPushAggOp) -> i32 {
    e.0
  }
}

impl From<&TPushAggOp> for i32 {
  fn from(e: &TPushAggOp) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TJoinOp(pub i32);

impl TJoinOp {
  pub const INNER_JOIN: TJoinOp = TJoinOp(0);
  pub const LEFT_OUTER_JOIN: TJoinOp = TJoinOp(1);
  pub const LEFT_SEMI_JOIN: TJoinOp = TJoinOp(2);
  pub const RIGHT_OUTER_JOIN: TJoinOp = TJoinOp(3);
  pub const FULL_OUTER_JOIN: TJoinOp = TJoinOp(4);
  pub const CROSS_JOIN: TJoinOp = TJoinOp(5);
  pub const MERGE_JOIN: TJoinOp = TJoinOp(6);
  pub const RIGHT_SEMI_JOIN: TJoinOp = TJoinOp(7);
  pub const LEFT_ANTI_JOIN: TJoinOp = TJoinOp(8);
  pub const RIGHT_ANTI_JOIN: TJoinOp = TJoinOp(9);
  pub const NULL_AWARE_LEFT_ANTI_JOIN: TJoinOp = TJoinOp(10);
  pub const NULL_AWARE_LEFT_SEMI_JOIN: TJoinOp = TJoinOp(11);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::INNER_JOIN,
    Self::LEFT_OUTER_JOIN,
    Self::LEFT_SEMI_JOIN,
    Self::RIGHT_OUTER_JOIN,
    Self::FULL_OUTER_JOIN,
    Self::CROSS_JOIN,
    Self::MERGE_JOIN,
    Self::RIGHT_SEMI_JOIN,
    Self::LEFT_ANTI_JOIN,
    Self::RIGHT_ANTI_JOIN,
    Self::NULL_AWARE_LEFT_ANTI_JOIN,
    Self::NULL_AWARE_LEFT_SEMI_JOIN,
  ];
}

impl TSerializable for TJoinOp {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TJoinOp> {
    let enum_value = i_prot.read_i32()?;
    Ok(TJoinOp::from(enum_value))
  }
}

impl From<i32> for TJoinOp {
  fn from(i: i32) -> Self {
    match i {
      0 => TJoinOp::INNER_JOIN,
      1 => TJoinOp::LEFT_OUTER_JOIN,
      2 => TJoinOp::LEFT_SEMI_JOIN,
      3 => TJoinOp::RIGHT_OUTER_JOIN,
      4 => TJoinOp::FULL_OUTER_JOIN,
      5 => TJoinOp::CROSS_JOIN,
      6 => TJoinOp::MERGE_JOIN,
      7 => TJoinOp::RIGHT_SEMI_JOIN,
      8 => TJoinOp::LEFT_ANTI_JOIN,
      9 => TJoinOp::RIGHT_ANTI_JOIN,
      10 => TJoinOp::NULL_AWARE_LEFT_ANTI_JOIN,
      11 => TJoinOp::NULL_AWARE_LEFT_SEMI_JOIN,
      _ => TJoinOp(i)
    }
  }
}

impl From<&i32> for TJoinOp {
  fn from(i: &i32) -> Self {
    TJoinOp::from(*i)
  }
}

impl From<TJoinOp> for i32 {
  fn from(e: TJoinOp) -> i32 {
    e.0
  }
}

impl From<&TJoinOp> for i32 {
  fn from(e: &TJoinOp) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TJoinDistributionType(pub i32);

impl TJoinDistributionType {
  pub const NONE: TJoinDistributionType = TJoinDistributionType(0);
  pub const BROADCAST: TJoinDistributionType = TJoinDistributionType(1);
  pub const PARTITIONED: TJoinDistributionType = TJoinDistributionType(2);
  pub const BUCKET_SHUFFLE: TJoinDistributionType = TJoinDistributionType(3);
  pub const COLOCATE: TJoinDistributionType = TJoinDistributionType(4);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::BROADCAST,
    Self::PARTITIONED,
    Self::BUCKET_SHUFFLE,
    Self::COLOCATE,
  ];
}

impl TSerializable for TJoinDistributionType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TJoinDistributionType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TJoinDistributionType::from(enum_value))
  }
}

impl From<i32> for TJoinDistributionType {
  fn from(i: i32) -> Self {
    match i {
      0 => TJoinDistributionType::NONE,
      1 => TJoinDistributionType::BROADCAST,
      2 => TJoinDistributionType::PARTITIONED,
      3 => TJoinDistributionType::BUCKET_SHUFFLE,
      4 => TJoinDistributionType::COLOCATE,
      _ => TJoinDistributionType(i)
    }
  }
}

impl From<&i32> for TJoinDistributionType {
  fn from(i: &i32) -> Self {
    TJoinDistributionType::from(*i)
  }
}

impl From<TJoinDistributionType> for i32 {
  fn from(e: TJoinDistributionType) -> i32 {
    e.0
  }
}

impl From<&TJoinDistributionType> for i32 {
  fn from(e: &TJoinDistributionType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TAggregationOp(pub i32);

impl TAggregationOp {
  pub const INVALID: TAggregationOp = TAggregationOp(0);
  pub const COUNT: TAggregationOp = TAggregationOp(1);
  pub const MAX: TAggregationOp = TAggregationOp(2);
  pub const DISTINCT_PC: TAggregationOp = TAggregationOp(3);
  pub const DISTINCT_PCSA: TAggregationOp = TAggregationOp(4);
  pub const MIN: TAggregationOp = TAggregationOp(5);
  pub const SUM: TAggregationOp = TAggregationOp(6);
  pub const GROUP_CONCAT: TAggregationOp = TAggregationOp(7);
  pub const HLL: TAggregationOp = TAggregationOp(8);
  pub const COUNT_DISTINCT: TAggregationOp = TAggregationOp(9);
  pub const SUM_DISTINCT: TAggregationOp = TAggregationOp(10);
  pub const LEAD: TAggregationOp = TAggregationOp(11);
  pub const FIRST_VALUE: TAggregationOp = TAggregationOp(12);
  pub const LAST_VALUE: TAggregationOp = TAggregationOp(13);
  pub const RANK: TAggregationOp = TAggregationOp(14);
  pub const DENSE_RANK: TAggregationOp = TAggregationOp(15);
  pub const ROW_NUMBER: TAggregationOp = TAggregationOp(16);
  pub const LAG: TAggregationOp = TAggregationOp(17);
  pub const HLL_C: TAggregationOp = TAggregationOp(18);
  pub const BITMAP_UNION: TAggregationOp = TAggregationOp(19);
  pub const NTILE: TAggregationOp = TAggregationOp(20);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::INVALID,
    Self::COUNT,
    Self::MAX,
    Self::DISTINCT_PC,
    Self::DISTINCT_PCSA,
    Self::MIN,
    Self::SUM,
    Self::GROUP_CONCAT,
    Self::HLL,
    Self::COUNT_DISTINCT,
    Self::SUM_DISTINCT,
    Self::LEAD,
    Self::FIRST_VALUE,
    Self::LAST_VALUE,
    Self::RANK,
    Self::DENSE_RANK,
    Self::ROW_NUMBER,
    Self::LAG,
    Self::HLL_C,
    Self::BITMAP_UNION,
    Self::NTILE,
  ];
}

impl TSerializable for TAggregationOp {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TAggregationOp> {
    let enum_value = i_prot.read_i32()?;
    Ok(TAggregationOp::from(enum_value))
  }
}

impl From<i32> for TAggregationOp {
  fn from(i: i32) -> Self {
    match i {
      0 => TAggregationOp::INVALID,
      1 => TAggregationOp::COUNT,
      2 => TAggregationOp::MAX,
      3 => TAggregationOp::DISTINCT_PC,
      4 => TAggregationOp::DISTINCT_PCSA,
      5 => TAggregationOp::MIN,
      6 => TAggregationOp::SUM,
      7 => TAggregationOp::GROUP_CONCAT,
      8 => TAggregationOp::HLL,
      9 => TAggregationOp::COUNT_DISTINCT,
      10 => TAggregationOp::SUM_DISTINCT,
      11 => TAggregationOp::LEAD,
      12 => TAggregationOp::FIRST_VALUE,
      13 => TAggregationOp::LAST_VALUE,
      14 => TAggregationOp::RANK,
      15 => TAggregationOp::DENSE_RANK,
      16 => TAggregationOp::ROW_NUMBER,
      17 => TAggregationOp::LAG,
      18 => TAggregationOp::HLL_C,
      19 => TAggregationOp::BITMAP_UNION,
      20 => TAggregationOp::NTILE,
      _ => TAggregationOp(i)
    }
  }
}

impl From<&i32> for TAggregationOp {
  fn from(i: &i32) -> Self {
    TAggregationOp::from(*i)
  }
}

impl From<TAggregationOp> for i32 {
  fn from(e: TAggregationOp) -> i32 {
    e.0
  }
}

impl From<&TAggregationOp> for i32 {
  fn from(e: &TAggregationOp) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSortAlgorithm(pub i32);

impl TSortAlgorithm {
  pub const HEAP_SORT: TSortAlgorithm = TSortAlgorithm(0);
  pub const TOPN_SORT: TSortAlgorithm = TSortAlgorithm(1);
  pub const FULL_SORT: TSortAlgorithm = TSortAlgorithm(2);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::HEAP_SORT,
    Self::TOPN_SORT,
    Self::FULL_SORT,
  ];
}

impl TSerializable for TSortAlgorithm {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSortAlgorithm> {
    let enum_value = i_prot.read_i32()?;
    Ok(TSortAlgorithm::from(enum_value))
  }
}

impl From<i32> for TSortAlgorithm {
  fn from(i: i32) -> Self {
    match i {
      0 => TSortAlgorithm::HEAP_SORT,
      1 => TSortAlgorithm::TOPN_SORT,
      2 => TSortAlgorithm::FULL_SORT,
      _ => TSortAlgorithm(i)
    }
  }
}

impl From<&i32> for TSortAlgorithm {
  fn from(i: &i32) -> Self {
    TSortAlgorithm::from(*i)
  }
}

impl From<TSortAlgorithm> for i32 {
  fn from(e: TSortAlgorithm) -> i32 {
    e.0
  }
}

impl From<&TSortAlgorithm> for i32 {
  fn from(e: &TSortAlgorithm) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TopNAlgorithm(pub i32);

impl TopNAlgorithm {
  pub const RANK: TopNAlgorithm = TopNAlgorithm(0);
  pub const DENSE_RANK: TopNAlgorithm = TopNAlgorithm(1);
  pub const ROW_NUMBER: TopNAlgorithm = TopNAlgorithm(2);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::RANK,
    Self::DENSE_RANK,
    Self::ROW_NUMBER,
  ];
}

impl TSerializable for TopNAlgorithm {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TopNAlgorithm> {
    let enum_value = i_prot.read_i32()?;
    Ok(TopNAlgorithm::from(enum_value))
  }
}

impl From<i32> for TopNAlgorithm {
  fn from(i: i32) -> Self {
    match i {
      0 => TopNAlgorithm::RANK,
      1 => TopNAlgorithm::DENSE_RANK,
      2 => TopNAlgorithm::ROW_NUMBER,
      _ => TopNAlgorithm(i)
    }
  }
}

impl From<&i32> for TopNAlgorithm {
  fn from(i: &i32) -> Self {
    TopNAlgorithm::from(*i)
  }
}

impl From<TopNAlgorithm> for i32 {
  fn from(e: TopNAlgorithm) -> i32 {
    e.0
  }
}

impl From<&TopNAlgorithm> for i32 {
  fn from(e: &TopNAlgorithm) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TPartTopNPhase(pub i32);

impl TPartTopNPhase {
  pub const UNKNOWN: TPartTopNPhase = TPartTopNPhase(0);
  pub const ONE_PHASE_GLOBAL: TPartTopNPhase = TPartTopNPhase(1);
  pub const TWO_PHASE_LOCAL: TPartTopNPhase = TPartTopNPhase(2);
  pub const TWO_PHASE_GLOBAL: TPartTopNPhase = TPartTopNPhase(3);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::UNKNOWN,
    Self::ONE_PHASE_GLOBAL,
    Self::TWO_PHASE_LOCAL,
    Self::TWO_PHASE_GLOBAL,
  ];
}

impl TSerializable for TPartTopNPhase {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TPartTopNPhase> {
    let enum_value = i_prot.read_i32()?;
    Ok(TPartTopNPhase::from(enum_value))
  }
}

impl From<i32> for TPartTopNPhase {
  fn from(i: i32) -> Self {
    match i {
      0 => TPartTopNPhase::UNKNOWN,
      1 => TPartTopNPhase::ONE_PHASE_GLOBAL,
      2 => TPartTopNPhase::TWO_PHASE_LOCAL,
      3 => TPartTopNPhase::TWO_PHASE_GLOBAL,
      _ => TPartTopNPhase(i)
    }
  }
}

impl From<&i32> for TPartTopNPhase {
  fn from(i: &i32) -> Self {
    TPartTopNPhase::from(*i)
  }
}

impl From<TPartTopNPhase> for i32 {
  fn from(e: TPartTopNPhase) -> i32 {
    e.0
  }
}

impl From<&TPartTopNPhase> for i32 {
  fn from(e: &TPartTopNPhase) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TAnalyticWindowType(pub i32);

impl TAnalyticWindowType {
  pub const RANGE: TAnalyticWindowType = TAnalyticWindowType(0);
  pub const ROWS: TAnalyticWindowType = TAnalyticWindowType(1);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::RANGE,
    Self::ROWS,
  ];
}

impl TSerializable for TAnalyticWindowType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TAnalyticWindowType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TAnalyticWindowType::from(enum_value))
  }
}

impl From<i32> for TAnalyticWindowType {
  fn from(i: i32) -> Self {
    match i {
      0 => TAnalyticWindowType::RANGE,
      1 => TAnalyticWindowType::ROWS,
      _ => TAnalyticWindowType(i)
    }
  }
}

impl From<&i32> for TAnalyticWindowType {
  fn from(i: &i32) -> Self {
    TAnalyticWindowType::from(*i)
  }
}

impl From<TAnalyticWindowType> for i32 {
  fn from(e: TAnalyticWindowType) -> i32 {
    e.0
  }
}

impl From<&TAnalyticWindowType> for i32 {
  fn from(e: &TAnalyticWindowType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TAnalyticWindowBoundaryType(pub i32);

impl TAnalyticWindowBoundaryType {
  pub const CURRENT_ROW: TAnalyticWindowBoundaryType = TAnalyticWindowBoundaryType(0);
  pub const PRECEDING: TAnalyticWindowBoundaryType = TAnalyticWindowBoundaryType(1);
  pub const FOLLOWING: TAnalyticWindowBoundaryType = TAnalyticWindowBoundaryType(2);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::CURRENT_ROW,
    Self::PRECEDING,
    Self::FOLLOWING,
  ];
}

impl TSerializable for TAnalyticWindowBoundaryType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TAnalyticWindowBoundaryType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TAnalyticWindowBoundaryType::from(enum_value))
  }
}

impl From<i32> for TAnalyticWindowBoundaryType {
  fn from(i: i32) -> Self {
    match i {
      0 => TAnalyticWindowBoundaryType::CURRENT_ROW,
      1 => TAnalyticWindowBoundaryType::PRECEDING,
      2 => TAnalyticWindowBoundaryType::FOLLOWING,
      _ => TAnalyticWindowBoundaryType(i)
    }
  }
}

impl From<&i32> for TAnalyticWindowBoundaryType {
  fn from(i: &i32) -> Self {
    TAnalyticWindowBoundaryType::from(*i)
  }
}

impl From<TAnalyticWindowBoundaryType> for i32 {
  fn from(e: TAnalyticWindowBoundaryType) -> i32 {
    e.0
  }
}

impl From<&TAnalyticWindowBoundaryType> for i32 {
  fn from(e: &TAnalyticWindowBoundaryType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TAssertion(pub i32);

impl TAssertion {
  pub const EQ: TAssertion = TAssertion(0);
  pub const NE: TAssertion = TAssertion(1);
  pub const LT: TAssertion = TAssertion(2);
  pub const LE: TAssertion = TAssertion(3);
  pub const GT: TAssertion = TAssertion(4);
  pub const GE: TAssertion = TAssertion(5);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::EQ,
    Self::NE,
    Self::LT,
    Self::LE,
    Self::GT,
    Self::GE,
  ];
}

impl TSerializable for TAssertion {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TAssertion> {
    let enum_value = i_prot.read_i32()?;
    Ok(TAssertion::from(enum_value))
  }
}

impl From<i32> for TAssertion {
  fn from(i: i32) -> Self {
    match i {
      0 => TAssertion::EQ,
      1 => TAssertion::NE,
      2 => TAssertion::LT,
      3 => TAssertion::LE,
      4 => TAssertion::GT,
      5 => TAssertion::GE,
      _ => TAssertion(i)
    }
  }
}

impl From<&i32> for TAssertion {
  fn from(i: &i32) -> Self {
    TAssertion::from(*i)
  }
}

impl From<TAssertion> for i32 {
  fn from(e: TAssertion) -> i32 {
    e.0
  }
}

impl From<&TAssertion> for i32 {
  fn from(e: &TAssertion) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TRuntimeFilterType(pub i32);

impl TRuntimeFilterType {
  pub const IN: TRuntimeFilterType = TRuntimeFilterType(1);
  pub const BLOOM: TRuntimeFilterType = TRuntimeFilterType(2);
  pub const MIN_MAX: TRuntimeFilterType = TRuntimeFilterType(4);
  pub const IN_OR_BLOOM: TRuntimeFilterType = TRuntimeFilterType(8);
  pub const BITMAP: TRuntimeFilterType = TRuntimeFilterType(16);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::IN,
    Self::BLOOM,
    Self::MIN_MAX,
    Self::IN_OR_BLOOM,
    Self::BITMAP,
  ];
}

impl TSerializable for TRuntimeFilterType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TRuntimeFilterType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TRuntimeFilterType::from(enum_value))
  }
}

impl From<i32> for TRuntimeFilterType {
  fn from(i: i32) -> Self {
    match i {
      1 => TRuntimeFilterType::IN,
      2 => TRuntimeFilterType::BLOOM,
      4 => TRuntimeFilterType::MIN_MAX,
      8 => TRuntimeFilterType::IN_OR_BLOOM,
      16 => TRuntimeFilterType::BITMAP,
      _ => TRuntimeFilterType(i)
    }
  }
}

impl From<&i32> for TRuntimeFilterType {
  fn from(i: &i32) -> Self {
    TRuntimeFilterType::from(*i)
  }
}

impl From<TRuntimeFilterType> for i32 {
  fn from(e: TRuntimeFilterType) -> i32 {
    e.0
  }
}

impl From<&TRuntimeFilterType> for i32 {
  fn from(e: &TRuntimeFilterType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TMinMaxRuntimeFilterType(pub i32);

impl TMinMaxRuntimeFilterType {
  pub const MIN: TMinMaxRuntimeFilterType = TMinMaxRuntimeFilterType(1);
  pub const MAX: TMinMaxRuntimeFilterType = TMinMaxRuntimeFilterType(2);
  pub const MIN_MAX: TMinMaxRuntimeFilterType = TMinMaxRuntimeFilterType(4);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::MIN,
    Self::MAX,
    Self::MIN_MAX,
  ];
}

impl TSerializable for TMinMaxRuntimeFilterType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TMinMaxRuntimeFilterType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TMinMaxRuntimeFilterType::from(enum_value))
  }
}

impl From<i32> for TMinMaxRuntimeFilterType {
  fn from(i: i32) -> Self {
    match i {
      1 => TMinMaxRuntimeFilterType::MIN,
      2 => TMinMaxRuntimeFilterType::MAX,
      4 => TMinMaxRuntimeFilterType::MIN_MAX,
      _ => TMinMaxRuntimeFilterType(i)
    }
  }
}

impl From<&i32> for TMinMaxRuntimeFilterType {
  fn from(i: &i32) -> Self {
    TMinMaxRuntimeFilterType::from(*i)
  }
}

impl From<TMinMaxRuntimeFilterType> for i32 {
  fn from(e: TMinMaxRuntimeFilterType) -> i32 {
    e.0
  }
}

impl From<&TMinMaxRuntimeFilterType> for i32 {
  fn from(e: &TMinMaxRuntimeFilterType) -> i32 {
    e.0
  }
}

//
// TKeyRange
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TKeyRange {
  pub begin_key: i64,
  pub end_key: i64,
  pub column_type: types::TPrimitiveType,
  pub column_name: String,
}

impl TKeyRange {
  pub fn new(begin_key: i64, end_key: i64, column_type: types::TPrimitiveType, column_name: String) -> TKeyRange {
    TKeyRange {
      begin_key,
      end_key,
      column_type,
      column_name,
    }
  }
}

impl TSerializable for TKeyRange {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TKeyRange> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<types::TPrimitiveType> = None;
    let mut f_4: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = types::TPrimitiveType::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TKeyRange.begin_key", &f_1)?;
    verify_required_field_exists("TKeyRange.end_key", &f_2)?;
    verify_required_field_exists("TKeyRange.column_type", &f_3)?;
    verify_required_field_exists("TKeyRange.column_name", &f_4)?;
    let ret = TKeyRange {
      begin_key: f_1.expect("auto-generated code should have checked for presence of required fields"),
      end_key: f_2.expect("auto-generated code should have checked for presence of required fields"),
      column_type: f_3.expect("auto-generated code should have checked for presence of required fields"),
      column_name: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TKeyRange");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("begin_key", TType::I64, 1))?;
    o_prot.write_i64(self.begin_key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("end_key", TType::I64, 2))?;
    o_prot.write_i64(self.end_key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("column_type", TType::I32, 3))?;
    self.column_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("column_name", TType::String, 4))?;
    o_prot.write_string(&self.column_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TPaloScanRange
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TPaloScanRange {
  pub hosts: Vec<types::TNetworkAddress>,
  pub schema_hash: String,
  pub version: String,
  pub version_hash: String,
  pub tablet_id: types::TTabletId,
  pub db_name: String,
  pub partition_column_ranges: Option<Vec<TKeyRange>>,
  pub index_name: Option<String>,
  pub table_name: Option<String>,
}

impl TPaloScanRange {
  pub fn new<F7, F8, F9>(hosts: Vec<types::TNetworkAddress>, schema_hash: String, version: String, version_hash: String, tablet_id: types::TTabletId, db_name: String, partition_column_ranges: F7, index_name: F8, table_name: F9) -> TPaloScanRange where F7: Into<Option<Vec<TKeyRange>>>, F8: Into<Option<String>>, F9: Into<Option<String>> {
    TPaloScanRange {
      hosts,
      schema_hash,
      version,
      version_hash,
      tablet_id,
      db_name,
      partition_column_ranges: partition_column_ranges.into(),
      index_name: index_name.into(),
      table_name: table_name.into(),
    }
  }
}

impl TSerializable for TPaloScanRange {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TPaloScanRange> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<types::TNetworkAddress>> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<types::TTabletId> = None;
    let mut f_6: Option<String> = None;
    let mut f_7: Option<Vec<TKeyRange>> = None;
    let mut f_8: Option<String> = None;
    let mut f_9: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::TNetworkAddress> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_0 = types::TNetworkAddress::read_from_in_protocol(i_prot)?;
            val.push(list_elem_0);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TKeyRange> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_1 = TKeyRange::read_from_in_protocol(i_prot)?;
            val.push(list_elem_1);
          }
          i_prot.read_list_end()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_string()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_string()?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TPaloScanRange.hosts", &f_1)?;
    verify_required_field_exists("TPaloScanRange.schema_hash", &f_2)?;
    verify_required_field_exists("TPaloScanRange.version", &f_3)?;
    verify_required_field_exists("TPaloScanRange.version_hash", &f_4)?;
    verify_required_field_exists("TPaloScanRange.tablet_id", &f_5)?;
    verify_required_field_exists("TPaloScanRange.db_name", &f_6)?;
    let ret = TPaloScanRange {
      hosts: f_1.expect("auto-generated code should have checked for presence of required fields"),
      schema_hash: f_2.expect("auto-generated code should have checked for presence of required fields"),
      version: f_3.expect("auto-generated code should have checked for presence of required fields"),
      version_hash: f_4.expect("auto-generated code should have checked for presence of required fields"),
      tablet_id: f_5.expect("auto-generated code should have checked for presence of required fields"),
      db_name: f_6.expect("auto-generated code should have checked for presence of required fields"),
      partition_column_ranges: f_7,
      index_name: f_8,
      table_name: f_9,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TPaloScanRange");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("hosts", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.hosts.len() as i32))?;
    for e in &self.hosts {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("schema_hash", TType::String, 2))?;
    o_prot.write_string(&self.schema_hash)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("version", TType::String, 3))?;
    o_prot.write_string(&self.version)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("version_hash", TType::String, 4))?;
    o_prot.write_string(&self.version_hash)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tablet_id", TType::I64, 5))?;
    o_prot.write_i64(self.tablet_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 6))?;
    o_prot.write_string(&self.db_name)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.partition_column_ranges {
      o_prot.write_field_begin(&TFieldIdentifier::new("partition_column_ranges", TType::List, 7))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.index_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("index_name", TType::String, 8))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.table_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 9))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// THdfsConf
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct THdfsConf {
  pub key: String,
  pub value: String,
}

impl THdfsConf {
  pub fn new(key: String, value: String) -> THdfsConf {
    THdfsConf {
      key,
      value,
    }
  }
}

impl TSerializable for THdfsConf {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<THdfsConf> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("THdfsConf.key", &f_1)?;
    verify_required_field_exists("THdfsConf.value", &f_2)?;
    let ret = THdfsConf {
      key: f_1.expect("auto-generated code should have checked for presence of required fields"),
      value: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("THdfsConf");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("key", TType::String, 1))?;
    o_prot.write_string(&self.key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 2))?;
    o_prot.write_string(&self.value)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// THdfsParams
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct THdfsParams {
  pub fs_name: Option<String>,
  pub user: Option<String>,
  pub hdfs_kerberos_principal: Option<String>,
  pub hdfs_kerberos_keytab: Option<String>,
  pub hdfs_conf: Option<Vec<THdfsConf>>,
  pub root_path: Option<String>,
}

impl THdfsParams {
  pub fn new<F1, F2, F3, F4, F5, F6>(fs_name: F1, user: F2, hdfs_kerberos_principal: F3, hdfs_kerberos_keytab: F4, hdfs_conf: F5, root_path: F6) -> THdfsParams where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<Vec<THdfsConf>>>, F6: Into<Option<String>> {
    THdfsParams {
      fs_name: fs_name.into(),
      user: user.into(),
      hdfs_kerberos_principal: hdfs_kerberos_principal.into(),
      hdfs_kerberos_keytab: hdfs_kerberos_keytab.into(),
      hdfs_conf: hdfs_conf.into(),
      root_path: root_path.into(),
    }
  }
}

impl TSerializable for THdfsParams {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<THdfsParams> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<Vec<THdfsConf>> = None;
    let mut f_6: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<THdfsConf> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_2 = THdfsConf::read_from_in_protocol(i_prot)?;
            val.push(list_elem_2);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = THdfsParams {
      fs_name: f_1,
      user: f_2,
      hdfs_kerberos_principal: f_3,
      hdfs_kerberos_keytab: f_4,
      hdfs_conf: f_5,
      root_path: f_6,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("THdfsParams");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.fs_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("fs_name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user {
      o_prot.write_field_begin(&TFieldIdentifier::new("user", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.hdfs_kerberos_principal {
      o_prot.write_field_begin(&TFieldIdentifier::new("hdfs_kerberos_principal", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.hdfs_kerberos_keytab {
      o_prot.write_field_begin(&TFieldIdentifier::new("hdfs_kerberos_keytab", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.hdfs_conf {
      o_prot.write_field_begin(&TFieldIdentifier::new("hdfs_conf", TType::List, 5))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.root_path {
      o_prot.write_field_begin(&TFieldIdentifier::new("root_path", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TBrokerRangeDesc
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TBrokerRangeDesc {
  pub file_type: types::TFileType,
  pub format_type: TFileFormatType,
  pub splittable: bool,
  pub path: String,
  pub start_offset: i64,
  pub size: i64,
  pub load_id: Option<types::TUniqueId>,
  pub file_size: Option<i64>,
  pub num_of_columns_from_file: Option<i32>,
  pub columns_from_path: Option<Vec<String>>,
  pub strip_outer_array: Option<bool>,
  pub jsonpaths: Option<String>,
  pub json_root: Option<String>,
  pub num_as_string: Option<bool>,
  pub fuzzy_parse: Option<bool>,
  pub hdfs_params: Option<THdfsParams>,
  pub read_json_by_line: Option<bool>,
  pub read_by_column_def: Option<bool>,
  pub header_type: Option<String>,
  pub skip_lines: Option<i32>,
}

impl TBrokerRangeDesc {
  pub fn new<F7, F8, F9, F10, F11, F12, F13, F14, F15, F16, F17, F18, F19, F20>(file_type: types::TFileType, format_type: TFileFormatType, splittable: bool, path: String, start_offset: i64, size: i64, load_id: F7, file_size: F8, num_of_columns_from_file: F9, columns_from_path: F10, strip_outer_array: F11, jsonpaths: F12, json_root: F13, num_as_string: F14, fuzzy_parse: F15, hdfs_params: F16, read_json_by_line: F17, read_by_column_def: F18, header_type: F19, skip_lines: F20) -> TBrokerRangeDesc where F7: Into<Option<types::TUniqueId>>, F8: Into<Option<i64>>, F9: Into<Option<i32>>, F10: Into<Option<Vec<String>>>, F11: Into<Option<bool>>, F12: Into<Option<String>>, F13: Into<Option<String>>, F14: Into<Option<bool>>, F15: Into<Option<bool>>, F16: Into<Option<THdfsParams>>, F17: Into<Option<bool>>, F18: Into<Option<bool>>, F19: Into<Option<String>>, F20: Into<Option<i32>> {
    TBrokerRangeDesc {
      file_type,
      format_type,
      splittable,
      path,
      start_offset,
      size,
      load_id: load_id.into(),
      file_size: file_size.into(),
      num_of_columns_from_file: num_of_columns_from_file.into(),
      columns_from_path: columns_from_path.into(),
      strip_outer_array: strip_outer_array.into(),
      jsonpaths: jsonpaths.into(),
      json_root: json_root.into(),
      num_as_string: num_as_string.into(),
      fuzzy_parse: fuzzy_parse.into(),
      hdfs_params: hdfs_params.into(),
      read_json_by_line: read_json_by_line.into(),
      read_by_column_def: read_by_column_def.into(),
      header_type: header_type.into(),
      skip_lines: skip_lines.into(),
    }
  }
}

impl TSerializable for TBrokerRangeDesc {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TBrokerRangeDesc> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<types::TFileType> = None;
    let mut f_2: Option<TFileFormatType> = None;
    let mut f_3: Option<bool> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<i64> = None;
    let mut f_6: Option<i64> = None;
    let mut f_7: Option<types::TUniqueId> = None;
    let mut f_8: Option<i64> = None;
    let mut f_9: Option<i32> = None;
    let mut f_10: Option<Vec<String>> = None;
    let mut f_11: Option<bool> = None;
    let mut f_12: Option<String> = None;
    let mut f_13: Option<String> = None;
    let mut f_14: Option<bool> = None;
    let mut f_15: Option<bool> = None;
    let mut f_16: Option<THdfsParams> = None;
    let mut f_17: Option<bool> = None;
    let mut f_18: Option<bool> = None;
    let mut f_19: Option<String> = None;
    let mut f_20: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = types::TFileType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = TFileFormatType::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i64()?;
          f_6 = Some(val);
        },
        7 => {
          let val = types::TUniqueId::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i64()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_i32()?;
          f_9 = Some(val);
        },
        10 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_3 = i_prot.read_string()?;
            val.push(list_elem_3);
          }
          i_prot.read_list_end()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_bool()?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_string()?;
          f_12 = Some(val);
        },
        13 => {
          let val = i_prot.read_string()?;
          f_13 = Some(val);
        },
        14 => {
          let val = i_prot.read_bool()?;
          f_14 = Some(val);
        },
        15 => {
          let val = i_prot.read_bool()?;
          f_15 = Some(val);
        },
        16 => {
          let val = THdfsParams::read_from_in_protocol(i_prot)?;
          f_16 = Some(val);
        },
        17 => {
          let val = i_prot.read_bool()?;
          f_17 = Some(val);
        },
        18 => {
          let val = i_prot.read_bool()?;
          f_18 = Some(val);
        },
        19 => {
          let val = i_prot.read_string()?;
          f_19 = Some(val);
        },
        20 => {
          let val = i_prot.read_i32()?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TBrokerRangeDesc.file_type", &f_1)?;
    verify_required_field_exists("TBrokerRangeDesc.format_type", &f_2)?;
    verify_required_field_exists("TBrokerRangeDesc.splittable", &f_3)?;
    verify_required_field_exists("TBrokerRangeDesc.path", &f_4)?;
    verify_required_field_exists("TBrokerRangeDesc.start_offset", &f_5)?;
    verify_required_field_exists("TBrokerRangeDesc.size", &f_6)?;
    let ret = TBrokerRangeDesc {
      file_type: f_1.expect("auto-generated code should have checked for presence of required fields"),
      format_type: f_2.expect("auto-generated code should have checked for presence of required fields"),
      splittable: f_3.expect("auto-generated code should have checked for presence of required fields"),
      path: f_4.expect("auto-generated code should have checked for presence of required fields"),
      start_offset: f_5.expect("auto-generated code should have checked for presence of required fields"),
      size: f_6.expect("auto-generated code should have checked for presence of required fields"),
      load_id: f_7,
      file_size: f_8,
      num_of_columns_from_file: f_9,
      columns_from_path: f_10,
      strip_outer_array: f_11,
      jsonpaths: f_12,
      json_root: f_13,
      num_as_string: f_14,
      fuzzy_parse: f_15,
      hdfs_params: f_16,
      read_json_by_line: f_17,
      read_by_column_def: f_18,
      header_type: f_19,
      skip_lines: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TBrokerRangeDesc");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("file_type", TType::I32, 1))?;
    self.file_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("format_type", TType::I32, 2))?;
    self.format_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("splittable", TType::Bool, 3))?;
    o_prot.write_bool(self.splittable)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("path", TType::String, 4))?;
    o_prot.write_string(&self.path)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("start_offset", TType::I64, 5))?;
    o_prot.write_i64(self.start_offset)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("size", TType::I64, 6))?;
    o_prot.write_i64(self.size)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.load_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("load_id", TType::Struct, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.file_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("file_size", TType::I64, 8))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.num_of_columns_from_file {
      o_prot.write_field_begin(&TFieldIdentifier::new("num_of_columns_from_file", TType::I32, 9))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.columns_from_path {
      o_prot.write_field_begin(&TFieldIdentifier::new("columns_from_path", TType::List, 10))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.strip_outer_array {
      o_prot.write_field_begin(&TFieldIdentifier::new("strip_outer_array", TType::Bool, 11))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.jsonpaths {
      o_prot.write_field_begin(&TFieldIdentifier::new("jsonpaths", TType::String, 12))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.json_root {
      o_prot.write_field_begin(&TFieldIdentifier::new("json_root", TType::String, 13))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.num_as_string {
      o_prot.write_field_begin(&TFieldIdentifier::new("num_as_string", TType::Bool, 14))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.fuzzy_parse {
      o_prot.write_field_begin(&TFieldIdentifier::new("fuzzy_parse", TType::Bool, 15))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.hdfs_params {
      o_prot.write_field_begin(&TFieldIdentifier::new("hdfs_params", TType::Struct, 16))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.read_json_by_line {
      o_prot.write_field_begin(&TFieldIdentifier::new("read_json_by_line", TType::Bool, 17))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.read_by_column_def {
      o_prot.write_field_begin(&TFieldIdentifier::new("read_by_column_def", TType::Bool, 18))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.header_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("header_type", TType::String, 19))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.skip_lines {
      o_prot.write_field_begin(&TFieldIdentifier::new("skip_lines", TType::I32, 20))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TBrokerScanRangeParams
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TBrokerScanRangeParams {
  pub column_separator: i8,
  pub line_delimiter: i8,
  pub src_tuple_id: types::TTupleId,
  pub src_slot_ids: Vec<types::TSlotId>,
  pub dest_tuple_id: types::TTupleId,
  pub expr_of_dest_slot: Option<BTreeMap<types::TSlotId, exprs::TExpr>>,
  pub properties: Option<BTreeMap<String, String>>,
  pub partition_ids: Option<Vec<i64>>,
  pub dest_sid_to_src_sid_without_trans: Option<BTreeMap<types::TSlotId, types::TSlotId>>,
  pub strict_mode: Option<bool>,
  pub column_separator_length: Option<i32>,
  pub line_delimiter_length: Option<i32>,
  pub column_separator_str: Option<String>,
  pub line_delimiter_str: Option<String>,
  pub trim_double_quotes: Option<bool>,
}

impl TBrokerScanRangeParams {
  pub fn new<F6, F7, F8, F9, F10, F11, F12, F13, F14, F15>(column_separator: i8, line_delimiter: i8, src_tuple_id: types::TTupleId, src_slot_ids: Vec<types::TSlotId>, dest_tuple_id: types::TTupleId, expr_of_dest_slot: F6, properties: F7, partition_ids: F8, dest_sid_to_src_sid_without_trans: F9, strict_mode: F10, column_separator_length: F11, line_delimiter_length: F12, column_separator_str: F13, line_delimiter_str: F14, trim_double_quotes: F15) -> TBrokerScanRangeParams where F6: Into<Option<BTreeMap<types::TSlotId, exprs::TExpr>>>, F7: Into<Option<BTreeMap<String, String>>>, F8: Into<Option<Vec<i64>>>, F9: Into<Option<BTreeMap<types::TSlotId, types::TSlotId>>>, F10: Into<Option<bool>>, F11: Into<Option<i32>>, F12: Into<Option<i32>>, F13: Into<Option<String>>, F14: Into<Option<String>>, F15: Into<Option<bool>> {
    TBrokerScanRangeParams {
      column_separator,
      line_delimiter,
      src_tuple_id,
      src_slot_ids,
      dest_tuple_id,
      expr_of_dest_slot: expr_of_dest_slot.into(),
      properties: properties.into(),
      partition_ids: partition_ids.into(),
      dest_sid_to_src_sid_without_trans: dest_sid_to_src_sid_without_trans.into(),
      strict_mode: strict_mode.into(),
      column_separator_length: column_separator_length.into(),
      line_delimiter_length: line_delimiter_length.into(),
      column_separator_str: column_separator_str.into(),
      line_delimiter_str: line_delimiter_str.into(),
      trim_double_quotes: trim_double_quotes.into(),
    }
  }
}

impl TSerializable for TBrokerScanRangeParams {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TBrokerScanRangeParams> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i8> = None;
    let mut f_2: Option<i8> = None;
    let mut f_3: Option<types::TTupleId> = None;
    let mut f_4: Option<Vec<types::TSlotId>> = None;
    let mut f_5: Option<types::TTupleId> = None;
    let mut f_6: Option<BTreeMap<types::TSlotId, exprs::TExpr>> = None;
    let mut f_7: Option<BTreeMap<String, String>> = None;
    let mut f_8: Option<Vec<i64>> = None;
    let mut f_9: Option<BTreeMap<types::TSlotId, types::TSlotId>> = None;
    let mut f_10: Option<bool> = None;
    let mut f_11: Option<i32> = None;
    let mut f_12: Option<i32> = None;
    let mut f_13: Option<String> = None;
    let mut f_14: Option<String> = None;
    let mut f_15: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i8()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i8()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::TSlotId> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_4 = i_prot.read_i32()?;
            val.push(list_elem_4);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<types::TSlotId, exprs::TExpr> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_5 = i_prot.read_i32()?;
            let map_val_6 = exprs::TExpr::read_from_in_protocol(i_prot)?;
            val.insert(map_key_5, map_val_6);
          }
          i_prot.read_map_end()?;
          f_6 = Some(val);
        },
        7 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_7 = i_prot.read_string()?;
            let map_val_8 = i_prot.read_string()?;
            val.insert(map_key_7, map_val_8);
          }
          i_prot.read_map_end()?;
          f_7 = Some(val);
        },
        8 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i64> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_9 = i_prot.read_i64()?;
            val.push(list_elem_9);
          }
          i_prot.read_list_end()?;
          f_8 = Some(val);
        },
        9 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<types::TSlotId, types::TSlotId> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_10 = i_prot.read_i32()?;
            let map_val_11 = i_prot.read_i32()?;
            val.insert(map_key_10, map_val_11);
          }
          i_prot.read_map_end()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_bool()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_i32()?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_i32()?;
          f_12 = Some(val);
        },
        13 => {
          let val = i_prot.read_string()?;
          f_13 = Some(val);
        },
        14 => {
          let val = i_prot.read_string()?;
          f_14 = Some(val);
        },
        15 => {
          let val = i_prot.read_bool()?;
          f_15 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TBrokerScanRangeParams.column_separator", &f_1)?;
    verify_required_field_exists("TBrokerScanRangeParams.line_delimiter", &f_2)?;
    verify_required_field_exists("TBrokerScanRangeParams.src_tuple_id", &f_3)?;
    verify_required_field_exists("TBrokerScanRangeParams.src_slot_ids", &f_4)?;
    verify_required_field_exists("TBrokerScanRangeParams.dest_tuple_id", &f_5)?;
    let ret = TBrokerScanRangeParams {
      column_separator: f_1.expect("auto-generated code should have checked for presence of required fields"),
      line_delimiter: f_2.expect("auto-generated code should have checked for presence of required fields"),
      src_tuple_id: f_3.expect("auto-generated code should have checked for presence of required fields"),
      src_slot_ids: f_4.expect("auto-generated code should have checked for presence of required fields"),
      dest_tuple_id: f_5.expect("auto-generated code should have checked for presence of required fields"),
      expr_of_dest_slot: f_6,
      properties: f_7,
      partition_ids: f_8,
      dest_sid_to_src_sid_without_trans: f_9,
      strict_mode: f_10,
      column_separator_length: f_11,
      line_delimiter_length: f_12,
      column_separator_str: f_13,
      line_delimiter_str: f_14,
      trim_double_quotes: f_15,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TBrokerScanRangeParams");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("column_separator", TType::I08, 1))?;
    o_prot.write_i8(self.column_separator)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("line_delimiter", TType::I08, 2))?;
    o_prot.write_i8(self.line_delimiter)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("src_tuple_id", TType::I32, 3))?;
    o_prot.write_i32(self.src_tuple_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("src_slot_ids", TType::List, 4))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I32, self.src_slot_ids.len() as i32))?;
    for e in &self.src_slot_ids {
      o_prot.write_i32(*e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dest_tuple_id", TType::I32, 5))?;
    o_prot.write_i32(self.dest_tuple_id)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.expr_of_dest_slot {
      o_prot.write_field_begin(&TFieldIdentifier::new("expr_of_dest_slot", TType::Map, 6))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::I32, TType::Struct, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_i32(*k)?;
        v.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.properties {
      o_prot.write_field_begin(&TFieldIdentifier::new("properties", TType::Map, 7))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.partition_ids {
      o_prot.write_field_begin(&TFieldIdentifier::new("partition_ids", TType::List, 8))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I64, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i64(*e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.dest_sid_to_src_sid_without_trans {
      o_prot.write_field_begin(&TFieldIdentifier::new("dest_sid_to_src_sid_without_trans", TType::Map, 9))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::I32, TType::I32, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_i32(*k)?;
        o_prot.write_i32(*v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.strict_mode {
      o_prot.write_field_begin(&TFieldIdentifier::new("strict_mode", TType::Bool, 10))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.column_separator_length {
      o_prot.write_field_begin(&TFieldIdentifier::new("column_separator_length", TType::I32, 11))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.line_delimiter_length {
      o_prot.write_field_begin(&TFieldIdentifier::new("line_delimiter_length", TType::I32, 12))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.column_separator_str {
      o_prot.write_field_begin(&TFieldIdentifier::new("column_separator_str", TType::String, 13))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.line_delimiter_str {
      o_prot.write_field_begin(&TFieldIdentifier::new("line_delimiter_str", TType::String, 14))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.trim_double_quotes {
      o_prot.write_field_begin(&TFieldIdentifier::new("trim_double_quotes", TType::Bool, 15))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TBrokerScanRange
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TBrokerScanRange {
  pub ranges: Vec<TBrokerRangeDesc>,
  pub params: TBrokerScanRangeParams,
  pub broker_addresses: Vec<types::TNetworkAddress>,
}

impl TBrokerScanRange {
  pub fn new(ranges: Vec<TBrokerRangeDesc>, params: TBrokerScanRangeParams, broker_addresses: Vec<types::TNetworkAddress>) -> TBrokerScanRange {
    TBrokerScanRange {
      ranges,
      params,
      broker_addresses,
    }
  }
}

impl TSerializable for TBrokerScanRange {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TBrokerScanRange> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<TBrokerRangeDesc>> = None;
    let mut f_2: Option<TBrokerScanRangeParams> = None;
    let mut f_3: Option<Vec<types::TNetworkAddress>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TBrokerRangeDesc> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_12 = TBrokerRangeDesc::read_from_in_protocol(i_prot)?;
            val.push(list_elem_12);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = TBrokerScanRangeParams::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::TNetworkAddress> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_13 = types::TNetworkAddress::read_from_in_protocol(i_prot)?;
            val.push(list_elem_13);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TBrokerScanRange.ranges", &f_1)?;
    verify_required_field_exists("TBrokerScanRange.params", &f_2)?;
    verify_required_field_exists("TBrokerScanRange.broker_addresses", &f_3)?;
    let ret = TBrokerScanRange {
      ranges: f_1.expect("auto-generated code should have checked for presence of required fields"),
      params: f_2.expect("auto-generated code should have checked for presence of required fields"),
      broker_addresses: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TBrokerScanRange");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("ranges", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.ranges.len() as i32))?;
    for e in &self.ranges {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("params", TType::Struct, 2))?;
    self.params.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("broker_addresses", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.broker_addresses.len() as i32))?;
    for e in &self.broker_addresses {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TEsScanRange
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TEsScanRange {
  pub es_hosts: Vec<types::TNetworkAddress>,
  pub index: String,
  pub type_: Option<String>,
  pub shard_id: i32,
}

impl TEsScanRange {
  pub fn new<F3>(es_hosts: Vec<types::TNetworkAddress>, index: String, type_: F3, shard_id: i32) -> TEsScanRange where F3: Into<Option<String>> {
    TEsScanRange {
      es_hosts,
      index,
      type_: type_.into(),
      shard_id,
    }
  }
}

impl TSerializable for TEsScanRange {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TEsScanRange> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<types::TNetworkAddress>> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::TNetworkAddress> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_14 = types::TNetworkAddress::read_from_in_protocol(i_prot)?;
            val.push(list_elem_14);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TEsScanRange.es_hosts", &f_1)?;
    verify_required_field_exists("TEsScanRange.index", &f_2)?;
    verify_required_field_exists("TEsScanRange.shard_id", &f_4)?;
    let ret = TEsScanRange {
      es_hosts: f_1.expect("auto-generated code should have checked for presence of required fields"),
      index: f_2.expect("auto-generated code should have checked for presence of required fields"),
      type_: f_3,
      shard_id: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TEsScanRange");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("es_hosts", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.es_hosts.len() as i32))?;
    for e in &self.es_hosts {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("index", TType::String, 2))?;
    o_prot.write_string(&self.index)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.type_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_begin(&TFieldIdentifier::new("shard_id", TType::I32, 4))?;
    o_prot.write_i32(self.shard_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TFileTextScanRangeParams
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TFileTextScanRangeParams {
  pub column_separator: Option<String>,
  pub line_delimiter: Option<String>,
  pub collection_delimiter: Option<String>,
  pub mapkv_delimiter: Option<String>,
  pub enclose: Option<i8>,
  pub escape: Option<i8>,
  pub null_format: Option<String>,
  pub empty_field_as_null: Option<bool>,
}

impl TFileTextScanRangeParams {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8>(column_separator: F1, line_delimiter: F2, collection_delimiter: F3, mapkv_delimiter: F4, enclose: F5, escape: F6, null_format: F7, empty_field_as_null: F8) -> TFileTextScanRangeParams where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<i8>>, F6: Into<Option<i8>>, F7: Into<Option<String>>, F8: Into<Option<bool>> {
    TFileTextScanRangeParams {
      column_separator: column_separator.into(),
      line_delimiter: line_delimiter.into(),
      collection_delimiter: collection_delimiter.into(),
      mapkv_delimiter: mapkv_delimiter.into(),
      enclose: enclose.into(),
      escape: escape.into(),
      null_format: null_format.into(),
      empty_field_as_null: empty_field_as_null.into(),
    }
  }
}

impl TSerializable for TFileTextScanRangeParams {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TFileTextScanRangeParams> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<i8> = None;
    let mut f_6: Option<i8> = None;
    let mut f_7: Option<String> = None;
    let mut f_8: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i8()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i8()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_bool()?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TFileTextScanRangeParams {
      column_separator: f_1,
      line_delimiter: f_2,
      collection_delimiter: f_3,
      mapkv_delimiter: f_4,
      enclose: f_5,
      escape: f_6,
      null_format: f_7,
      empty_field_as_null: f_8,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TFileTextScanRangeParams");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.column_separator {
      o_prot.write_field_begin(&TFieldIdentifier::new("column_separator", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.line_delimiter {
      o_prot.write_field_begin(&TFieldIdentifier::new("line_delimiter", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.collection_delimiter {
      o_prot.write_field_begin(&TFieldIdentifier::new("collection_delimiter", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.mapkv_delimiter {
      o_prot.write_field_begin(&TFieldIdentifier::new("mapkv_delimiter", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enclose {
      o_prot.write_field_begin(&TFieldIdentifier::new("enclose", TType::I08, 5))?;
      o_prot.write_i8(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.escape {
      o_prot.write_field_begin(&TFieldIdentifier::new("escape", TType::I08, 6))?;
      o_prot.write_i8(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.null_format {
      o_prot.write_field_begin(&TFieldIdentifier::new("null_format", TType::String, 7))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.empty_field_as_null {
      o_prot.write_field_begin(&TFieldIdentifier::new("empty_field_as_null", TType::Bool, 8))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TFileScanSlotInfo
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TFileScanSlotInfo {
  pub slot_id: Option<types::TSlotId>,
  pub is_file_slot: Option<bool>,
}

impl TFileScanSlotInfo {
  pub fn new<F1, F2>(slot_id: F1, is_file_slot: F2) -> TFileScanSlotInfo where F1: Into<Option<types::TSlotId>>, F2: Into<Option<bool>> {
    TFileScanSlotInfo {
      slot_id: slot_id.into(),
      is_file_slot: is_file_slot.into(),
    }
  }
}

impl TSerializable for TFileScanSlotInfo {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TFileScanSlotInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<types::TSlotId> = None;
    let mut f_2: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TFileScanSlotInfo {
      slot_id: f_1,
      is_file_slot: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TFileScanSlotInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.slot_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("slot_id", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_file_slot {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_file_slot", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TFileAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TFileAttributes {
  pub text_params: Option<TFileTextScanRangeParams>,
  pub strip_outer_array: Option<bool>,
  pub jsonpaths: Option<String>,
  pub json_root: Option<String>,
  pub num_as_string: Option<bool>,
  pub fuzzy_parse: Option<bool>,
  pub read_json_by_line: Option<bool>,
  pub read_by_column_def: Option<bool>,
  pub header_type: Option<String>,
  pub trim_double_quotes: Option<bool>,
  pub skip_lines: Option<i32>,
  pub enable_text_validate_utf8: Option<bool>,
  pub openx_json_ignore_malformed: Option<bool>,
  pub ignore_csv_redundant_col: Option<bool>,
}

impl TFileAttributes {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F1001>(text_params: F1, strip_outer_array: F2, jsonpaths: F3, json_root: F4, num_as_string: F5, fuzzy_parse: F6, read_json_by_line: F7, read_by_column_def: F8, header_type: F9, trim_double_quotes: F10, skip_lines: F11, enable_text_validate_utf8: F12, openx_json_ignore_malformed: F13, ignore_csv_redundant_col: F1001) -> TFileAttributes where F1: Into<Option<TFileTextScanRangeParams>>, F2: Into<Option<bool>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<bool>>, F6: Into<Option<bool>>, F7: Into<Option<bool>>, F8: Into<Option<bool>>, F9: Into<Option<String>>, F10: Into<Option<bool>>, F11: Into<Option<i32>>, F12: Into<Option<bool>>, F13: Into<Option<bool>>, F1001: Into<Option<bool>> {
    TFileAttributes {
      text_params: text_params.into(),
      strip_outer_array: strip_outer_array.into(),
      jsonpaths: jsonpaths.into(),
      json_root: json_root.into(),
      num_as_string: num_as_string.into(),
      fuzzy_parse: fuzzy_parse.into(),
      read_json_by_line: read_json_by_line.into(),
      read_by_column_def: read_by_column_def.into(),
      header_type: header_type.into(),
      trim_double_quotes: trim_double_quotes.into(),
      skip_lines: skip_lines.into(),
      enable_text_validate_utf8: enable_text_validate_utf8.into(),
      openx_json_ignore_malformed: openx_json_ignore_malformed.into(),
      ignore_csv_redundant_col: ignore_csv_redundant_col.into(),
    }
  }
}

impl TSerializable for TFileAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TFileAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TFileTextScanRangeParams> = None;
    let mut f_2: Option<bool> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<bool> = None;
    let mut f_6: Option<bool> = None;
    let mut f_7: Option<bool> = None;
    let mut f_8: Option<bool> = None;
    let mut f_9: Option<String> = None;
    let mut f_10: Option<bool> = None;
    let mut f_11: Option<i32> = None;
    let mut f_12: Option<bool> = None;
    let mut f_13: Option<bool> = None;
    let mut f_1001: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TFileTextScanRangeParams::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bool()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_bool()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_string()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_bool()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_i32()?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_bool()?;
          f_12 = Some(val);
        },
        13 => {
          let val = i_prot.read_bool()?;
          f_13 = Some(val);
        },
        1001 => {
          let val = i_prot.read_bool()?;
          f_1001 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TFileAttributes {
      text_params: f_1,
      strip_outer_array: f_2,
      jsonpaths: f_3,
      json_root: f_4,
      num_as_string: f_5,
      fuzzy_parse: f_6,
      read_json_by_line: f_7,
      read_by_column_def: f_8,
      header_type: f_9,
      trim_double_quotes: f_10,
      skip_lines: f_11,
      enable_text_validate_utf8: f_12,
      openx_json_ignore_malformed: f_13,
      ignore_csv_redundant_col: f_1001,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TFileAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.text_params {
      o_prot.write_field_begin(&TFieldIdentifier::new("text_params", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.strip_outer_array {
      o_prot.write_field_begin(&TFieldIdentifier::new("strip_outer_array", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.jsonpaths {
      o_prot.write_field_begin(&TFieldIdentifier::new("jsonpaths", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.json_root {
      o_prot.write_field_begin(&TFieldIdentifier::new("json_root", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.num_as_string {
      o_prot.write_field_begin(&TFieldIdentifier::new("num_as_string", TType::Bool, 5))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.fuzzy_parse {
      o_prot.write_field_begin(&TFieldIdentifier::new("fuzzy_parse", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.read_json_by_line {
      o_prot.write_field_begin(&TFieldIdentifier::new("read_json_by_line", TType::Bool, 7))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.read_by_column_def {
      o_prot.write_field_begin(&TFieldIdentifier::new("read_by_column_def", TType::Bool, 8))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.header_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("header_type", TType::String, 9))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.trim_double_quotes {
      o_prot.write_field_begin(&TFieldIdentifier::new("trim_double_quotes", TType::Bool, 10))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.skip_lines {
      o_prot.write_field_begin(&TFieldIdentifier::new("skip_lines", TType::I32, 11))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_text_validate_utf8 {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_text_validate_utf8", TType::Bool, 12))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.openx_json_ignore_malformed {
      o_prot.write_field_begin(&TFieldIdentifier::new("openx_json_ignore_malformed", TType::Bool, 13))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.ignore_csv_redundant_col {
      o_prot.write_field_begin(&TFieldIdentifier::new("ignore_csv_redundant_col", TType::Bool, 1001))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TIcebergDeleteFileDesc
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TIcebergDeleteFileDesc {
  pub path: Option<String>,
  pub position_lower_bound: Option<i64>,
  pub position_upper_bound: Option<i64>,
  pub field_ids: Option<Vec<i32>>,
  pub content: Option<i32>,
}

impl TIcebergDeleteFileDesc {
  pub fn new<F1, F2, F3, F4, F5>(path: F1, position_lower_bound: F2, position_upper_bound: F3, field_ids: F4, content: F5) -> TIcebergDeleteFileDesc where F1: Into<Option<String>>, F2: Into<Option<i64>>, F3: Into<Option<i64>>, F4: Into<Option<Vec<i32>>>, F5: Into<Option<i32>> {
    TIcebergDeleteFileDesc {
      path: path.into(),
      position_lower_bound: position_lower_bound.into(),
      position_upper_bound: position_upper_bound.into(),
      field_ids: field_ids.into(),
      content: content.into(),
    }
  }
}

impl TSerializable for TIcebergDeleteFileDesc {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TIcebergDeleteFileDesc> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<Vec<i32>> = None;
    let mut f_5: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_15 = i_prot.read_i32()?;
            val.push(list_elem_15);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TIcebergDeleteFileDesc {
      path: f_1,
      position_lower_bound: f_2,
      position_upper_bound: f_3,
      field_ids: f_4,
      content: f_5,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TIcebergDeleteFileDesc");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.path {
      o_prot.write_field_begin(&TFieldIdentifier::new("path", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.position_lower_bound {
      o_prot.write_field_begin(&TFieldIdentifier::new("position_lower_bound", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.position_upper_bound {
      o_prot.write_field_begin(&TFieldIdentifier::new("position_upper_bound", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.field_ids {
      o_prot.write_field_begin(&TFieldIdentifier::new("field_ids", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I32, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i32(*e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.content {
      o_prot.write_field_begin(&TFieldIdentifier::new("content", TType::I32, 5))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TIcebergFileDesc
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TIcebergFileDesc {
  pub format_version: Option<i32>,
  pub content: Option<i32>,
  pub delete_files: Option<Vec<TIcebergDeleteFileDesc>>,
  pub delete_table_tuple_id: Option<types::TTupleId>,
  pub file_select_conjunct: Option<exprs::TExpr>,
  pub original_file_path: Option<String>,
  pub row_count: Option<i64>,
}

impl TIcebergFileDesc {
  pub fn new<F1, F2, F3, F4, F5, F6, F7>(format_version: F1, content: F2, delete_files: F3, delete_table_tuple_id: F4, file_select_conjunct: F5, original_file_path: F6, row_count: F7) -> TIcebergFileDesc where F1: Into<Option<i32>>, F2: Into<Option<i32>>, F3: Into<Option<Vec<TIcebergDeleteFileDesc>>>, F4: Into<Option<types::TTupleId>>, F5: Into<Option<exprs::TExpr>>, F6: Into<Option<String>>, F7: Into<Option<i64>> {
    TIcebergFileDesc {
      format_version: format_version.into(),
      content: content.into(),
      delete_files: delete_files.into(),
      delete_table_tuple_id: delete_table_tuple_id.into(),
      file_select_conjunct: file_select_conjunct.into(),
      original_file_path: original_file_path.into(),
      row_count: row_count.into(),
    }
  }
}

impl TSerializable for TIcebergFileDesc {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TIcebergFileDesc> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<Vec<TIcebergDeleteFileDesc>> = None;
    let mut f_4: Option<types::TTupleId> = None;
    let mut f_5: Option<exprs::TExpr> = None;
    let mut f_6: Option<String> = None;
    let mut f_7: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TIcebergDeleteFileDesc> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_16 = TIcebergDeleteFileDesc::read_from_in_protocol(i_prot)?;
            val.push(list_elem_16);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = exprs::TExpr::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i64()?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TIcebergFileDesc {
      format_version: f_1,
      content: f_2,
      delete_files: f_3,
      delete_table_tuple_id: f_4,
      file_select_conjunct: f_5,
      original_file_path: f_6,
      row_count: f_7,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TIcebergFileDesc");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.format_version {
      o_prot.write_field_begin(&TFieldIdentifier::new("format_version", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.content {
      o_prot.write_field_begin(&TFieldIdentifier::new("content", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.delete_files {
      o_prot.write_field_begin(&TFieldIdentifier::new("delete_files", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.delete_table_tuple_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("delete_table_tuple_id", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.file_select_conjunct {
      o_prot.write_field_begin(&TFieldIdentifier::new("file_select_conjunct", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.original_file_path {
      o_prot.write_field_begin(&TFieldIdentifier::new("original_file_path", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.row_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("row_count", TType::I64, 7))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TPaimonDeletionFileDesc
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TPaimonDeletionFileDesc {
  pub path: Option<String>,
  pub offset: Option<i64>,
  pub length: Option<i64>,
}

impl TPaimonDeletionFileDesc {
  pub fn new<F1, F2, F3>(path: F1, offset: F2, length: F3) -> TPaimonDeletionFileDesc where F1: Into<Option<String>>, F2: Into<Option<i64>>, F3: Into<Option<i64>> {
    TPaimonDeletionFileDesc {
      path: path.into(),
      offset: offset.into(),
      length: length.into(),
    }
  }
}

impl TSerializable for TPaimonDeletionFileDesc {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TPaimonDeletionFileDesc> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TPaimonDeletionFileDesc {
      path: f_1,
      offset: f_2,
      length: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TPaimonDeletionFileDesc");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.path {
      o_prot.write_field_begin(&TFieldIdentifier::new("path", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.offset {
      o_prot.write_field_begin(&TFieldIdentifier::new("offset", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.length {
      o_prot.write_field_begin(&TFieldIdentifier::new("length", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TPaimonFileDesc
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TPaimonFileDesc {
  pub paimon_split: Option<String>,
  pub paimon_column_names: Option<String>,
  pub db_name: Option<String>,
  pub table_name: Option<String>,
  pub paimon_predicate: Option<String>,
  pub paimon_options: Option<BTreeMap<String, String>>,
  pub ctl_id: Option<i64>,
  pub db_id: Option<i64>,
  pub tbl_id: Option<i64>,
  pub last_update_time: Option<i64>,
  pub file_format: Option<String>,
  pub deletion_file: Option<TPaimonDeletionFileDesc>,
  pub hadoop_conf: Option<BTreeMap<String, String>>,
  pub paimon_table: Option<String>,
  pub row_count: Option<i64>,
  pub schema_id: Option<i64>,
}

impl TPaimonFileDesc {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15, F16>(paimon_split: F1, paimon_column_names: F2, db_name: F3, table_name: F4, paimon_predicate: F5, paimon_options: F6, ctl_id: F7, db_id: F8, tbl_id: F9, last_update_time: F10, file_format: F11, deletion_file: F12, hadoop_conf: F13, paimon_table: F14, row_count: F15, schema_id: F16) -> TPaimonFileDesc where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<String>>, F6: Into<Option<BTreeMap<String, String>>>, F7: Into<Option<i64>>, F8: Into<Option<i64>>, F9: Into<Option<i64>>, F10: Into<Option<i64>>, F11: Into<Option<String>>, F12: Into<Option<TPaimonDeletionFileDesc>>, F13: Into<Option<BTreeMap<String, String>>>, F14: Into<Option<String>>, F15: Into<Option<i64>>, F16: Into<Option<i64>> {
    TPaimonFileDesc {
      paimon_split: paimon_split.into(),
      paimon_column_names: paimon_column_names.into(),
      db_name: db_name.into(),
      table_name: table_name.into(),
      paimon_predicate: paimon_predicate.into(),
      paimon_options: paimon_options.into(),
      ctl_id: ctl_id.into(),
      db_id: db_id.into(),
      tbl_id: tbl_id.into(),
      last_update_time: last_update_time.into(),
      file_format: file_format.into(),
      deletion_file: deletion_file.into(),
      hadoop_conf: hadoop_conf.into(),
      paimon_table: paimon_table.into(),
      row_count: row_count.into(),
      schema_id: schema_id.into(),
    }
  }
}

impl TSerializable for TPaimonFileDesc {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TPaimonFileDesc> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<BTreeMap<String, String>> = None;
    let mut f_7: Option<i64> = None;
    let mut f_8: Option<i64> = None;
    let mut f_9: Option<i64> = None;
    let mut f_10: Option<i64> = None;
    let mut f_11: Option<String> = None;
    let mut f_12: Option<TPaimonDeletionFileDesc> = None;
    let mut f_13: Option<BTreeMap<String, String>> = None;
    let mut f_14: Option<String> = None;
    let mut f_15: Option<i64> = None;
    let mut f_16: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_17 = i_prot.read_string()?;
            let map_val_18 = i_prot.read_string()?;
            val.insert(map_key_17, map_val_18);
          }
          i_prot.read_map_end()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i64()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i64()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_i64()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_i64()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_string()?;
          f_11 = Some(val);
        },
        12 => {
          let val = TPaimonDeletionFileDesc::read_from_in_protocol(i_prot)?;
          f_12 = Some(val);
        },
        13 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_19 = i_prot.read_string()?;
            let map_val_20 = i_prot.read_string()?;
            val.insert(map_key_19, map_val_20);
          }
          i_prot.read_map_end()?;
          f_13 = Some(val);
        },
        14 => {
          let val = i_prot.read_string()?;
          f_14 = Some(val);
        },
        15 => {
          let val = i_prot.read_i64()?;
          f_15 = Some(val);
        },
        16 => {
          let val = i_prot.read_i64()?;
          f_16 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TPaimonFileDesc {
      paimon_split: f_1,
      paimon_column_names: f_2,
      db_name: f_3,
      table_name: f_4,
      paimon_predicate: f_5,
      paimon_options: f_6,
      ctl_id: f_7,
      db_id: f_8,
      tbl_id: f_9,
      last_update_time: f_10,
      file_format: f_11,
      deletion_file: f_12,
      hadoop_conf: f_13,
      paimon_table: f_14,
      row_count: f_15,
      schema_id: f_16,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TPaimonFileDesc");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.paimon_split {
      o_prot.write_field_begin(&TFieldIdentifier::new("paimon_split", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.paimon_column_names {
      o_prot.write_field_begin(&TFieldIdentifier::new("paimon_column_names", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.db_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.table_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.paimon_predicate {
      o_prot.write_field_begin(&TFieldIdentifier::new("paimon_predicate", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.paimon_options {
      o_prot.write_field_begin(&TFieldIdentifier::new("paimon_options", TType::Map, 6))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.ctl_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("ctl_id", TType::I64, 7))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.db_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("db_id", TType::I64, 8))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.tbl_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("tbl_id", TType::I64, 9))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.last_update_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("last_update_time", TType::I64, 10))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.file_format {
      o_prot.write_field_begin(&TFieldIdentifier::new("file_format", TType::String, 11))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.deletion_file {
      o_prot.write_field_begin(&TFieldIdentifier::new("deletion_file", TType::Struct, 12))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.hadoop_conf {
      o_prot.write_field_begin(&TFieldIdentifier::new("hadoop_conf", TType::Map, 13))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.paimon_table {
      o_prot.write_field_begin(&TFieldIdentifier::new("paimon_table", TType::String, 14))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.row_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("row_count", TType::I64, 15))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.schema_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("schema_id", TType::I64, 16))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TTrinoConnectorFileDesc
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTrinoConnectorFileDesc {
  pub catalog_name: Option<String>,
  pub db_name: Option<String>,
  pub table_name: Option<String>,
  pub trino_connector_options: Option<BTreeMap<String, String>>,
  pub trino_connector_table_handle: Option<String>,
  pub trino_connector_column_handles: Option<String>,
  pub trino_connector_column_metadata: Option<String>,
  pub trino_connector_column_names: Option<String>,
  pub trino_connector_split: Option<String>,
  pub trino_connector_predicate: Option<String>,
  pub trino_connector_trascation_handle: Option<String>,
}

impl TTrinoConnectorFileDesc {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11>(catalog_name: F1, db_name: F2, table_name: F3, trino_connector_options: F4, trino_connector_table_handle: F5, trino_connector_column_handles: F6, trino_connector_column_metadata: F7, trino_connector_column_names: F8, trino_connector_split: F9, trino_connector_predicate: F10, trino_connector_trascation_handle: F11) -> TTrinoConnectorFileDesc where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<BTreeMap<String, String>>>, F5: Into<Option<String>>, F6: Into<Option<String>>, F7: Into<Option<String>>, F8: Into<Option<String>>, F9: Into<Option<String>>, F10: Into<Option<String>>, F11: Into<Option<String>> {
    TTrinoConnectorFileDesc {
      catalog_name: catalog_name.into(),
      db_name: db_name.into(),
      table_name: table_name.into(),
      trino_connector_options: trino_connector_options.into(),
      trino_connector_table_handle: trino_connector_table_handle.into(),
      trino_connector_column_handles: trino_connector_column_handles.into(),
      trino_connector_column_metadata: trino_connector_column_metadata.into(),
      trino_connector_column_names: trino_connector_column_names.into(),
      trino_connector_split: trino_connector_split.into(),
      trino_connector_predicate: trino_connector_predicate.into(),
      trino_connector_trascation_handle: trino_connector_trascation_handle.into(),
    }
  }
}

impl TSerializable for TTrinoConnectorFileDesc {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTrinoConnectorFileDesc> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<BTreeMap<String, String>> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<String> = None;
    let mut f_7: Option<String> = None;
    let mut f_8: Option<String> = None;
    let mut f_9: Option<String> = None;
    let mut f_10: Option<String> = None;
    let mut f_11: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_21 = i_prot.read_string()?;
            let map_val_22 = i_prot.read_string()?;
            val.insert(map_key_21, map_val_22);
          }
          i_prot.read_map_end()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_string()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_string()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_string()?;
          f_11 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TTrinoConnectorFileDesc {
      catalog_name: f_1,
      db_name: f_2,
      table_name: f_3,
      trino_connector_options: f_4,
      trino_connector_table_handle: f_5,
      trino_connector_column_handles: f_6,
      trino_connector_column_metadata: f_7,
      trino_connector_column_names: f_8,
      trino_connector_split: f_9,
      trino_connector_predicate: f_10,
      trino_connector_trascation_handle: f_11,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TTrinoConnectorFileDesc");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.catalog_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("catalog_name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.db_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.table_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.trino_connector_options {
      o_prot.write_field_begin(&TFieldIdentifier::new("trino_connector_options", TType::Map, 4))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.trino_connector_table_handle {
      o_prot.write_field_begin(&TFieldIdentifier::new("trino_connector_table_handle", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.trino_connector_column_handles {
      o_prot.write_field_begin(&TFieldIdentifier::new("trino_connector_column_handles", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.trino_connector_column_metadata {
      o_prot.write_field_begin(&TFieldIdentifier::new("trino_connector_column_metadata", TType::String, 7))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.trino_connector_column_names {
      o_prot.write_field_begin(&TFieldIdentifier::new("trino_connector_column_names", TType::String, 8))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.trino_connector_split {
      o_prot.write_field_begin(&TFieldIdentifier::new("trino_connector_split", TType::String, 9))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.trino_connector_predicate {
      o_prot.write_field_begin(&TFieldIdentifier::new("trino_connector_predicate", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.trino_connector_trascation_handle {
      o_prot.write_field_begin(&TFieldIdentifier::new("trino_connector_trascation_handle", TType::String, 11))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TMaxComputeFileDesc
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TMaxComputeFileDesc {
  pub partition_spec: Option<String>,
  pub session_id: Option<String>,
  pub table_batch_read_session: Option<String>,
  pub connect_timeout: Option<i32>,
  pub read_timeout: Option<i32>,
  pub retry_times: Option<i32>,
}

impl TMaxComputeFileDesc {
  pub fn new<F1, F2, F3, F4, F5, F6>(partition_spec: F1, session_id: F2, table_batch_read_session: F3, connect_timeout: F4, read_timeout: F5, retry_times: F6) -> TMaxComputeFileDesc where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<i32>>, F5: Into<Option<i32>>, F6: Into<Option<i32>> {
    TMaxComputeFileDesc {
      partition_spec: partition_spec.into(),
      session_id: session_id.into(),
      table_batch_read_session: table_batch_read_session.into(),
      connect_timeout: connect_timeout.into(),
      read_timeout: read_timeout.into(),
      retry_times: retry_times.into(),
    }
  }
}

impl TSerializable for TMaxComputeFileDesc {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TMaxComputeFileDesc> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = None;
    let mut f_5: Option<i32> = None;
    let mut f_6: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TMaxComputeFileDesc {
      partition_spec: f_1,
      session_id: f_2,
      table_batch_read_session: f_3,
      connect_timeout: f_4,
      read_timeout: f_5,
      retry_times: f_6,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TMaxComputeFileDesc");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.partition_spec {
      o_prot.write_field_begin(&TFieldIdentifier::new("partition_spec", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.session_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("session_id", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.table_batch_read_session {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_batch_read_session", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.connect_timeout {
      o_prot.write_field_begin(&TFieldIdentifier::new("connect_timeout", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.read_timeout {
      o_prot.write_field_begin(&TFieldIdentifier::new("read_timeout", TType::I32, 5))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.retry_times {
      o_prot.write_field_begin(&TFieldIdentifier::new("retry_times", TType::I32, 6))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// THudiFileDesc
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct THudiFileDesc {
  pub instant_time: Option<String>,
  pub serde: Option<String>,
  pub input_format: Option<String>,
  pub base_path: Option<String>,
  pub data_file_path: Option<String>,
  pub data_file_length: Option<i64>,
  pub delta_logs: Option<Vec<String>>,
  pub column_names: Option<Vec<String>>,
  pub column_types: Option<Vec<String>>,
  pub nested_fields: Option<Vec<String>>,
  pub hudi_jni_scanner: Option<String>,
  pub schema_id: Option<i64>,
}

impl THudiFileDesc {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12>(instant_time: F1, serde: F2, input_format: F3, base_path: F4, data_file_path: F5, data_file_length: F6, delta_logs: F7, column_names: F8, column_types: F9, nested_fields: F10, hudi_jni_scanner: F11, schema_id: F12) -> THudiFileDesc where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<String>>, F6: Into<Option<i64>>, F7: Into<Option<Vec<String>>>, F8: Into<Option<Vec<String>>>, F9: Into<Option<Vec<String>>>, F10: Into<Option<Vec<String>>>, F11: Into<Option<String>>, F12: Into<Option<i64>> {
    THudiFileDesc {
      instant_time: instant_time.into(),
      serde: serde.into(),
      input_format: input_format.into(),
      base_path: base_path.into(),
      data_file_path: data_file_path.into(),
      data_file_length: data_file_length.into(),
      delta_logs: delta_logs.into(),
      column_names: column_names.into(),
      column_types: column_types.into(),
      nested_fields: nested_fields.into(),
      hudi_jni_scanner: hudi_jni_scanner.into(),
      schema_id: schema_id.into(),
    }
  }
}

impl TSerializable for THudiFileDesc {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<THudiFileDesc> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<i64> = None;
    let mut f_7: Option<Vec<String>> = None;
    let mut f_8: Option<Vec<String>> = None;
    let mut f_9: Option<Vec<String>> = None;
    let mut f_10: Option<Vec<String>> = None;
    let mut f_11: Option<String> = None;
    let mut f_12: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i64()?;
          f_6 = Some(val);
        },
        7 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_23 = i_prot.read_string()?;
            val.push(list_elem_23);
          }
          i_prot.read_list_end()?;
          f_7 = Some(val);
        },
        8 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_24 = i_prot.read_string()?;
            val.push(list_elem_24);
          }
          i_prot.read_list_end()?;
          f_8 = Some(val);
        },
        9 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_25 = i_prot.read_string()?;
            val.push(list_elem_25);
          }
          i_prot.read_list_end()?;
          f_9 = Some(val);
        },
        10 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_26 = i_prot.read_string()?;
            val.push(list_elem_26);
          }
          i_prot.read_list_end()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_string()?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_i64()?;
          f_12 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = THudiFileDesc {
      instant_time: f_1,
      serde: f_2,
      input_format: f_3,
      base_path: f_4,
      data_file_path: f_5,
      data_file_length: f_6,
      delta_logs: f_7,
      column_names: f_8,
      column_types: f_9,
      nested_fields: f_10,
      hudi_jni_scanner: f_11,
      schema_id: f_12,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("THudiFileDesc");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.instant_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("instant_time", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.serde {
      o_prot.write_field_begin(&TFieldIdentifier::new("serde", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.input_format {
      o_prot.write_field_begin(&TFieldIdentifier::new("input_format", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.base_path {
      o_prot.write_field_begin(&TFieldIdentifier::new("base_path", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.data_file_path {
      o_prot.write_field_begin(&TFieldIdentifier::new("data_file_path", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.data_file_length {
      o_prot.write_field_begin(&TFieldIdentifier::new("data_file_length", TType::I64, 6))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.delta_logs {
      o_prot.write_field_begin(&TFieldIdentifier::new("delta_logs", TType::List, 7))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.column_names {
      o_prot.write_field_begin(&TFieldIdentifier::new("column_names", TType::List, 8))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.column_types {
      o_prot.write_field_begin(&TFieldIdentifier::new("column_types", TType::List, 9))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.nested_fields {
      o_prot.write_field_begin(&TFieldIdentifier::new("nested_fields", TType::List, 10))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.hudi_jni_scanner {
      o_prot.write_field_begin(&TFieldIdentifier::new("hudi_jni_scanner", TType::String, 11))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.schema_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("schema_id", TType::I64, 12))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TLakeSoulFileDesc
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TLakeSoulFileDesc {
  pub file_paths: Option<Vec<String>>,
  pub primary_keys: Option<Vec<String>>,
  pub partition_descs: Option<Vec<String>>,
  pub table_schema: Option<String>,
  pub options: Option<String>,
}

impl TLakeSoulFileDesc {
  pub fn new<F1, F2, F3, F4, F5>(file_paths: F1, primary_keys: F2, partition_descs: F3, table_schema: F4, options: F5) -> TLakeSoulFileDesc where F1: Into<Option<Vec<String>>>, F2: Into<Option<Vec<String>>>, F3: Into<Option<Vec<String>>>, F4: Into<Option<String>>, F5: Into<Option<String>> {
    TLakeSoulFileDesc {
      file_paths: file_paths.into(),
      primary_keys: primary_keys.into(),
      partition_descs: partition_descs.into(),
      table_schema: table_schema.into(),
      options: options.into(),
    }
  }
}

impl TSerializable for TLakeSoulFileDesc {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TLakeSoulFileDesc> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<String>> = None;
    let mut f_2: Option<Vec<String>> = None;
    let mut f_3: Option<Vec<String>> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_27 = i_prot.read_string()?;
            val.push(list_elem_27);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_28 = i_prot.read_string()?;
            val.push(list_elem_28);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_29 = i_prot.read_string()?;
            val.push(list_elem_29);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TLakeSoulFileDesc {
      file_paths: f_1,
      primary_keys: f_2,
      partition_descs: f_3,
      table_schema: f_4,
      options: f_5,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TLakeSoulFileDesc");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.file_paths {
      o_prot.write_field_begin(&TFieldIdentifier::new("file_paths", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.primary_keys {
      o_prot.write_field_begin(&TFieldIdentifier::new("primary_keys", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.partition_descs {
      o_prot.write_field_begin(&TFieldIdentifier::new("partition_descs", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.table_schema {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_schema", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.options {
      o_prot.write_field_begin(&TFieldIdentifier::new("options", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TTransactionalHiveDeleteDeltaDesc
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTransactionalHiveDeleteDeltaDesc {
  pub directory_location: Option<String>,
  pub file_names: Option<Vec<String>>,
}

impl TTransactionalHiveDeleteDeltaDesc {
  pub fn new<F1, F2>(directory_location: F1, file_names: F2) -> TTransactionalHiveDeleteDeltaDesc where F1: Into<Option<String>>, F2: Into<Option<Vec<String>>> {
    TTransactionalHiveDeleteDeltaDesc {
      directory_location: directory_location.into(),
      file_names: file_names.into(),
    }
  }
}

impl TSerializable for TTransactionalHiveDeleteDeltaDesc {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTransactionalHiveDeleteDeltaDesc> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_30 = i_prot.read_string()?;
            val.push(list_elem_30);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TTransactionalHiveDeleteDeltaDesc {
      directory_location: f_1,
      file_names: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TTransactionalHiveDeleteDeltaDesc");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.directory_location {
      o_prot.write_field_begin(&TFieldIdentifier::new("directory_location", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.file_names {
      o_prot.write_field_begin(&TFieldIdentifier::new("file_names", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TTransactionalHiveDesc
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTransactionalHiveDesc {
  pub partition: Option<String>,
  pub delete_deltas: Option<Vec<TTransactionalHiveDeleteDeltaDesc>>,
}

impl TTransactionalHiveDesc {
  pub fn new<F1, F2>(partition: F1, delete_deltas: F2) -> TTransactionalHiveDesc where F1: Into<Option<String>>, F2: Into<Option<Vec<TTransactionalHiveDeleteDeltaDesc>>> {
    TTransactionalHiveDesc {
      partition: partition.into(),
      delete_deltas: delete_deltas.into(),
    }
  }
}

impl TSerializable for TTransactionalHiveDesc {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTransactionalHiveDesc> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<Vec<TTransactionalHiveDeleteDeltaDesc>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TTransactionalHiveDeleteDeltaDesc> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_31 = TTransactionalHiveDeleteDeltaDesc::read_from_in_protocol(i_prot)?;
            val.push(list_elem_31);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TTransactionalHiveDesc {
      partition: f_1,
      delete_deltas: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TTransactionalHiveDesc");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.partition {
      o_prot.write_field_begin(&TFieldIdentifier::new("partition", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.delete_deltas {
      o_prot.write_field_begin(&TFieldIdentifier::new("delete_deltas", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TRemoteDorisFileDesc
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TRemoteDorisFileDesc {
  pub ip: Option<String>,
  pub arrow_port: Option<String>,
  pub ticket: Option<Vec<u8>>,
  pub location_uri: Option<String>,
  pub user: Option<String>,
  pub password: Option<String>,
}

impl TRemoteDorisFileDesc {
  pub fn new<F1, F2, F3, F4, F5, F6>(ip: F1, arrow_port: F2, ticket: F3, location_uri: F4, user: F5, password: F6) -> TRemoteDorisFileDesc where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<Vec<u8>>>, F4: Into<Option<String>>, F5: Into<Option<String>>, F6: Into<Option<String>> {
    TRemoteDorisFileDesc {
      ip: ip.into(),
      arrow_port: arrow_port.into(),
      ticket: ticket.into(),
      location_uri: location_uri.into(),
      user: user.into(),
      password: password.into(),
    }
  }
}

impl TSerializable for TRemoteDorisFileDesc {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TRemoteDorisFileDesc> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<u8>> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bytes()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TRemoteDorisFileDesc {
      ip: f_1,
      arrow_port: f_2,
      ticket: f_3,
      location_uri: f_4,
      user: f_5,
      password: f_6,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TRemoteDorisFileDesc");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.ip {
      o_prot.write_field_begin(&TFieldIdentifier::new("ip", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.arrow_port {
      o_prot.write_field_begin(&TFieldIdentifier::new("arrow_port", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.ticket {
      o_prot.write_field_begin(&TFieldIdentifier::new("ticket", TType::String, 3))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.location_uri {
      o_prot.write_field_begin(&TFieldIdentifier::new("location_uri", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user {
      o_prot.write_field_begin(&TFieldIdentifier::new("user", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.password {
      o_prot.write_field_begin(&TFieldIdentifier::new("password", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TTableFormatFileDesc
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTableFormatFileDesc {
  pub table_format_type: Option<String>,
  pub iceberg_params: Option<TIcebergFileDesc>,
  pub hudi_params: Option<THudiFileDesc>,
  pub paimon_params: Option<TPaimonFileDesc>,
  pub transactional_hive_params: Option<TTransactionalHiveDesc>,
  pub max_compute_params: Option<TMaxComputeFileDesc>,
  pub trino_connector_params: Option<TTrinoConnectorFileDesc>,
  pub lakesoul_params: Option<TLakeSoulFileDesc>,
  pub table_level_row_count: Option<i64>,
  pub remote_doris_params: Option<TRemoteDorisFileDesc>,
}

impl TTableFormatFileDesc {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10>(table_format_type: F1, iceberg_params: F2, hudi_params: F3, paimon_params: F4, transactional_hive_params: F5, max_compute_params: F6, trino_connector_params: F7, lakesoul_params: F8, table_level_row_count: F9, remote_doris_params: F10) -> TTableFormatFileDesc where F1: Into<Option<String>>, F2: Into<Option<TIcebergFileDesc>>, F3: Into<Option<THudiFileDesc>>, F4: Into<Option<TPaimonFileDesc>>, F5: Into<Option<TTransactionalHiveDesc>>, F6: Into<Option<TMaxComputeFileDesc>>, F7: Into<Option<TTrinoConnectorFileDesc>>, F8: Into<Option<TLakeSoulFileDesc>>, F9: Into<Option<i64>>, F10: Into<Option<TRemoteDorisFileDesc>> {
    TTableFormatFileDesc {
      table_format_type: table_format_type.into(),
      iceberg_params: iceberg_params.into(),
      hudi_params: hudi_params.into(),
      paimon_params: paimon_params.into(),
      transactional_hive_params: transactional_hive_params.into(),
      max_compute_params: max_compute_params.into(),
      trino_connector_params: trino_connector_params.into(),
      lakesoul_params: lakesoul_params.into(),
      table_level_row_count: table_level_row_count.into(),
      remote_doris_params: remote_doris_params.into(),
    }
  }
}

impl TSerializable for TTableFormatFileDesc {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTableFormatFileDesc> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<TIcebergFileDesc> = None;
    let mut f_3: Option<THudiFileDesc> = None;
    let mut f_4: Option<TPaimonFileDesc> = None;
    let mut f_5: Option<TTransactionalHiveDesc> = None;
    let mut f_6: Option<TMaxComputeFileDesc> = None;
    let mut f_7: Option<TTrinoConnectorFileDesc> = None;
    let mut f_8: Option<TLakeSoulFileDesc> = None;
    let mut f_9: Option<i64> = None;
    let mut f_10: Option<TRemoteDorisFileDesc> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = TIcebergFileDesc::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = THudiFileDesc::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = TPaimonFileDesc::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = TTransactionalHiveDesc::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = TMaxComputeFileDesc::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = TTrinoConnectorFileDesc::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        8 => {
          let val = TLakeSoulFileDesc::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_i64()?;
          f_9 = Some(val);
        },
        10 => {
          let val = TRemoteDorisFileDesc::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TTableFormatFileDesc {
      table_format_type: f_1,
      iceberg_params: f_2,
      hudi_params: f_3,
      paimon_params: f_4,
      transactional_hive_params: f_5,
      max_compute_params: f_6,
      trino_connector_params: f_7,
      lakesoul_params: f_8,
      table_level_row_count: f_9,
      remote_doris_params: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TTableFormatFileDesc");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.table_format_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_format_type", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.iceberg_params {
      o_prot.write_field_begin(&TFieldIdentifier::new("iceberg_params", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.hudi_params {
      o_prot.write_field_begin(&TFieldIdentifier::new("hudi_params", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.paimon_params {
      o_prot.write_field_begin(&TFieldIdentifier::new("paimon_params", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.transactional_hive_params {
      o_prot.write_field_begin(&TFieldIdentifier::new("transactional_hive_params", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.max_compute_params {
      o_prot.write_field_begin(&TFieldIdentifier::new("max_compute_params", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.trino_connector_params {
      o_prot.write_field_begin(&TFieldIdentifier::new("trino_connector_params", TType::Struct, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.lakesoul_params {
      o_prot.write_field_begin(&TFieldIdentifier::new("lakesoul_params", TType::Struct, 8))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.table_level_row_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_level_row_count", TType::I64, 9))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.remote_doris_params {
      o_prot.write_field_begin(&TFieldIdentifier::new("remote_doris_params", TType::Struct, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TFileScanRangeParams
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TFileScanRangeParams {
  pub file_type: Option<types::TFileType>,
  pub format_type: Option<TFileFormatType>,
  pub compress_type: Option<TFileCompressType>,
  pub src_tuple_id: Option<types::TTupleId>,
  pub dest_tuple_id: Option<types::TTupleId>,
  pub num_of_columns_from_file: Option<i32>,
  pub required_slots: Option<Vec<TFileScanSlotInfo>>,
  pub hdfs_params: Option<THdfsParams>,
  pub properties: Option<BTreeMap<String, String>>,
  pub expr_of_dest_slot: Option<BTreeMap<types::TSlotId, exprs::TExpr>>,
  pub default_value_of_src_slot: Option<BTreeMap<types::TSlotId, exprs::TExpr>>,
  pub dest_sid_to_src_sid_without_trans: Option<BTreeMap<types::TSlotId, types::TSlotId>>,
  pub strict_mode: Option<bool>,
  pub broker_addresses: Option<Vec<types::TNetworkAddress>>,
  pub file_attributes: Option<TFileAttributes>,
  pub pre_filter_exprs: Option<exprs::TExpr>,
  pub table_format_params: Option<TTableFormatFileDesc>,
  pub column_idxs: Option<Vec<i32>>,
  pub slot_name_to_schema_pos: Option<BTreeMap<String, i32>>,
  pub pre_filter_exprs_list: Option<Vec<exprs::TExpr>>,
  pub load_id: Option<types::TUniqueId>,
  pub text_serde_type: Option<TTextSerdeType>,
  pub sequence_map_col: Option<String>,
  pub serialized_table: Option<String>,
  pub current_schema_id: Option<i64>,
  pub history_schema_info: Option<Vec<external_table_schema::TSchema>>,
}

impl TFileScanRangeParams {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15, F16, F17, F18, F19, F20, F21, F22, F23, F24, F25, F26>(file_type: F1, format_type: F2, compress_type: F3, src_tuple_id: F4, dest_tuple_id: F5, num_of_columns_from_file: F6, required_slots: F7, hdfs_params: F8, properties: F9, expr_of_dest_slot: F10, default_value_of_src_slot: F11, dest_sid_to_src_sid_without_trans: F12, strict_mode: F13, broker_addresses: F14, file_attributes: F15, pre_filter_exprs: F16, table_format_params: F17, column_idxs: F18, slot_name_to_schema_pos: F19, pre_filter_exprs_list: F20, load_id: F21, text_serde_type: F22, sequence_map_col: F23, serialized_table: F24, current_schema_id: F25, history_schema_info: F26) -> TFileScanRangeParams where F1: Into<Option<types::TFileType>>, F2: Into<Option<TFileFormatType>>, F3: Into<Option<TFileCompressType>>, F4: Into<Option<types::TTupleId>>, F5: Into<Option<types::TTupleId>>, F6: Into<Option<i32>>, F7: Into<Option<Vec<TFileScanSlotInfo>>>, F8: Into<Option<THdfsParams>>, F9: Into<Option<BTreeMap<String, String>>>, F10: Into<Option<BTreeMap<types::TSlotId, exprs::TExpr>>>, F11: Into<Option<BTreeMap<types::TSlotId, exprs::TExpr>>>, F12: Into<Option<BTreeMap<types::TSlotId, types::TSlotId>>>, F13: Into<Option<bool>>, F14: Into<Option<Vec<types::TNetworkAddress>>>, F15: Into<Option<TFileAttributes>>, F16: Into<Option<exprs::TExpr>>, F17: Into<Option<TTableFormatFileDesc>>, F18: Into<Option<Vec<i32>>>, F19: Into<Option<BTreeMap<String, i32>>>, F20: Into<Option<Vec<exprs::TExpr>>>, F21: Into<Option<types::TUniqueId>>, F22: Into<Option<TTextSerdeType>>, F23: Into<Option<String>>, F24: Into<Option<String>>, F25: Into<Option<i64>>, F26: Into<Option<Vec<external_table_schema::TSchema>>> {
    TFileScanRangeParams {
      file_type: file_type.into(),
      format_type: format_type.into(),
      compress_type: compress_type.into(),
      src_tuple_id: src_tuple_id.into(),
      dest_tuple_id: dest_tuple_id.into(),
      num_of_columns_from_file: num_of_columns_from_file.into(),
      required_slots: required_slots.into(),
      hdfs_params: hdfs_params.into(),
      properties: properties.into(),
      expr_of_dest_slot: expr_of_dest_slot.into(),
      default_value_of_src_slot: default_value_of_src_slot.into(),
      dest_sid_to_src_sid_without_trans: dest_sid_to_src_sid_without_trans.into(),
      strict_mode: strict_mode.into(),
      broker_addresses: broker_addresses.into(),
      file_attributes: file_attributes.into(),
      pre_filter_exprs: pre_filter_exprs.into(),
      table_format_params: table_format_params.into(),
      column_idxs: column_idxs.into(),
      slot_name_to_schema_pos: slot_name_to_schema_pos.into(),
      pre_filter_exprs_list: pre_filter_exprs_list.into(),
      load_id: load_id.into(),
      text_serde_type: text_serde_type.into(),
      sequence_map_col: sequence_map_col.into(),
      serialized_table: serialized_table.into(),
      current_schema_id: current_schema_id.into(),
      history_schema_info: history_schema_info.into(),
    }
  }
}

impl TSerializable for TFileScanRangeParams {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TFileScanRangeParams> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<types::TFileType> = None;
    let mut f_2: Option<TFileFormatType> = None;
    let mut f_3: Option<TFileCompressType> = None;
    let mut f_4: Option<types::TTupleId> = None;
    let mut f_5: Option<types::TTupleId> = None;
    let mut f_6: Option<i32> = None;
    let mut f_7: Option<Vec<TFileScanSlotInfo>> = None;
    let mut f_8: Option<THdfsParams> = None;
    let mut f_9: Option<BTreeMap<String, String>> = None;
    let mut f_10: Option<BTreeMap<types::TSlotId, exprs::TExpr>> = None;
    let mut f_11: Option<BTreeMap<types::TSlotId, exprs::TExpr>> = None;
    let mut f_12: Option<BTreeMap<types::TSlotId, types::TSlotId>> = None;
    let mut f_13: Option<bool> = None;
    let mut f_14: Option<Vec<types::TNetworkAddress>> = None;
    let mut f_15: Option<TFileAttributes> = None;
    let mut f_16: Option<exprs::TExpr> = None;
    let mut f_17: Option<TTableFormatFileDesc> = None;
    let mut f_18: Option<Vec<i32>> = None;
    let mut f_19: Option<BTreeMap<String, i32>> = None;
    let mut f_20: Option<Vec<exprs::TExpr>> = None;
    let mut f_21: Option<types::TUniqueId> = None;
    let mut f_22: Option<TTextSerdeType> = None;
    let mut f_23: Option<String> = None;
    let mut f_24: Option<String> = None;
    let mut f_25: Option<i64> = None;
    let mut f_26: Option<Vec<external_table_schema::TSchema>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = types::TFileType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = TFileFormatType::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = TFileCompressType::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        7 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TFileScanSlotInfo> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_32 = TFileScanSlotInfo::read_from_in_protocol(i_prot)?;
            val.push(list_elem_32);
          }
          i_prot.read_list_end()?;
          f_7 = Some(val);
        },
        8 => {
          let val = THdfsParams::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        9 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_33 = i_prot.read_string()?;
            let map_val_34 = i_prot.read_string()?;
            val.insert(map_key_33, map_val_34);
          }
          i_prot.read_map_end()?;
          f_9 = Some(val);
        },
        10 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<types::TSlotId, exprs::TExpr> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_35 = i_prot.read_i32()?;
            let map_val_36 = exprs::TExpr::read_from_in_protocol(i_prot)?;
            val.insert(map_key_35, map_val_36);
          }
          i_prot.read_map_end()?;
          f_10 = Some(val);
        },
        11 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<types::TSlotId, exprs::TExpr> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_37 = i_prot.read_i32()?;
            let map_val_38 = exprs::TExpr::read_from_in_protocol(i_prot)?;
            val.insert(map_key_37, map_val_38);
          }
          i_prot.read_map_end()?;
          f_11 = Some(val);
        },
        12 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<types::TSlotId, types::TSlotId> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_39 = i_prot.read_i32()?;
            let map_val_40 = i_prot.read_i32()?;
            val.insert(map_key_39, map_val_40);
          }
          i_prot.read_map_end()?;
          f_12 = Some(val);
        },
        13 => {
          let val = i_prot.read_bool()?;
          f_13 = Some(val);
        },
        14 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::TNetworkAddress> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_41 = types::TNetworkAddress::read_from_in_protocol(i_prot)?;
            val.push(list_elem_41);
          }
          i_prot.read_list_end()?;
          f_14 = Some(val);
        },
        15 => {
          let val = TFileAttributes::read_from_in_protocol(i_prot)?;
          f_15 = Some(val);
        },
        16 => {
          let val = exprs::TExpr::read_from_in_protocol(i_prot)?;
          f_16 = Some(val);
        },
        17 => {
          let val = TTableFormatFileDesc::read_from_in_protocol(i_prot)?;
          f_17 = Some(val);
        },
        18 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_42 = i_prot.read_i32()?;
            val.push(list_elem_42);
          }
          i_prot.read_list_end()?;
          f_18 = Some(val);
        },
        19 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, i32> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_43 = i_prot.read_string()?;
            let map_val_44 = i_prot.read_i32()?;
            val.insert(map_key_43, map_val_44);
          }
          i_prot.read_map_end()?;
          f_19 = Some(val);
        },
        20 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<exprs::TExpr> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_45 = exprs::TExpr::read_from_in_protocol(i_prot)?;
            val.push(list_elem_45);
          }
          i_prot.read_list_end()?;
          f_20 = Some(val);
        },
        21 => {
          let val = types::TUniqueId::read_from_in_protocol(i_prot)?;
          f_21 = Some(val);
        },
        22 => {
          let val = TTextSerdeType::read_from_in_protocol(i_prot)?;
          f_22 = Some(val);
        },
        23 => {
          let val = i_prot.read_string()?;
          f_23 = Some(val);
        },
        24 => {
          let val = i_prot.read_string()?;
          f_24 = Some(val);
        },
        25 => {
          let val = i_prot.read_i64()?;
          f_25 = Some(val);
        },
        26 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<external_table_schema::TSchema> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_46 = external_table_schema::TSchema::read_from_in_protocol(i_prot)?;
            val.push(list_elem_46);
          }
          i_prot.read_list_end()?;
          f_26 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TFileScanRangeParams {
      file_type: f_1,
      format_type: f_2,
      compress_type: f_3,
      src_tuple_id: f_4,
      dest_tuple_id: f_5,
      num_of_columns_from_file: f_6,
      required_slots: f_7,
      hdfs_params: f_8,
      properties: f_9,
      expr_of_dest_slot: f_10,
      default_value_of_src_slot: f_11,
      dest_sid_to_src_sid_without_trans: f_12,
      strict_mode: f_13,
      broker_addresses: f_14,
      file_attributes: f_15,
      pre_filter_exprs: f_16,
      table_format_params: f_17,
      column_idxs: f_18,
      slot_name_to_schema_pos: f_19,
      pre_filter_exprs_list: f_20,
      load_id: f_21,
      text_serde_type: f_22,
      sequence_map_col: f_23,
      serialized_table: f_24,
      current_schema_id: f_25,
      history_schema_info: f_26,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TFileScanRangeParams");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.file_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("file_type", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.format_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("format_type", TType::I32, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.compress_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("compress_type", TType::I32, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.src_tuple_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("src_tuple_id", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.dest_tuple_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("dest_tuple_id", TType::I32, 5))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.num_of_columns_from_file {
      o_prot.write_field_begin(&TFieldIdentifier::new("num_of_columns_from_file", TType::I32, 6))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.required_slots {
      o_prot.write_field_begin(&TFieldIdentifier::new("required_slots", TType::List, 7))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.hdfs_params {
      o_prot.write_field_begin(&TFieldIdentifier::new("hdfs_params", TType::Struct, 8))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.properties {
      o_prot.write_field_begin(&TFieldIdentifier::new("properties", TType::Map, 9))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.expr_of_dest_slot {
      o_prot.write_field_begin(&TFieldIdentifier::new("expr_of_dest_slot", TType::Map, 10))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::I32, TType::Struct, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_i32(*k)?;
        v.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.default_value_of_src_slot {
      o_prot.write_field_begin(&TFieldIdentifier::new("default_value_of_src_slot", TType::Map, 11))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::I32, TType::Struct, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_i32(*k)?;
        v.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.dest_sid_to_src_sid_without_trans {
      o_prot.write_field_begin(&TFieldIdentifier::new("dest_sid_to_src_sid_without_trans", TType::Map, 12))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::I32, TType::I32, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_i32(*k)?;
        o_prot.write_i32(*v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.strict_mode {
      o_prot.write_field_begin(&TFieldIdentifier::new("strict_mode", TType::Bool, 13))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.broker_addresses {
      o_prot.write_field_begin(&TFieldIdentifier::new("broker_addresses", TType::List, 14))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.file_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("file_attributes", TType::Struct, 15))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.pre_filter_exprs {
      o_prot.write_field_begin(&TFieldIdentifier::new("pre_filter_exprs", TType::Struct, 16))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.table_format_params {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_format_params", TType::Struct, 17))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.column_idxs {
      o_prot.write_field_begin(&TFieldIdentifier::new("column_idxs", TType::List, 18))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I32, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i32(*e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.slot_name_to_schema_pos {
      o_prot.write_field_begin(&TFieldIdentifier::new("slot_name_to_schema_pos", TType::Map, 19))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::I32, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_i32(*v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.pre_filter_exprs_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("pre_filter_exprs_list", TType::List, 20))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.load_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("load_id", TType::Struct, 21))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.text_serde_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("text_serde_type", TType::I32, 22))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.sequence_map_col {
      o_prot.write_field_begin(&TFieldIdentifier::new("sequence_map_col", TType::String, 23))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.serialized_table {
      o_prot.write_field_begin(&TFieldIdentifier::new("serialized_table", TType::String, 24))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.current_schema_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("current_schema_id", TType::I64, 25))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.history_schema_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("history_schema_info", TType::List, 26))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TFileRangeDesc
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TFileRangeDesc {
  pub load_id: Option<types::TUniqueId>,
  pub path: Option<String>,
  pub start_offset: Option<i64>,
  pub size: Option<i64>,
  pub file_size: Option<i64>,
  pub columns_from_path: Option<Vec<String>>,
  pub columns_from_path_keys: Option<Vec<String>>,
  pub table_format_params: Option<TTableFormatFileDesc>,
  pub modification_time: Option<i64>,
  pub file_type: Option<types::TFileType>,
  pub compress_type: Option<TFileCompressType>,
  pub fs_name: Option<String>,
  pub format_type: Option<TFileFormatType>,
  pub self_split_weight: Option<i64>,
  pub columns_from_path_is_null: Option<Vec<bool>>,
}

impl TFileRangeDesc {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15>(load_id: F1, path: F2, start_offset: F3, size: F4, file_size: F5, columns_from_path: F6, columns_from_path_keys: F7, table_format_params: F8, modification_time: F9, file_type: F10, compress_type: F11, fs_name: F12, format_type: F13, self_split_weight: F14, columns_from_path_is_null: F15) -> TFileRangeDesc where F1: Into<Option<types::TUniqueId>>, F2: Into<Option<String>>, F3: Into<Option<i64>>, F4: Into<Option<i64>>, F5: Into<Option<i64>>, F6: Into<Option<Vec<String>>>, F7: Into<Option<Vec<String>>>, F8: Into<Option<TTableFormatFileDesc>>, F9: Into<Option<i64>>, F10: Into<Option<types::TFileType>>, F11: Into<Option<TFileCompressType>>, F12: Into<Option<String>>, F13: Into<Option<TFileFormatType>>, F14: Into<Option<i64>>, F15: Into<Option<Vec<bool>>> {
    TFileRangeDesc {
      load_id: load_id.into(),
      path: path.into(),
      start_offset: start_offset.into(),
      size: size.into(),
      file_size: file_size.into(),
      columns_from_path: columns_from_path.into(),
      columns_from_path_keys: columns_from_path_keys.into(),
      table_format_params: table_format_params.into(),
      modification_time: modification_time.into(),
      file_type: file_type.into(),
      compress_type: compress_type.into(),
      fs_name: fs_name.into(),
      format_type: format_type.into(),
      self_split_weight: self_split_weight.into(),
      columns_from_path_is_null: columns_from_path_is_null.into(),
    }
  }
}

impl TSerializable for TFileRangeDesc {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TFileRangeDesc> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<types::TUniqueId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<i64> = None;
    let mut f_5: Option<i64> = None;
    let mut f_6: Option<Vec<String>> = None;
    let mut f_7: Option<Vec<String>> = None;
    let mut f_8: Option<TTableFormatFileDesc> = None;
    let mut f_9: Option<i64> = None;
    let mut f_10: Option<types::TFileType> = None;
    let mut f_11: Option<TFileCompressType> = None;
    let mut f_12: Option<String> = None;
    let mut f_13: Option<TFileFormatType> = None;
    let mut f_14: Option<i64> = None;
    let mut f_15: Option<Vec<bool>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = types::TUniqueId::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        6 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_47 = i_prot.read_string()?;
            val.push(list_elem_47);
          }
          i_prot.read_list_end()?;
          f_6 = Some(val);
        },
        7 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_48 = i_prot.read_string()?;
            val.push(list_elem_48);
          }
          i_prot.read_list_end()?;
          f_7 = Some(val);
        },
        8 => {
          let val = TTableFormatFileDesc::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_i64()?;
          f_9 = Some(val);
        },
        10 => {
          let val = types::TFileType::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        11 => {
          let val = TFileCompressType::read_from_in_protocol(i_prot)?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_string()?;
          f_12 = Some(val);
        },
        13 => {
          let val = TFileFormatType::read_from_in_protocol(i_prot)?;
          f_13 = Some(val);
        },
        14 => {
          let val = i_prot.read_i64()?;
          f_14 = Some(val);
        },
        15 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<bool> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_49 = i_prot.read_bool()?;
            val.push(list_elem_49);
          }
          i_prot.read_list_end()?;
          f_15 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TFileRangeDesc {
      load_id: f_1,
      path: f_2,
      start_offset: f_3,
      size: f_4,
      file_size: f_5,
      columns_from_path: f_6,
      columns_from_path_keys: f_7,
      table_format_params: f_8,
      modification_time: f_9,
      file_type: f_10,
      compress_type: f_11,
      fs_name: f_12,
      format_type: f_13,
      self_split_weight: f_14,
      columns_from_path_is_null: f_15,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TFileRangeDesc");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.load_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("load_id", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.path {
      o_prot.write_field_begin(&TFieldIdentifier::new("path", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.start_offset {
      o_prot.write_field_begin(&TFieldIdentifier::new("start_offset", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.size {
      o_prot.write_field_begin(&TFieldIdentifier::new("size", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.file_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("file_size", TType::I64, 5))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.columns_from_path {
      o_prot.write_field_begin(&TFieldIdentifier::new("columns_from_path", TType::List, 6))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.columns_from_path_keys {
      o_prot.write_field_begin(&TFieldIdentifier::new("columns_from_path_keys", TType::List, 7))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.table_format_params {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_format_params", TType::Struct, 8))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.modification_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("modification_time", TType::I64, 9))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.file_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("file_type", TType::I32, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.compress_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("compress_type", TType::I32, 11))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.fs_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("fs_name", TType::String, 12))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.format_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("format_type", TType::I32, 13))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.self_split_weight {
      o_prot.write_field_begin(&TFieldIdentifier::new("self_split_weight", TType::I64, 14))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.columns_from_path_is_null {
      o_prot.write_field_begin(&TFieldIdentifier::new("columns_from_path_is_null", TType::List, 15))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Bool, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_bool(*e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSplitSource
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSplitSource {
  pub split_source_id: Option<i64>,
  pub num_splits: Option<i32>,
}

impl TSplitSource {
  pub fn new<F1, F2>(split_source_id: F1, num_splits: F2) -> TSplitSource where F1: Into<Option<i64>>, F2: Into<Option<i32>> {
    TSplitSource {
      split_source_id: split_source_id.into(),
      num_splits: num_splits.into(),
    }
  }
}

impl TSerializable for TSplitSource {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSplitSource> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TSplitSource {
      split_source_id: f_1,
      num_splits: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSplitSource");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.split_source_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("split_source_id", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.num_splits {
      o_prot.write_field_begin(&TFieldIdentifier::new("num_splits", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TFileScanRange
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TFileScanRange {
  pub ranges: Option<Vec<TFileRangeDesc>>,
  pub params: Option<TFileScanRangeParams>,
  pub split_source: Option<TSplitSource>,
}

impl TFileScanRange {
  pub fn new<F1, F2, F3>(ranges: F1, params: F2, split_source: F3) -> TFileScanRange where F1: Into<Option<Vec<TFileRangeDesc>>>, F2: Into<Option<TFileScanRangeParams>>, F3: Into<Option<TSplitSource>> {
    TFileScanRange {
      ranges: ranges.into(),
      params: params.into(),
      split_source: split_source.into(),
    }
  }
}

impl TSerializable for TFileScanRange {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TFileScanRange> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<TFileRangeDesc>> = None;
    let mut f_2: Option<TFileScanRangeParams> = None;
    let mut f_3: Option<TSplitSource> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TFileRangeDesc> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_50 = TFileRangeDesc::read_from_in_protocol(i_prot)?;
            val.push(list_elem_50);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = TFileScanRangeParams::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = TSplitSource::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TFileScanRange {
      ranges: f_1,
      params: f_2,
      split_source: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TFileScanRange");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.ranges {
      o_prot.write_field_begin(&TFieldIdentifier::new("ranges", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.params {
      o_prot.write_field_begin(&TFieldIdentifier::new("params", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.split_source {
      o_prot.write_field_begin(&TFieldIdentifier::new("split_source", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TExternalScanRange
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TExternalScanRange {
  pub file_scan_range: Option<TFileScanRange>,
}

impl TExternalScanRange {
  pub fn new<F1>(file_scan_range: F1) -> TExternalScanRange where F1: Into<Option<TFileScanRange>> {
    TExternalScanRange {
      file_scan_range: file_scan_range.into(),
    }
  }
}

impl TSerializable for TExternalScanRange {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TExternalScanRange> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TFileScanRange> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TFileScanRange::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TExternalScanRange {
      file_scan_range: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TExternalScanRange");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.file_scan_range {
      o_prot.write_field_begin(&TFieldIdentifier::new("file_scan_range", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TTVFNumbersScanRange
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTVFNumbersScanRange {
  pub total_numbers: Option<i64>,
  pub use_const: Option<bool>,
  pub const_value: Option<i64>,
}

impl TTVFNumbersScanRange {
  pub fn new<F1, F2, F3>(total_numbers: F1, use_const: F2, const_value: F3) -> TTVFNumbersScanRange where F1: Into<Option<i64>>, F2: Into<Option<bool>>, F3: Into<Option<i64>> {
    TTVFNumbersScanRange {
      total_numbers: total_numbers.into(),
      use_const: use_const.into(),
      const_value: const_value.into(),
    }
  }
}

impl TSerializable for TTVFNumbersScanRange {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTVFNumbersScanRange> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<bool> = None;
    let mut f_3: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TTVFNumbersScanRange {
      total_numbers: f_1,
      use_const: f_2,
      const_value: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TTVFNumbersScanRange");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.total_numbers {
      o_prot.write_field_begin(&TFieldIdentifier::new("totalNumbers", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.use_const {
      o_prot.write_field_begin(&TFieldIdentifier::new("useConst", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.const_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("constValue", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TDataGenScanRange
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDataGenScanRange {
  pub numbers_params: Option<TTVFNumbersScanRange>,
}

impl TDataGenScanRange {
  pub fn new<F1>(numbers_params: F1) -> TDataGenScanRange where F1: Into<Option<TTVFNumbersScanRange>> {
    TDataGenScanRange {
      numbers_params: numbers_params.into(),
    }
  }
}

impl TSerializable for TDataGenScanRange {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDataGenScanRange> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TTVFNumbersScanRange> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TTVFNumbersScanRange::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TDataGenScanRange {
      numbers_params: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDataGenScanRange");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.numbers_params {
      o_prot.write_field_begin(&TFieldIdentifier::new("numbers_params", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TIcebergMetadataParams
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TIcebergMetadataParams {
  pub iceberg_query_type: Option<types::TIcebergQueryType>,
  pub catalog: Option<String>,
  pub database: Option<String>,
  pub table: Option<String>,
}

impl TIcebergMetadataParams {
  pub fn new<F1, F2, F3, F4>(iceberg_query_type: F1, catalog: F2, database: F3, table: F4) -> TIcebergMetadataParams where F1: Into<Option<types::TIcebergQueryType>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>> {
    TIcebergMetadataParams {
      iceberg_query_type: iceberg_query_type.into(),
      catalog: catalog.into(),
      database: database.into(),
      table: table.into(),
    }
  }
}

impl TSerializable for TIcebergMetadataParams {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TIcebergMetadataParams> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<types::TIcebergQueryType> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = types::TIcebergQueryType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TIcebergMetadataParams {
      iceberg_query_type: f_1,
      catalog: f_2,
      database: f_3,
      table: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TIcebergMetadataParams");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.iceberg_query_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("iceberg_query_type", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.catalog {
      o_prot.write_field_begin(&TFieldIdentifier::new("catalog", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.database {
      o_prot.write_field_begin(&TFieldIdentifier::new("database", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.table {
      o_prot.write_field_begin(&TFieldIdentifier::new("table", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TPaimonMetadataParams
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TPaimonMetadataParams {
  pub db_name: Option<String>,
  pub tbl_name: Option<String>,
  pub query_type: Option<String>,
  pub ctl_id: Option<i64>,
  pub db_id: Option<i64>,
  pub tbl_id: Option<i64>,
  pub serialized_split: Option<String>,
  pub hadoop_props: Option<BTreeMap<String, String>>,
  pub paimon_props: Option<BTreeMap<String, String>>,
}

impl TPaimonMetadataParams {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9>(db_name: F1, tbl_name: F2, query_type: F3, ctl_id: F4, db_id: F5, tbl_id: F6, serialized_split: F7, hadoop_props: F8, paimon_props: F9) -> TPaimonMetadataParams where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<i64>>, F5: Into<Option<i64>>, F6: Into<Option<i64>>, F7: Into<Option<String>>, F8: Into<Option<BTreeMap<String, String>>>, F9: Into<Option<BTreeMap<String, String>>> {
    TPaimonMetadataParams {
      db_name: db_name.into(),
      tbl_name: tbl_name.into(),
      query_type: query_type.into(),
      ctl_id: ctl_id.into(),
      db_id: db_id.into(),
      tbl_id: tbl_id.into(),
      serialized_split: serialized_split.into(),
      hadoop_props: hadoop_props.into(),
      paimon_props: paimon_props.into(),
    }
  }
}

impl TSerializable for TPaimonMetadataParams {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TPaimonMetadataParams> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i64> = None;
    let mut f_5: Option<i64> = None;
    let mut f_6: Option<i64> = None;
    let mut f_7: Option<String> = None;
    let mut f_8: Option<BTreeMap<String, String>> = None;
    let mut f_9: Option<BTreeMap<String, String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i64()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        8 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_51 = i_prot.read_string()?;
            let map_val_52 = i_prot.read_string()?;
            val.insert(map_key_51, map_val_52);
          }
          i_prot.read_map_end()?;
          f_8 = Some(val);
        },
        9 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_53 = i_prot.read_string()?;
            let map_val_54 = i_prot.read_string()?;
            val.insert(map_key_53, map_val_54);
          }
          i_prot.read_map_end()?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TPaimonMetadataParams {
      db_name: f_1,
      tbl_name: f_2,
      query_type: f_3,
      ctl_id: f_4,
      db_id: f_5,
      tbl_id: f_6,
      serialized_split: f_7,
      hadoop_props: f_8,
      paimon_props: f_9,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TPaimonMetadataParams");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.db_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.tbl_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("tbl_name", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.query_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("query_type", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.ctl_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("ctl_id", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.db_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("db_id", TType::I64, 5))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.tbl_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("tbl_id", TType::I64, 6))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.serialized_split {
      o_prot.write_field_begin(&TFieldIdentifier::new("serialized_split", TType::String, 7))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.hadoop_props {
      o_prot.write_field_begin(&TFieldIdentifier::new("hadoop_props", TType::Map, 8))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.paimon_props {
      o_prot.write_field_begin(&TFieldIdentifier::new("paimon_props", TType::Map, 9))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// THudiMetadataParams
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct THudiMetadataParams {
  pub hudi_query_type: Option<types::THudiQueryType>,
  pub catalog: Option<String>,
  pub database: Option<String>,
  pub table: Option<String>,
}

impl THudiMetadataParams {
  pub fn new<F1, F2, F3, F4>(hudi_query_type: F1, catalog: F2, database: F3, table: F4) -> THudiMetadataParams where F1: Into<Option<types::THudiQueryType>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>> {
    THudiMetadataParams {
      hudi_query_type: hudi_query_type.into(),
      catalog: catalog.into(),
      database: database.into(),
      table: table.into(),
    }
  }
}

impl TSerializable for THudiMetadataParams {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<THudiMetadataParams> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<types::THudiQueryType> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = types::THudiQueryType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = THudiMetadataParams {
      hudi_query_type: f_1,
      catalog: f_2,
      database: f_3,
      table: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("THudiMetadataParams");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.hudi_query_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("hudi_query_type", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.catalog {
      o_prot.write_field_begin(&TFieldIdentifier::new("catalog", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.database {
      o_prot.write_field_begin(&TFieldIdentifier::new("database", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.table {
      o_prot.write_field_begin(&TFieldIdentifier::new("table", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TBackendsMetadataParams
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TBackendsMetadataParams {
  pub cluster_name: Option<String>,
}

impl TBackendsMetadataParams {
  pub fn new<F1>(cluster_name: F1) -> TBackendsMetadataParams where F1: Into<Option<String>> {
    TBackendsMetadataParams {
      cluster_name: cluster_name.into(),
    }
  }
}

impl TSerializable for TBackendsMetadataParams {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TBackendsMetadataParams> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TBackendsMetadataParams {
      cluster_name: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TBackendsMetadataParams");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.cluster_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("cluster_name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TFrontendsMetadataParams
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TFrontendsMetadataParams {
  pub cluster_name: Option<String>,
}

impl TFrontendsMetadataParams {
  pub fn new<F1>(cluster_name: F1) -> TFrontendsMetadataParams where F1: Into<Option<String>> {
    TFrontendsMetadataParams {
      cluster_name: cluster_name.into(),
    }
  }
}

impl TSerializable for TFrontendsMetadataParams {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TFrontendsMetadataParams> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TFrontendsMetadataParams {
      cluster_name: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TFrontendsMetadataParams");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.cluster_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("cluster_name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TMaterializedViewsMetadataParams
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TMaterializedViewsMetadataParams {
  pub database: Option<String>,
  pub current_user_ident: Option<types::TUserIdentity>,
}

impl TMaterializedViewsMetadataParams {
  pub fn new<F1, F2>(database: F1, current_user_ident: F2) -> TMaterializedViewsMetadataParams where F1: Into<Option<String>>, F2: Into<Option<types::TUserIdentity>> {
    TMaterializedViewsMetadataParams {
      database: database.into(),
      current_user_ident: current_user_ident.into(),
    }
  }
}

impl TSerializable for TMaterializedViewsMetadataParams {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TMaterializedViewsMetadataParams> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::TUserIdentity> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = types::TUserIdentity::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TMaterializedViewsMetadataParams {
      database: f_1,
      current_user_ident: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TMaterializedViewsMetadataParams");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.database {
      o_prot.write_field_begin(&TFieldIdentifier::new("database", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.current_user_ident {
      o_prot.write_field_begin(&TFieldIdentifier::new("current_user_ident", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TPartitionsMetadataParams
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TPartitionsMetadataParams {
  pub catalog: Option<String>,
  pub database: Option<String>,
  pub table: Option<String>,
}

impl TPartitionsMetadataParams {
  pub fn new<F1, F2, F3>(catalog: F1, database: F2, table: F3) -> TPartitionsMetadataParams where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>> {
    TPartitionsMetadataParams {
      catalog: catalog.into(),
      database: database.into(),
      table: table.into(),
    }
  }
}

impl TSerializable for TPartitionsMetadataParams {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TPartitionsMetadataParams> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TPartitionsMetadataParams {
      catalog: f_1,
      database: f_2,
      table: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TPartitionsMetadataParams");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.catalog {
      o_prot.write_field_begin(&TFieldIdentifier::new("catalog", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.database {
      o_prot.write_field_begin(&TFieldIdentifier::new("database", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.table {
      o_prot.write_field_begin(&TFieldIdentifier::new("table", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TPartitionValuesMetadataParams
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TPartitionValuesMetadataParams {
  pub catalog: Option<String>,
  pub database: Option<String>,
  pub table: Option<String>,
}

impl TPartitionValuesMetadataParams {
  pub fn new<F1, F2, F3>(catalog: F1, database: F2, table: F3) -> TPartitionValuesMetadataParams where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>> {
    TPartitionValuesMetadataParams {
      catalog: catalog.into(),
      database: database.into(),
      table: table.into(),
    }
  }
}

impl TSerializable for TPartitionValuesMetadataParams {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TPartitionValuesMetadataParams> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TPartitionValuesMetadataParams {
      catalog: f_1,
      database: f_2,
      table: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TPartitionValuesMetadataParams");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.catalog {
      o_prot.write_field_begin(&TFieldIdentifier::new("catalog", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.database {
      o_prot.write_field_begin(&TFieldIdentifier::new("database", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.table {
      o_prot.write_field_begin(&TFieldIdentifier::new("table", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TJobsMetadataParams
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TJobsMetadataParams {
  pub type_: Option<String>,
  pub current_user_ident: Option<types::TUserIdentity>,
}

impl TJobsMetadataParams {
  pub fn new<F1, F2>(type_: F1, current_user_ident: F2) -> TJobsMetadataParams where F1: Into<Option<String>>, F2: Into<Option<types::TUserIdentity>> {
    TJobsMetadataParams {
      type_: type_.into(),
      current_user_ident: current_user_ident.into(),
    }
  }
}

impl TSerializable for TJobsMetadataParams {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TJobsMetadataParams> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::TUserIdentity> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = types::TUserIdentity::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TJobsMetadataParams {
      type_: f_1,
      current_user_ident: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TJobsMetadataParams");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.type_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.current_user_ident {
      o_prot.write_field_begin(&TFieldIdentifier::new("current_user_ident", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TTasksMetadataParams
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTasksMetadataParams {
  pub type_: Option<String>,
  pub current_user_ident: Option<types::TUserIdentity>,
}

impl TTasksMetadataParams {
  pub fn new<F1, F2>(type_: F1, current_user_ident: F2) -> TTasksMetadataParams where F1: Into<Option<String>>, F2: Into<Option<types::TUserIdentity>> {
    TTasksMetadataParams {
      type_: type_.into(),
      current_user_ident: current_user_ident.into(),
    }
  }
}

impl TSerializable for TTasksMetadataParams {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTasksMetadataParams> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<types::TUserIdentity> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = types::TUserIdentity::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TTasksMetadataParams {
      type_: f_1,
      current_user_ident: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TTasksMetadataParams");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.type_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.current_user_ident {
      o_prot.write_field_begin(&TFieldIdentifier::new("current_user_ident", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TQueriesMetadataParams
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TQueriesMetadataParams {
  pub cluster_name: Option<String>,
  pub relay_to_other_fe: Option<bool>,
  pub materialized_views_params: Option<TMaterializedViewsMetadataParams>,
  pub jobs_params: Option<TJobsMetadataParams>,
  pub tasks_params: Option<TTasksMetadataParams>,
  pub partitions_params: Option<TPartitionsMetadataParams>,
  pub partition_values_params: Option<TPartitionValuesMetadataParams>,
}

impl TQueriesMetadataParams {
  pub fn new<F1, F2, F3, F4, F5, F6, F7>(cluster_name: F1, relay_to_other_fe: F2, materialized_views_params: F3, jobs_params: F4, tasks_params: F5, partitions_params: F6, partition_values_params: F7) -> TQueriesMetadataParams where F1: Into<Option<String>>, F2: Into<Option<bool>>, F3: Into<Option<TMaterializedViewsMetadataParams>>, F4: Into<Option<TJobsMetadataParams>>, F5: Into<Option<TTasksMetadataParams>>, F6: Into<Option<TPartitionsMetadataParams>>, F7: Into<Option<TPartitionValuesMetadataParams>> {
    TQueriesMetadataParams {
      cluster_name: cluster_name.into(),
      relay_to_other_fe: relay_to_other_fe.into(),
      materialized_views_params: materialized_views_params.into(),
      jobs_params: jobs_params.into(),
      tasks_params: tasks_params.into(),
      partitions_params: partitions_params.into(),
      partition_values_params: partition_values_params.into(),
    }
  }
}

impl TSerializable for TQueriesMetadataParams {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TQueriesMetadataParams> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<bool> = None;
    let mut f_3: Option<TMaterializedViewsMetadataParams> = None;
    let mut f_4: Option<TJobsMetadataParams> = None;
    let mut f_5: Option<TTasksMetadataParams> = None;
    let mut f_6: Option<TPartitionsMetadataParams> = None;
    let mut f_7: Option<TPartitionValuesMetadataParams> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = TMaterializedViewsMetadataParams::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = TJobsMetadataParams::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = TTasksMetadataParams::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = TPartitionsMetadataParams::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = TPartitionValuesMetadataParams::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TQueriesMetadataParams {
      cluster_name: f_1,
      relay_to_other_fe: f_2,
      materialized_views_params: f_3,
      jobs_params: f_4,
      tasks_params: f_5,
      partitions_params: f_6,
      partition_values_params: f_7,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TQueriesMetadataParams");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.cluster_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("cluster_name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.relay_to_other_fe {
      o_prot.write_field_begin(&TFieldIdentifier::new("relay_to_other_fe", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.materialized_views_params {
      o_prot.write_field_begin(&TFieldIdentifier::new("materialized_views_params", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.jobs_params {
      o_prot.write_field_begin(&TFieldIdentifier::new("jobs_params", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.tasks_params {
      o_prot.write_field_begin(&TFieldIdentifier::new("tasks_params", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.partitions_params {
      o_prot.write_field_begin(&TFieldIdentifier::new("partitions_params", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.partition_values_params {
      o_prot.write_field_begin(&TFieldIdentifier::new("partition_values_params", TType::Struct, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TMetaCacheStatsParams
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TMetaCacheStatsParams {
}

impl TMetaCacheStatsParams {
  pub fn new() -> TMetaCacheStatsParams {
    TMetaCacheStatsParams {}
  }
}

impl TSerializable for TMetaCacheStatsParams {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TMetaCacheStatsParams> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      i_prot.skip(field_ident.field_type)?;
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TMetaCacheStatsParams {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TMetaCacheStatsParams");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TMetaScanRange
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TMetaScanRange {
  pub metadata_type: Option<types::TMetadataType>,
  pub iceberg_params: Option<TIcebergMetadataParams>,
  pub backends_params: Option<TBackendsMetadataParams>,
  pub frontends_params: Option<TFrontendsMetadataParams>,
  pub queries_params: Option<TQueriesMetadataParams>,
  pub materialized_views_params: Option<TMaterializedViewsMetadataParams>,
  pub jobs_params: Option<TJobsMetadataParams>,
  pub tasks_params: Option<TTasksMetadataParams>,
  pub partitions_params: Option<TPartitionsMetadataParams>,
  pub meta_cache_stats_params: Option<TMetaCacheStatsParams>,
  pub partition_values_params: Option<TPartitionValuesMetadataParams>,
  pub hudi_params: Option<THudiMetadataParams>,
  pub paimon_params: Option<TPaimonMetadataParams>,
  pub hadoop_props: Option<BTreeMap<String, String>>,
  pub serialized_table: Option<String>,
  pub serialized_splits: Option<Vec<String>>,
}

impl TMetaScanRange {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15, F16>(metadata_type: F1, iceberg_params: F2, backends_params: F3, frontends_params: F4, queries_params: F5, materialized_views_params: F6, jobs_params: F7, tasks_params: F8, partitions_params: F9, meta_cache_stats_params: F10, partition_values_params: F11, hudi_params: F12, paimon_params: F13, hadoop_props: F14, serialized_table: F15, serialized_splits: F16) -> TMetaScanRange where F1: Into<Option<types::TMetadataType>>, F2: Into<Option<TIcebergMetadataParams>>, F3: Into<Option<TBackendsMetadataParams>>, F4: Into<Option<TFrontendsMetadataParams>>, F5: Into<Option<TQueriesMetadataParams>>, F6: Into<Option<TMaterializedViewsMetadataParams>>, F7: Into<Option<TJobsMetadataParams>>, F8: Into<Option<TTasksMetadataParams>>, F9: Into<Option<TPartitionsMetadataParams>>, F10: Into<Option<TMetaCacheStatsParams>>, F11: Into<Option<TPartitionValuesMetadataParams>>, F12: Into<Option<THudiMetadataParams>>, F13: Into<Option<TPaimonMetadataParams>>, F14: Into<Option<BTreeMap<String, String>>>, F15: Into<Option<String>>, F16: Into<Option<Vec<String>>> {
    TMetaScanRange {
      metadata_type: metadata_type.into(),
      iceberg_params: iceberg_params.into(),
      backends_params: backends_params.into(),
      frontends_params: frontends_params.into(),
      queries_params: queries_params.into(),
      materialized_views_params: materialized_views_params.into(),
      jobs_params: jobs_params.into(),
      tasks_params: tasks_params.into(),
      partitions_params: partitions_params.into(),
      meta_cache_stats_params: meta_cache_stats_params.into(),
      partition_values_params: partition_values_params.into(),
      hudi_params: hudi_params.into(),
      paimon_params: paimon_params.into(),
      hadoop_props: hadoop_props.into(),
      serialized_table: serialized_table.into(),
      serialized_splits: serialized_splits.into(),
    }
  }
}

impl TSerializable for TMetaScanRange {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TMetaScanRange> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<types::TMetadataType> = None;
    let mut f_2: Option<TIcebergMetadataParams> = None;
    let mut f_3: Option<TBackendsMetadataParams> = None;
    let mut f_4: Option<TFrontendsMetadataParams> = None;
    let mut f_5: Option<TQueriesMetadataParams> = None;
    let mut f_6: Option<TMaterializedViewsMetadataParams> = None;
    let mut f_7: Option<TJobsMetadataParams> = None;
    let mut f_8: Option<TTasksMetadataParams> = None;
    let mut f_9: Option<TPartitionsMetadataParams> = None;
    let mut f_10: Option<TMetaCacheStatsParams> = None;
    let mut f_11: Option<TPartitionValuesMetadataParams> = None;
    let mut f_12: Option<THudiMetadataParams> = None;
    let mut f_13: Option<TPaimonMetadataParams> = None;
    let mut f_14: Option<BTreeMap<String, String>> = None;
    let mut f_15: Option<String> = None;
    let mut f_16: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = types::TMetadataType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = TIcebergMetadataParams::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = TBackendsMetadataParams::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = TFrontendsMetadataParams::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = TQueriesMetadataParams::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = TMaterializedViewsMetadataParams::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = TJobsMetadataParams::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        8 => {
          let val = TTasksMetadataParams::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        9 => {
          let val = TPartitionsMetadataParams::read_from_in_protocol(i_prot)?;
          f_9 = Some(val);
        },
        10 => {
          let val = TMetaCacheStatsParams::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        11 => {
          let val = TPartitionValuesMetadataParams::read_from_in_protocol(i_prot)?;
          f_11 = Some(val);
        },
        12 => {
          let val = THudiMetadataParams::read_from_in_protocol(i_prot)?;
          f_12 = Some(val);
        },
        13 => {
          let val = TPaimonMetadataParams::read_from_in_protocol(i_prot)?;
          f_13 = Some(val);
        },
        14 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_55 = i_prot.read_string()?;
            let map_val_56 = i_prot.read_string()?;
            val.insert(map_key_55, map_val_56);
          }
          i_prot.read_map_end()?;
          f_14 = Some(val);
        },
        15 => {
          let val = i_prot.read_string()?;
          f_15 = Some(val);
        },
        16 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_57 = i_prot.read_string()?;
            val.push(list_elem_57);
          }
          i_prot.read_list_end()?;
          f_16 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TMetaScanRange {
      metadata_type: f_1,
      iceberg_params: f_2,
      backends_params: f_3,
      frontends_params: f_4,
      queries_params: f_5,
      materialized_views_params: f_6,
      jobs_params: f_7,
      tasks_params: f_8,
      partitions_params: f_9,
      meta_cache_stats_params: f_10,
      partition_values_params: f_11,
      hudi_params: f_12,
      paimon_params: f_13,
      hadoop_props: f_14,
      serialized_table: f_15,
      serialized_splits: f_16,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TMetaScanRange");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.metadata_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("metadata_type", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.iceberg_params {
      o_prot.write_field_begin(&TFieldIdentifier::new("iceberg_params", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.backends_params {
      o_prot.write_field_begin(&TFieldIdentifier::new("backends_params", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.frontends_params {
      o_prot.write_field_begin(&TFieldIdentifier::new("frontends_params", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.queries_params {
      o_prot.write_field_begin(&TFieldIdentifier::new("queries_params", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.materialized_views_params {
      o_prot.write_field_begin(&TFieldIdentifier::new("materialized_views_params", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.jobs_params {
      o_prot.write_field_begin(&TFieldIdentifier::new("jobs_params", TType::Struct, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.tasks_params {
      o_prot.write_field_begin(&TFieldIdentifier::new("tasks_params", TType::Struct, 8))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.partitions_params {
      o_prot.write_field_begin(&TFieldIdentifier::new("partitions_params", TType::Struct, 9))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.meta_cache_stats_params {
      o_prot.write_field_begin(&TFieldIdentifier::new("meta_cache_stats_params", TType::Struct, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.partition_values_params {
      o_prot.write_field_begin(&TFieldIdentifier::new("partition_values_params", TType::Struct, 11))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.hudi_params {
      o_prot.write_field_begin(&TFieldIdentifier::new("hudi_params", TType::Struct, 12))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.paimon_params {
      o_prot.write_field_begin(&TFieldIdentifier::new("paimon_params", TType::Struct, 13))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.hadoop_props {
      o_prot.write_field_begin(&TFieldIdentifier::new("hadoop_props", TType::Map, 14))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.serialized_table {
      o_prot.write_field_begin(&TFieldIdentifier::new("serialized_table", TType::String, 15))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.serialized_splits {
      o_prot.write_field_begin(&TFieldIdentifier::new("serialized_splits", TType::List, 16))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TScanRange
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TScanRange {
  pub palo_scan_range: Option<TPaloScanRange>,
  pub kudu_scan_token: Option<Vec<u8>>,
  pub broker_scan_range: Option<TBrokerScanRange>,
  pub es_scan_range: Option<TEsScanRange>,
  pub ext_scan_range: Option<TExternalScanRange>,
  pub data_gen_scan_range: Option<TDataGenScanRange>,
  pub meta_scan_range: Option<TMetaScanRange>,
}

impl TScanRange {
  pub fn new<F4, F5, F6, F7, F8, F9, F10>(palo_scan_range: F4, kudu_scan_token: F5, broker_scan_range: F6, es_scan_range: F7, ext_scan_range: F8, data_gen_scan_range: F9, meta_scan_range: F10) -> TScanRange where F4: Into<Option<TPaloScanRange>>, F5: Into<Option<Vec<u8>>>, F6: Into<Option<TBrokerScanRange>>, F7: Into<Option<TEsScanRange>>, F8: Into<Option<TExternalScanRange>>, F9: Into<Option<TDataGenScanRange>>, F10: Into<Option<TMetaScanRange>> {
    TScanRange {
      palo_scan_range: palo_scan_range.into(),
      kudu_scan_token: kudu_scan_token.into(),
      broker_scan_range: broker_scan_range.into(),
      es_scan_range: es_scan_range.into(),
      ext_scan_range: ext_scan_range.into(),
      data_gen_scan_range: data_gen_scan_range.into(),
      meta_scan_range: meta_scan_range.into(),
    }
  }
}

impl TSerializable for TScanRange {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TScanRange> {
    i_prot.read_struct_begin()?;
    let mut f_4: Option<TPaloScanRange> = None;
    let mut f_5: Option<Vec<u8>> = None;
    let mut f_6: Option<TBrokerScanRange> = None;
    let mut f_7: Option<TEsScanRange> = None;
    let mut f_8: Option<TExternalScanRange> = None;
    let mut f_9: Option<TDataGenScanRange> = None;
    let mut f_10: Option<TMetaScanRange> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        4 => {
          let val = TPaloScanRange::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bytes()?;
          f_5 = Some(val);
        },
        6 => {
          let val = TBrokerScanRange::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = TEsScanRange::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        8 => {
          let val = TExternalScanRange::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        9 => {
          let val = TDataGenScanRange::read_from_in_protocol(i_prot)?;
          f_9 = Some(val);
        },
        10 => {
          let val = TMetaScanRange::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TScanRange {
      palo_scan_range: f_4,
      kudu_scan_token: f_5,
      broker_scan_range: f_6,
      es_scan_range: f_7,
      ext_scan_range: f_8,
      data_gen_scan_range: f_9,
      meta_scan_range: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TScanRange");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.palo_scan_range {
      o_prot.write_field_begin(&TFieldIdentifier::new("palo_scan_range", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.kudu_scan_token {
      o_prot.write_field_begin(&TFieldIdentifier::new("kudu_scan_token", TType::String, 5))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.broker_scan_range {
      o_prot.write_field_begin(&TFieldIdentifier::new("broker_scan_range", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.es_scan_range {
      o_prot.write_field_begin(&TFieldIdentifier::new("es_scan_range", TType::Struct, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.ext_scan_range {
      o_prot.write_field_begin(&TFieldIdentifier::new("ext_scan_range", TType::Struct, 8))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.data_gen_scan_range {
      o_prot.write_field_begin(&TFieldIdentifier::new("data_gen_scan_range", TType::Struct, 9))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.meta_scan_range {
      o_prot.write_field_begin(&TFieldIdentifier::new("meta_scan_range", TType::Struct, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TMySQLScanNode
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TMySQLScanNode {
  pub tuple_id: types::TTupleId,
  pub table_name: String,
  pub columns: Vec<String>,
  pub filters: Vec<String>,
}

impl TMySQLScanNode {
  pub fn new(tuple_id: types::TTupleId, table_name: String, columns: Vec<String>, filters: Vec<String>) -> TMySQLScanNode {
    TMySQLScanNode {
      tuple_id,
      table_name,
      columns,
      filters,
    }
  }
}

impl TSerializable for TMySQLScanNode {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TMySQLScanNode> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<types::TTupleId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<String>> = None;
    let mut f_4: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_58 = i_prot.read_string()?;
            val.push(list_elem_58);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_59 = i_prot.read_string()?;
            val.push(list_elem_59);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TMySQLScanNode.tuple_id", &f_1)?;
    verify_required_field_exists("TMySQLScanNode.table_name", &f_2)?;
    verify_required_field_exists("TMySQLScanNode.columns", &f_3)?;
    verify_required_field_exists("TMySQLScanNode.filters", &f_4)?;
    let ret = TMySQLScanNode {
      tuple_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      columns: f_3.expect("auto-generated code should have checked for presence of required fields"),
      filters: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TMySQLScanNode");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tuple_id", TType::I32, 1))?;
    o_prot.write_i32(self.tuple_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 2))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("columns", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.columns.len() as i32))?;
    for e in &self.columns {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("filters", TType::List, 4))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.filters.len() as i32))?;
    for e in &self.filters {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TOdbcScanNode
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TOdbcScanNode {
  pub tuple_id: Option<types::TTupleId>,
  pub table_name: Option<String>,
  pub driver: Option<String>,
  pub type_: Option<types::TOdbcTableType>,
  pub columns: Option<Vec<String>>,
  pub filters: Option<Vec<String>>,
  pub connect_string: Option<String>,
  pub query_string: Option<String>,
}

impl TOdbcScanNode {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8>(tuple_id: F1, table_name: F2, driver: F3, type_: F4, columns: F5, filters: F6, connect_string: F7, query_string: F8) -> TOdbcScanNode where F1: Into<Option<types::TTupleId>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<types::TOdbcTableType>>, F5: Into<Option<Vec<String>>>, F6: Into<Option<Vec<String>>>, F7: Into<Option<String>>, F8: Into<Option<String>> {
    TOdbcScanNode {
      tuple_id: tuple_id.into(),
      table_name: table_name.into(),
      driver: driver.into(),
      type_: type_.into(),
      columns: columns.into(),
      filters: filters.into(),
      connect_string: connect_string.into(),
      query_string: query_string.into(),
    }
  }
}

impl TSerializable for TOdbcScanNode {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TOdbcScanNode> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<types::TTupleId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<types::TOdbcTableType> = None;
    let mut f_5: Option<Vec<String>> = None;
    let mut f_6: Option<Vec<String>> = None;
    let mut f_7: Option<String> = None;
    let mut f_8: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = types::TOdbcTableType::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_60 = i_prot.read_string()?;
            val.push(list_elem_60);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_61 = i_prot.read_string()?;
            val.push(list_elem_61);
          }
          i_prot.read_list_end()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_string()?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TOdbcScanNode {
      tuple_id: f_1,
      table_name: f_2,
      driver: f_3,
      type_: f_4,
      columns: f_5,
      filters: f_6,
      connect_string: f_7,
      query_string: f_8,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TOdbcScanNode");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.tuple_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("tuple_id", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.table_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.driver {
      o_prot.write_field_begin(&TFieldIdentifier::new("driver", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.type_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.columns {
      o_prot.write_field_begin(&TFieldIdentifier::new("columns", TType::List, 5))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.filters {
      o_prot.write_field_begin(&TFieldIdentifier::new("filters", TType::List, 6))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.connect_string {
      o_prot.write_field_begin(&TFieldIdentifier::new("connect_string", TType::String, 7))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.query_string {
      o_prot.write_field_begin(&TFieldIdentifier::new("query_string", TType::String, 8))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TJdbcScanNode
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TJdbcScanNode {
  pub tuple_id: Option<types::TTupleId>,
  pub table_name: Option<String>,
  pub query_string: Option<String>,
  pub table_type: Option<types::TOdbcTableType>,
  pub is_tvf: Option<bool>,
}

impl TJdbcScanNode {
  pub fn new<F1, F2, F3, F4, F5>(tuple_id: F1, table_name: F2, query_string: F3, table_type: F4, is_tvf: F5) -> TJdbcScanNode where F1: Into<Option<types::TTupleId>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<types::TOdbcTableType>>, F5: Into<Option<bool>> {
    TJdbcScanNode {
      tuple_id: tuple_id.into(),
      table_name: table_name.into(),
      query_string: query_string.into(),
      table_type: table_type.into(),
      is_tvf: is_tvf.into(),
    }
  }
}

impl TSerializable for TJdbcScanNode {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TJdbcScanNode> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<types::TTupleId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<types::TOdbcTableType> = None;
    let mut f_5: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = types::TOdbcTableType::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TJdbcScanNode {
      tuple_id: f_1,
      table_name: f_2,
      query_string: f_3,
      table_type: f_4,
      is_tvf: f_5,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TJdbcScanNode");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.tuple_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("tuple_id", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.table_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.query_string {
      o_prot.write_field_begin(&TFieldIdentifier::new("query_string", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.table_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_type", TType::I32, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_tvf {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_tvf", TType::Bool, 5))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TBrokerScanNode
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TBrokerScanNode {
  pub tuple_id: types::TTupleId,
  pub partition_exprs: Option<Vec<exprs::TExpr>>,
  pub partition_infos: Option<Vec<partitions::TRangePartition>>,
  pub pre_filter_exprs: Option<Vec<exprs::TExpr>>,
}

impl TBrokerScanNode {
  pub fn new<F2, F3, F4>(tuple_id: types::TTupleId, partition_exprs: F2, partition_infos: F3, pre_filter_exprs: F4) -> TBrokerScanNode where F2: Into<Option<Vec<exprs::TExpr>>>, F3: Into<Option<Vec<partitions::TRangePartition>>>, F4: Into<Option<Vec<exprs::TExpr>>> {
    TBrokerScanNode {
      tuple_id,
      partition_exprs: partition_exprs.into(),
      partition_infos: partition_infos.into(),
      pre_filter_exprs: pre_filter_exprs.into(),
    }
  }
}

impl TSerializable for TBrokerScanNode {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TBrokerScanNode> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<types::TTupleId> = None;
    let mut f_2: Option<Vec<exprs::TExpr>> = None;
    let mut f_3: Option<Vec<partitions::TRangePartition>> = None;
    let mut f_4: Option<Vec<exprs::TExpr>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<exprs::TExpr> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_62 = exprs::TExpr::read_from_in_protocol(i_prot)?;
            val.push(list_elem_62);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<partitions::TRangePartition> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_63 = partitions::TRangePartition::read_from_in_protocol(i_prot)?;
            val.push(list_elem_63);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<exprs::TExpr> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_64 = exprs::TExpr::read_from_in_protocol(i_prot)?;
            val.push(list_elem_64);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TBrokerScanNode.tuple_id", &f_1)?;
    let ret = TBrokerScanNode {
      tuple_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      partition_exprs: f_2,
      partition_infos: f_3,
      pre_filter_exprs: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TBrokerScanNode");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tuple_id", TType::I32, 1))?;
    o_prot.write_i32(self.tuple_id)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.partition_exprs {
      o_prot.write_field_begin(&TFieldIdentifier::new("partition_exprs", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.partition_infos {
      o_prot.write_field_begin(&TFieldIdentifier::new("partition_infos", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.pre_filter_exprs {
      o_prot.write_field_begin(&TFieldIdentifier::new("pre_filter_exprs", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TFileScanNode
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TFileScanNode {
  pub tuple_id: Option<types::TTupleId>,
  pub table_name: Option<String>,
}

impl TFileScanNode {
  pub fn new<F1, F2>(tuple_id: F1, table_name: F2) -> TFileScanNode where F1: Into<Option<types::TTupleId>>, F2: Into<Option<String>> {
    TFileScanNode {
      tuple_id: tuple_id.into(),
      table_name: table_name.into(),
    }
  }
}

impl TSerializable for TFileScanNode {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TFileScanNode> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<types::TTupleId> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TFileScanNode {
      tuple_id: f_1,
      table_name: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TFileScanNode");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.tuple_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("tuple_id", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.table_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TEsScanNode
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TEsScanNode {
  pub tuple_id: types::TTupleId,
  pub properties: Option<BTreeMap<String, String>>,
  pub docvalue_context: Option<BTreeMap<String, String>>,
  pub fields_context: Option<BTreeMap<String, String>>,
}

impl TEsScanNode {
  pub fn new<F2, F3, F4>(tuple_id: types::TTupleId, properties: F2, docvalue_context: F3, fields_context: F4) -> TEsScanNode where F2: Into<Option<BTreeMap<String, String>>>, F3: Into<Option<BTreeMap<String, String>>>, F4: Into<Option<BTreeMap<String, String>>> {
    TEsScanNode {
      tuple_id,
      properties: properties.into(),
      docvalue_context: docvalue_context.into(),
      fields_context: fields_context.into(),
    }
  }
}

impl TSerializable for TEsScanNode {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TEsScanNode> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<types::TTupleId> = None;
    let mut f_2: Option<BTreeMap<String, String>> = None;
    let mut f_3: Option<BTreeMap<String, String>> = None;
    let mut f_4: Option<BTreeMap<String, String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_65 = i_prot.read_string()?;
            let map_val_66 = i_prot.read_string()?;
            val.insert(map_key_65, map_val_66);
          }
          i_prot.read_map_end()?;
          f_2 = Some(val);
        },
        3 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_67 = i_prot.read_string()?;
            let map_val_68 = i_prot.read_string()?;
            val.insert(map_key_67, map_val_68);
          }
          i_prot.read_map_end()?;
          f_3 = Some(val);
        },
        4 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_69 = i_prot.read_string()?;
            let map_val_70 = i_prot.read_string()?;
            val.insert(map_key_69, map_val_70);
          }
          i_prot.read_map_end()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TEsScanNode.tuple_id", &f_1)?;
    let ret = TEsScanNode {
      tuple_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      properties: f_2,
      docvalue_context: f_3,
      fields_context: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TEsScanNode");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tuple_id", TType::I32, 1))?;
    o_prot.write_i32(self.tuple_id)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.properties {
      o_prot.write_field_begin(&TFieldIdentifier::new("properties", TType::Map, 2))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.docvalue_context {
      o_prot.write_field_begin(&TFieldIdentifier::new("docvalue_context", TType::Map, 3))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.fields_context {
      o_prot.write_field_begin(&TFieldIdentifier::new("fields_context", TType::Map, 4))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TMiniLoadEtlFunction
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TMiniLoadEtlFunction {
  pub function_name: String,
  pub param_column_index: i32,
}

impl TMiniLoadEtlFunction {
  pub fn new(function_name: String, param_column_index: i32) -> TMiniLoadEtlFunction {
    TMiniLoadEtlFunction {
      function_name,
      param_column_index,
    }
  }
}

impl TSerializable for TMiniLoadEtlFunction {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TMiniLoadEtlFunction> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TMiniLoadEtlFunction.function_name", &f_1)?;
    verify_required_field_exists("TMiniLoadEtlFunction.param_column_index", &f_2)?;
    let ret = TMiniLoadEtlFunction {
      function_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      param_column_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TMiniLoadEtlFunction");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("function_name", TType::String, 1))?;
    o_prot.write_string(&self.function_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("param_column_index", TType::I32, 2))?;
    o_prot.write_i32(self.param_column_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TCsvScanNode
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TCsvScanNode {
  pub tuple_id: types::TTupleId,
  pub file_paths: Vec<String>,
  pub column_separator: Option<String>,
  pub line_delimiter: Option<String>,
  pub column_type_mapping: Option<BTreeMap<String, types::TColumnType>>,
  pub columns: Option<Vec<String>>,
  pub unspecified_columns: Option<Vec<String>>,
  pub default_values: Option<Vec<String>>,
  pub max_filter_ratio: Option<OrderedFloat<f64>>,
  pub column_function_mapping: Option<BTreeMap<String, TMiniLoadEtlFunction>>,
}

impl TCsvScanNode {
  pub fn new<F3, F4, F5, F6, F7, F8, F9, F10>(tuple_id: types::TTupleId, file_paths: Vec<String>, column_separator: F3, line_delimiter: F4, column_type_mapping: F5, columns: F6, unspecified_columns: F7, default_values: F8, max_filter_ratio: F9, column_function_mapping: F10) -> TCsvScanNode where F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<BTreeMap<String, types::TColumnType>>>, F6: Into<Option<Vec<String>>>, F7: Into<Option<Vec<String>>>, F8: Into<Option<Vec<String>>>, F9: Into<Option<OrderedFloat<f64>>>, F10: Into<Option<BTreeMap<String, TMiniLoadEtlFunction>>> {
    TCsvScanNode {
      tuple_id,
      file_paths,
      column_separator: column_separator.into(),
      line_delimiter: line_delimiter.into(),
      column_type_mapping: column_type_mapping.into(),
      columns: columns.into(),
      unspecified_columns: unspecified_columns.into(),
      default_values: default_values.into(),
      max_filter_ratio: max_filter_ratio.into(),
      column_function_mapping: column_function_mapping.into(),
    }
  }
}

impl TSerializable for TCsvScanNode {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCsvScanNode> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<types::TTupleId> = None;
    let mut f_2: Option<Vec<String>> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<BTreeMap<String, types::TColumnType>> = None;
    let mut f_6: Option<Vec<String>> = None;
    let mut f_7: Option<Vec<String>> = None;
    let mut f_8: Option<Vec<String>> = None;
    let mut f_9: Option<OrderedFloat<f64>> = None;
    let mut f_10: Option<BTreeMap<String, TMiniLoadEtlFunction>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_71 = i_prot.read_string()?;
            val.push(list_elem_71);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, types::TColumnType> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_72 = i_prot.read_string()?;
            let map_val_73 = types::TColumnType::read_from_in_protocol(i_prot)?;
            val.insert(map_key_72, map_val_73);
          }
          i_prot.read_map_end()?;
          f_5 = Some(val);
        },
        6 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_74 = i_prot.read_string()?;
            val.push(list_elem_74);
          }
          i_prot.read_list_end()?;
          f_6 = Some(val);
        },
        7 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_75 = i_prot.read_string()?;
            val.push(list_elem_75);
          }
          i_prot.read_list_end()?;
          f_7 = Some(val);
        },
        8 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_76 = i_prot.read_string()?;
            val.push(list_elem_76);
          }
          i_prot.read_list_end()?;
          f_8 = Some(val);
        },
        9 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_9 = Some(val);
        },
        10 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, TMiniLoadEtlFunction> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_77 = i_prot.read_string()?;
            let map_val_78 = TMiniLoadEtlFunction::read_from_in_protocol(i_prot)?;
            val.insert(map_key_77, map_val_78);
          }
          i_prot.read_map_end()?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TCsvScanNode.tuple_id", &f_1)?;
    verify_required_field_exists("TCsvScanNode.file_paths", &f_2)?;
    let ret = TCsvScanNode {
      tuple_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      file_paths: f_2.expect("auto-generated code should have checked for presence of required fields"),
      column_separator: f_3,
      line_delimiter: f_4,
      column_type_mapping: f_5,
      columns: f_6,
      unspecified_columns: f_7,
      default_values: f_8,
      max_filter_ratio: f_9,
      column_function_mapping: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TCsvScanNode");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tuple_id", TType::I32, 1))?;
    o_prot.write_i32(self.tuple_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("file_paths", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.file_paths.len() as i32))?;
    for e in &self.file_paths {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.column_separator {
      o_prot.write_field_begin(&TFieldIdentifier::new("column_separator", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.line_delimiter {
      o_prot.write_field_begin(&TFieldIdentifier::new("line_delimiter", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.column_type_mapping {
      o_prot.write_field_begin(&TFieldIdentifier::new("column_type_mapping", TType::Map, 5))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Struct, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        v.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.columns {
      o_prot.write_field_begin(&TFieldIdentifier::new("columns", TType::List, 6))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.unspecified_columns {
      o_prot.write_field_begin(&TFieldIdentifier::new("unspecified_columns", TType::List, 7))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.default_values {
      o_prot.write_field_begin(&TFieldIdentifier::new("default_values", TType::List, 8))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.max_filter_ratio {
      o_prot.write_field_begin(&TFieldIdentifier::new("max_filter_ratio", TType::Double, 9))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.column_function_mapping {
      o_prot.write_field_begin(&TFieldIdentifier::new("column_function_mapping", TType::Map, 10))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Struct, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        v.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSchemaScanNode
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSchemaScanNode {
  pub tuple_id: types::TTupleId,
  pub table_name: String,
  pub db: Option<String>,
  pub table: Option<String>,
  pub wild: Option<String>,
  pub user: Option<String>,
  pub ip: Option<String>,
  pub port: Option<i32>,
  pub thread_id: Option<i64>,
  pub user_ip: Option<String>,
  pub current_user_ident: Option<types::TUserIdentity>,
  pub show_hidden_cloumns: Option<bool>,
  pub catalog: Option<String>,
  pub fe_addr_list: Option<Vec<types::TNetworkAddress>>,
  pub frontend_conjuncts: Option<String>,
}

impl TSchemaScanNode {
  pub fn new<F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F14, F15, F16>(tuple_id: types::TTupleId, table_name: String, db: F3, table: F4, wild: F5, user: F6, ip: F7, port: F8, thread_id: F9, user_ip: F10, current_user_ident: F11, show_hidden_cloumns: F12, catalog: F14, fe_addr_list: F15, frontend_conjuncts: F16) -> TSchemaScanNode where F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<String>>, F6: Into<Option<String>>, F7: Into<Option<String>>, F8: Into<Option<i32>>, F9: Into<Option<i64>>, F10: Into<Option<String>>, F11: Into<Option<types::TUserIdentity>>, F12: Into<Option<bool>>, F14: Into<Option<String>>, F15: Into<Option<Vec<types::TNetworkAddress>>>, F16: Into<Option<String>> {
    TSchemaScanNode {
      tuple_id,
      table_name,
      db: db.into(),
      table: table.into(),
      wild: wild.into(),
      user: user.into(),
      ip: ip.into(),
      port: port.into(),
      thread_id: thread_id.into(),
      user_ip: user_ip.into(),
      current_user_ident: current_user_ident.into(),
      show_hidden_cloumns: show_hidden_cloumns.into(),
      catalog: catalog.into(),
      fe_addr_list: fe_addr_list.into(),
      frontend_conjuncts: frontend_conjuncts.into(),
    }
  }
}

impl TSerializable for TSchemaScanNode {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSchemaScanNode> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<types::TTupleId> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<String> = None;
    let mut f_7: Option<String> = None;
    let mut f_8: Option<i32> = None;
    let mut f_9: Option<i64> = None;
    let mut f_10: Option<String> = None;
    let mut f_11: Option<types::TUserIdentity> = None;
    let mut f_12: Option<bool> = None;
    let mut f_14: Option<String> = None;
    let mut f_15: Option<Vec<types::TNetworkAddress>> = None;
    let mut f_16: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i32()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_i64()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        11 => {
          let val = types::TUserIdentity::read_from_in_protocol(i_prot)?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_bool()?;
          f_12 = Some(val);
        },
        14 => {
          let val = i_prot.read_string()?;
          f_14 = Some(val);
        },
        15 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::TNetworkAddress> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_79 = types::TNetworkAddress::read_from_in_protocol(i_prot)?;
            val.push(list_elem_79);
          }
          i_prot.read_list_end()?;
          f_15 = Some(val);
        },
        16 => {
          let val = i_prot.read_string()?;
          f_16 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSchemaScanNode.tuple_id", &f_1)?;
    verify_required_field_exists("TSchemaScanNode.table_name", &f_2)?;
    let ret = TSchemaScanNode {
      tuple_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      db: f_3,
      table: f_4,
      wild: f_5,
      user: f_6,
      ip: f_7,
      port: f_8,
      thread_id: f_9,
      user_ip: f_10,
      current_user_ident: f_11,
      show_hidden_cloumns: f_12,
      catalog: f_14,
      fe_addr_list: f_15,
      frontend_conjuncts: f_16,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSchemaScanNode");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tuple_id", TType::I32, 1))?;
    o_prot.write_i32(self.tuple_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 2))?;
    o_prot.write_string(&self.table_name)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.db {
      o_prot.write_field_begin(&TFieldIdentifier::new("db", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.table {
      o_prot.write_field_begin(&TFieldIdentifier::new("table", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.wild {
      o_prot.write_field_begin(&TFieldIdentifier::new("wild", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user {
      o_prot.write_field_begin(&TFieldIdentifier::new("user", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.ip {
      o_prot.write_field_begin(&TFieldIdentifier::new("ip", TType::String, 7))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.port {
      o_prot.write_field_begin(&TFieldIdentifier::new("port", TType::I32, 8))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.thread_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("thread_id", TType::I64, 9))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_ip {
      o_prot.write_field_begin(&TFieldIdentifier::new("user_ip", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.current_user_ident {
      o_prot.write_field_begin(&TFieldIdentifier::new("current_user_ident", TType::Struct, 11))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.show_hidden_cloumns {
      o_prot.write_field_begin(&TFieldIdentifier::new("show_hidden_cloumns", TType::Bool, 12))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.catalog {
      o_prot.write_field_begin(&TFieldIdentifier::new("catalog", TType::String, 14))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.fe_addr_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("fe_addr_list", TType::List, 15))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.frontend_conjuncts {
      o_prot.write_field_begin(&TFieldIdentifier::new("frontend_conjuncts", TType::String, 16))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TMetaScanNode
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TMetaScanNode {
  pub tuple_id: types::TTupleId,
  pub metadata_type: Option<types::TMetadataType>,
  pub current_user_ident: Option<types::TUserIdentity>,
}

impl TMetaScanNode {
  pub fn new<F2, F3>(tuple_id: types::TTupleId, metadata_type: F2, current_user_ident: F3) -> TMetaScanNode where F2: Into<Option<types::TMetadataType>>, F3: Into<Option<types::TUserIdentity>> {
    TMetaScanNode {
      tuple_id,
      metadata_type: metadata_type.into(),
      current_user_ident: current_user_ident.into(),
    }
  }
}

impl TSerializable for TMetaScanNode {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TMetaScanNode> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<types::TTupleId> = None;
    let mut f_2: Option<types::TMetadataType> = None;
    let mut f_3: Option<types::TUserIdentity> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = types::TMetadataType::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = types::TUserIdentity::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TMetaScanNode.tuple_id", &f_1)?;
    let ret = TMetaScanNode {
      tuple_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      metadata_type: f_2,
      current_user_ident: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TMetaScanNode");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tuple_id", TType::I32, 1))?;
    o_prot.write_i32(self.tuple_id)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.metadata_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("metadata_type", TType::I32, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.current_user_ident {
      o_prot.write_field_begin(&TFieldIdentifier::new("current_user_ident", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TTestExternalScanNode
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTestExternalScanNode {
  pub tuple_id: Option<types::TTupleId>,
  pub table_name: Option<String>,
}

impl TTestExternalScanNode {
  pub fn new<F1, F2>(tuple_id: F1, table_name: F2) -> TTestExternalScanNode where F1: Into<Option<types::TTupleId>>, F2: Into<Option<String>> {
    TTestExternalScanNode {
      tuple_id: tuple_id.into(),
      table_name: table_name.into(),
    }
  }
}

impl TSerializable for TTestExternalScanNode {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTestExternalScanNode> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<types::TTupleId> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TTestExternalScanNode {
      tuple_id: f_1,
      table_name: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TTestExternalScanNode");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.tuple_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("tuple_id", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.table_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSortInfo
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSortInfo {
  pub ordering_exprs: Vec<exprs::TExpr>,
  pub is_asc_order: Vec<bool>,
  pub nulls_first: Vec<bool>,
  pub sort_tuple_slot_exprs: Option<Vec<exprs::TExpr>>,
  pub use_two_phase_read: Option<bool>,
}

impl TSortInfo {
  pub fn new<F4, F6>(ordering_exprs: Vec<exprs::TExpr>, is_asc_order: Vec<bool>, nulls_first: Vec<bool>, sort_tuple_slot_exprs: F4, use_two_phase_read: F6) -> TSortInfo where F4: Into<Option<Vec<exprs::TExpr>>>, F6: Into<Option<bool>> {
    TSortInfo {
      ordering_exprs,
      is_asc_order,
      nulls_first,
      sort_tuple_slot_exprs: sort_tuple_slot_exprs.into(),
      use_two_phase_read: use_two_phase_read.into(),
    }
  }
}

impl TSerializable for TSortInfo {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSortInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<exprs::TExpr>> = None;
    let mut f_2: Option<Vec<bool>> = None;
    let mut f_3: Option<Vec<bool>> = None;
    let mut f_4: Option<Vec<exprs::TExpr>> = None;
    let mut f_6: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<exprs::TExpr> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_80 = exprs::TExpr::read_from_in_protocol(i_prot)?;
            val.push(list_elem_80);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<bool> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_81 = i_prot.read_bool()?;
            val.push(list_elem_81);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<bool> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_82 = i_prot.read_bool()?;
            val.push(list_elem_82);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<exprs::TExpr> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_83 = exprs::TExpr::read_from_in_protocol(i_prot)?;
            val.push(list_elem_83);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSortInfo.ordering_exprs", &f_1)?;
    verify_required_field_exists("TSortInfo.is_asc_order", &f_2)?;
    verify_required_field_exists("TSortInfo.nulls_first", &f_3)?;
    let ret = TSortInfo {
      ordering_exprs: f_1.expect("auto-generated code should have checked for presence of required fields"),
      is_asc_order: f_2.expect("auto-generated code should have checked for presence of required fields"),
      nulls_first: f_3.expect("auto-generated code should have checked for presence of required fields"),
      sort_tuple_slot_exprs: f_4,
      use_two_phase_read: f_6,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSortInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("ordering_exprs", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.ordering_exprs.len() as i32))?;
    for e in &self.ordering_exprs {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("is_asc_order", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Bool, self.is_asc_order.len() as i32))?;
    for e in &self.is_asc_order {
      o_prot.write_bool(*e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("nulls_first", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Bool, self.nulls_first.len() as i32))?;
    for e in &self.nulls_first {
      o_prot.write_bool(*e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.sort_tuple_slot_exprs {
      o_prot.write_field_begin(&TFieldIdentifier::new("sort_tuple_slot_exprs", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.use_two_phase_read {
      o_prot.write_field_begin(&TFieldIdentifier::new("use_two_phase_read", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TOlapScanNode
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TOlapScanNode {
  pub tuple_id: types::TTupleId,
  pub key_column_name: Vec<String>,
  pub key_column_type: Vec<types::TPrimitiveType>,
  pub is_preaggregation: bool,
  pub sort_column: Option<String>,
  pub key_type: Option<types::TKeysType>,
  pub table_name: Option<String>,
  pub columns_desc: Option<Vec<descriptors::TColumn>>,
  pub sort_info: Option<TSortInfo>,
  pub sort_limit: Option<i64>,
  pub enable_unique_key_merge_on_write: Option<bool>,
  pub push_down_agg_type_opt: Option<TPushAggOp>,
  pub use_topn_opt: Option<bool>,
  pub indexes_desc: Option<Vec<descriptors::TOlapTableIndex>>,
  pub output_column_unique_ids: Option<BTreeSet<i32>>,
  pub distribute_column_ids: Option<Vec<i32>>,
  pub schema_version: Option<i32>,
  pub topn_filter_source_node_ids: Option<Vec<i32>>,
  pub score_sort_info: Option<TSortInfo>,
  pub score_sort_limit: Option<i64>,
  pub ann_sort_info: Option<TSortInfo>,
  pub ann_sort_limit: Option<i64>,
}

impl TOlapScanNode {
  pub fn new<F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15, F16, F17, F18, F19, F20, F21, F22>(tuple_id: types::TTupleId, key_column_name: Vec<String>, key_column_type: Vec<types::TPrimitiveType>, is_preaggregation: bool, sort_column: F5, key_type: F6, table_name: F7, columns_desc: F8, sort_info: F9, sort_limit: F10, enable_unique_key_merge_on_write: F11, push_down_agg_type_opt: F12, use_topn_opt: F13, indexes_desc: F14, output_column_unique_ids: F15, distribute_column_ids: F16, schema_version: F17, topn_filter_source_node_ids: F18, score_sort_info: F19, score_sort_limit: F20, ann_sort_info: F21, ann_sort_limit: F22) -> TOlapScanNode where F5: Into<Option<String>>, F6: Into<Option<types::TKeysType>>, F7: Into<Option<String>>, F8: Into<Option<Vec<descriptors::TColumn>>>, F9: Into<Option<TSortInfo>>, F10: Into<Option<i64>>, F11: Into<Option<bool>>, F12: Into<Option<TPushAggOp>>, F13: Into<Option<bool>>, F14: Into<Option<Vec<descriptors::TOlapTableIndex>>>, F15: Into<Option<BTreeSet<i32>>>, F16: Into<Option<Vec<i32>>>, F17: Into<Option<i32>>, F18: Into<Option<Vec<i32>>>, F19: Into<Option<TSortInfo>>, F20: Into<Option<i64>>, F21: Into<Option<TSortInfo>>, F22: Into<Option<i64>> {
    TOlapScanNode {
      tuple_id,
      key_column_name,
      key_column_type,
      is_preaggregation,
      sort_column: sort_column.into(),
      key_type: key_type.into(),
      table_name: table_name.into(),
      columns_desc: columns_desc.into(),
      sort_info: sort_info.into(),
      sort_limit: sort_limit.into(),
      enable_unique_key_merge_on_write: enable_unique_key_merge_on_write.into(),
      push_down_agg_type_opt: push_down_agg_type_opt.into(),
      use_topn_opt: use_topn_opt.into(),
      indexes_desc: indexes_desc.into(),
      output_column_unique_ids: output_column_unique_ids.into(),
      distribute_column_ids: distribute_column_ids.into(),
      schema_version: schema_version.into(),
      topn_filter_source_node_ids: topn_filter_source_node_ids.into(),
      score_sort_info: score_sort_info.into(),
      score_sort_limit: score_sort_limit.into(),
      ann_sort_info: ann_sort_info.into(),
      ann_sort_limit: ann_sort_limit.into(),
    }
  }
}

impl TSerializable for TOlapScanNode {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TOlapScanNode> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<types::TTupleId> = None;
    let mut f_2: Option<Vec<String>> = None;
    let mut f_3: Option<Vec<types::TPrimitiveType>> = None;
    let mut f_4: Option<bool> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<types::TKeysType> = None;
    let mut f_7: Option<String> = None;
    let mut f_8: Option<Vec<descriptors::TColumn>> = None;
    let mut f_9: Option<TSortInfo> = None;
    let mut f_10: Option<i64> = None;
    let mut f_11: Option<bool> = None;
    let mut f_12: Option<TPushAggOp> = None;
    let mut f_13: Option<bool> = None;
    let mut f_14: Option<Vec<descriptors::TOlapTableIndex>> = None;
    let mut f_15: Option<BTreeSet<i32>> = None;
    let mut f_16: Option<Vec<i32>> = None;
    let mut f_17: Option<i32> = None;
    let mut f_18: Option<Vec<i32>> = None;
    let mut f_19: Option<TSortInfo> = None;
    let mut f_20: Option<i64> = None;
    let mut f_21: Option<TSortInfo> = None;
    let mut f_22: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_84 = i_prot.read_string()?;
            val.push(list_elem_84);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::TPrimitiveType> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_85 = types::TPrimitiveType::read_from_in_protocol(i_prot)?;
            val.push(list_elem_85);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = types::TKeysType::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        8 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<descriptors::TColumn> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_86 = descriptors::TColumn::read_from_in_protocol(i_prot)?;
            val.push(list_elem_86);
          }
          i_prot.read_list_end()?;
          f_8 = Some(val);
        },
        9 => {
          let val = TSortInfo::read_from_in_protocol(i_prot)?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_i64()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_bool()?;
          f_11 = Some(val);
        },
        12 => {
          let val = TPushAggOp::read_from_in_protocol(i_prot)?;
          f_12 = Some(val);
        },
        13 => {
          let val = i_prot.read_bool()?;
          f_13 = Some(val);
        },
        14 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<descriptors::TOlapTableIndex> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_87 = descriptors::TOlapTableIndex::read_from_in_protocol(i_prot)?;
            val.push(list_elem_87);
          }
          i_prot.read_list_end()?;
          f_14 = Some(val);
        },
        15 => {
          let set_ident = i_prot.read_set_begin()?;
          let mut val: BTreeSet<i32> = BTreeSet::new();
          for _ in 0..set_ident.size {
            let set_elem_88 = i_prot.read_i32()?;
            val.insert(set_elem_88);
          }
          i_prot.read_set_end()?;
          f_15 = Some(val);
        },
        16 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_89 = i_prot.read_i32()?;
            val.push(list_elem_89);
          }
          i_prot.read_list_end()?;
          f_16 = Some(val);
        },
        17 => {
          let val = i_prot.read_i32()?;
          f_17 = Some(val);
        },
        18 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_90 = i_prot.read_i32()?;
            val.push(list_elem_90);
          }
          i_prot.read_list_end()?;
          f_18 = Some(val);
        },
        19 => {
          let val = TSortInfo::read_from_in_protocol(i_prot)?;
          f_19 = Some(val);
        },
        20 => {
          let val = i_prot.read_i64()?;
          f_20 = Some(val);
        },
        21 => {
          let val = TSortInfo::read_from_in_protocol(i_prot)?;
          f_21 = Some(val);
        },
        22 => {
          let val = i_prot.read_i64()?;
          f_22 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TOlapScanNode.tuple_id", &f_1)?;
    verify_required_field_exists("TOlapScanNode.key_column_name", &f_2)?;
    verify_required_field_exists("TOlapScanNode.key_column_type", &f_3)?;
    verify_required_field_exists("TOlapScanNode.is_preaggregation", &f_4)?;
    let ret = TOlapScanNode {
      tuple_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      key_column_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      key_column_type: f_3.expect("auto-generated code should have checked for presence of required fields"),
      is_preaggregation: f_4.expect("auto-generated code should have checked for presence of required fields"),
      sort_column: f_5,
      key_type: f_6,
      table_name: f_7,
      columns_desc: f_8,
      sort_info: f_9,
      sort_limit: f_10,
      enable_unique_key_merge_on_write: f_11,
      push_down_agg_type_opt: f_12,
      use_topn_opt: f_13,
      indexes_desc: f_14,
      output_column_unique_ids: f_15,
      distribute_column_ids: f_16,
      schema_version: f_17,
      topn_filter_source_node_ids: f_18,
      score_sort_info: f_19,
      score_sort_limit: f_20,
      ann_sort_info: f_21,
      ann_sort_limit: f_22,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TOlapScanNode");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tuple_id", TType::I32, 1))?;
    o_prot.write_i32(self.tuple_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("key_column_name", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.key_column_name.len() as i32))?;
    for e in &self.key_column_name {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("key_column_type", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I32, self.key_column_type.len() as i32))?;
    for e in &self.key_column_type {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("is_preaggregation", TType::Bool, 4))?;
    o_prot.write_bool(self.is_preaggregation)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.sort_column {
      o_prot.write_field_begin(&TFieldIdentifier::new("sort_column", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.key_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("keyType", TType::I32, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.table_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 7))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.columns_desc {
      o_prot.write_field_begin(&TFieldIdentifier::new("columns_desc", TType::List, 8))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.sort_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("sort_info", TType::Struct, 9))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.sort_limit {
      o_prot.write_field_begin(&TFieldIdentifier::new("sort_limit", TType::I64, 10))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_unique_key_merge_on_write {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_unique_key_merge_on_write", TType::Bool, 11))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.push_down_agg_type_opt {
      o_prot.write_field_begin(&TFieldIdentifier::new("push_down_agg_type_opt", TType::I32, 12))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.use_topn_opt {
      o_prot.write_field_begin(&TFieldIdentifier::new("use_topn_opt", TType::Bool, 13))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.indexes_desc {
      o_prot.write_field_begin(&TFieldIdentifier::new("indexes_desc", TType::List, 14))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.output_column_unique_ids {
      o_prot.write_field_begin(&TFieldIdentifier::new("output_column_unique_ids", TType::Set, 15))?;
      o_prot.write_set_begin(&TSetIdentifier::new(TType::I32, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i32(*e)?;
      }
      o_prot.write_set_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.distribute_column_ids {
      o_prot.write_field_begin(&TFieldIdentifier::new("distribute_column_ids", TType::List, 16))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I32, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i32(*e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.schema_version {
      o_prot.write_field_begin(&TFieldIdentifier::new("schema_version", TType::I32, 17))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.topn_filter_source_node_ids {
      o_prot.write_field_begin(&TFieldIdentifier::new("topn_filter_source_node_ids", TType::List, 18))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I32, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i32(*e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.score_sort_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("score_sort_info", TType::Struct, 19))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.score_sort_limit {
      o_prot.write_field_begin(&TFieldIdentifier::new("score_sort_limit", TType::I64, 20))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.ann_sort_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("ann_sort_info", TType::Struct, 21))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.ann_sort_limit {
      o_prot.write_field_begin(&TFieldIdentifier::new("ann_sort_limit", TType::I64, 22))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TEqJoinCondition
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TEqJoinCondition {
  pub left: exprs::TExpr,
  pub right: exprs::TExpr,
  pub opcode: Option<opcodes::TExprOpcode>,
}

impl TEqJoinCondition {
  pub fn new<F3>(left: exprs::TExpr, right: exprs::TExpr, opcode: F3) -> TEqJoinCondition where F3: Into<Option<opcodes::TExprOpcode>> {
    TEqJoinCondition {
      left,
      right,
      opcode: opcode.into(),
    }
  }
}

impl TSerializable for TEqJoinCondition {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TEqJoinCondition> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<exprs::TExpr> = None;
    let mut f_2: Option<exprs::TExpr> = None;
    let mut f_3: Option<opcodes::TExprOpcode> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = exprs::TExpr::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = exprs::TExpr::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = opcodes::TExprOpcode::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TEqJoinCondition.left", &f_1)?;
    verify_required_field_exists("TEqJoinCondition.right", &f_2)?;
    let ret = TEqJoinCondition {
      left: f_1.expect("auto-generated code should have checked for presence of required fields"),
      right: f_2.expect("auto-generated code should have checked for presence of required fields"),
      opcode: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TEqJoinCondition");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("left", TType::Struct, 1))?;
    self.left.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("right", TType::Struct, 2))?;
    self.right.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.opcode {
      o_prot.write_field_begin(&TFieldIdentifier::new("opcode", TType::I32, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// THashJoinNode
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct THashJoinNode {
  pub join_op: TJoinOp,
  pub eq_join_conjuncts: Vec<TEqJoinCondition>,
  pub other_join_conjuncts: Option<Vec<exprs::TExpr>>,
  pub add_probe_filters: Option<bool>,
  pub vother_join_conjunct: Option<exprs::TExpr>,
  pub hash_output_slot_ids: Option<Vec<types::TSlotId>>,
  pub src_expr_list: Option<Vec<exprs::TExpr>>,
  pub voutput_tuple_id: Option<types::TTupleId>,
  pub vintermediate_tuple_id_list: Option<Vec<types::TTupleId>>,
  pub is_broadcast_join: Option<bool>,
  pub is_mark: Option<bool>,
  pub dist_type: Option<TJoinDistributionType>,
  pub mark_join_conjuncts: Option<Vec<exprs::TExpr>>,
  pub use_specific_projections: Option<bool>,
}

impl THashJoinNode {
  pub fn new<F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14>(join_op: TJoinOp, eq_join_conjuncts: Vec<TEqJoinCondition>, other_join_conjuncts: F3, add_probe_filters: F4, vother_join_conjunct: F5, hash_output_slot_ids: F6, src_expr_list: F7, voutput_tuple_id: F8, vintermediate_tuple_id_list: F9, is_broadcast_join: F10, is_mark: F11, dist_type: F12, mark_join_conjuncts: F13, use_specific_projections: F14) -> THashJoinNode where F3: Into<Option<Vec<exprs::TExpr>>>, F4: Into<Option<bool>>, F5: Into<Option<exprs::TExpr>>, F6: Into<Option<Vec<types::TSlotId>>>, F7: Into<Option<Vec<exprs::TExpr>>>, F8: Into<Option<types::TTupleId>>, F9: Into<Option<Vec<types::TTupleId>>>, F10: Into<Option<bool>>, F11: Into<Option<bool>>, F12: Into<Option<TJoinDistributionType>>, F13: Into<Option<Vec<exprs::TExpr>>>, F14: Into<Option<bool>> {
    THashJoinNode {
      join_op,
      eq_join_conjuncts,
      other_join_conjuncts: other_join_conjuncts.into(),
      add_probe_filters: add_probe_filters.into(),
      vother_join_conjunct: vother_join_conjunct.into(),
      hash_output_slot_ids: hash_output_slot_ids.into(),
      src_expr_list: src_expr_list.into(),
      voutput_tuple_id: voutput_tuple_id.into(),
      vintermediate_tuple_id_list: vintermediate_tuple_id_list.into(),
      is_broadcast_join: is_broadcast_join.into(),
      is_mark: is_mark.into(),
      dist_type: dist_type.into(),
      mark_join_conjuncts: mark_join_conjuncts.into(),
      use_specific_projections: use_specific_projections.into(),
    }
  }
}

impl TSerializable for THashJoinNode {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<THashJoinNode> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TJoinOp> = None;
    let mut f_2: Option<Vec<TEqJoinCondition>> = None;
    let mut f_3: Option<Vec<exprs::TExpr>> = None;
    let mut f_4: Option<bool> = None;
    let mut f_5: Option<exprs::TExpr> = None;
    let mut f_6: Option<Vec<types::TSlotId>> = None;
    let mut f_7: Option<Vec<exprs::TExpr>> = None;
    let mut f_8: Option<types::TTupleId> = None;
    let mut f_9: Option<Vec<types::TTupleId>> = None;
    let mut f_10: Option<bool> = None;
    let mut f_11: Option<bool> = None;
    let mut f_12: Option<TJoinDistributionType> = None;
    let mut f_13: Option<Vec<exprs::TExpr>> = None;
    let mut f_14: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TJoinOp::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TEqJoinCondition> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_91 = TEqJoinCondition::read_from_in_protocol(i_prot)?;
            val.push(list_elem_91);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<exprs::TExpr> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_92 = exprs::TExpr::read_from_in_protocol(i_prot)?;
            val.push(list_elem_92);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = exprs::TExpr::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::TSlotId> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_93 = i_prot.read_i32()?;
            val.push(list_elem_93);
          }
          i_prot.read_list_end()?;
          f_6 = Some(val);
        },
        7 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<exprs::TExpr> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_94 = exprs::TExpr::read_from_in_protocol(i_prot)?;
            val.push(list_elem_94);
          }
          i_prot.read_list_end()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i32()?;
          f_8 = Some(val);
        },
        9 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::TTupleId> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_95 = i_prot.read_i32()?;
            val.push(list_elem_95);
          }
          i_prot.read_list_end()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_bool()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_bool()?;
          f_11 = Some(val);
        },
        12 => {
          let val = TJoinDistributionType::read_from_in_protocol(i_prot)?;
          f_12 = Some(val);
        },
        13 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<exprs::TExpr> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_96 = exprs::TExpr::read_from_in_protocol(i_prot)?;
            val.push(list_elem_96);
          }
          i_prot.read_list_end()?;
          f_13 = Some(val);
        },
        14 => {
          let val = i_prot.read_bool()?;
          f_14 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("THashJoinNode.join_op", &f_1)?;
    verify_required_field_exists("THashJoinNode.eq_join_conjuncts", &f_2)?;
    let ret = THashJoinNode {
      join_op: f_1.expect("auto-generated code should have checked for presence of required fields"),
      eq_join_conjuncts: f_2.expect("auto-generated code should have checked for presence of required fields"),
      other_join_conjuncts: f_3,
      add_probe_filters: f_4,
      vother_join_conjunct: f_5,
      hash_output_slot_ids: f_6,
      src_expr_list: f_7,
      voutput_tuple_id: f_8,
      vintermediate_tuple_id_list: f_9,
      is_broadcast_join: f_10,
      is_mark: f_11,
      dist_type: f_12,
      mark_join_conjuncts: f_13,
      use_specific_projections: f_14,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("THashJoinNode");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("join_op", TType::I32, 1))?;
    self.join_op.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("eq_join_conjuncts", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.eq_join_conjuncts.len() as i32))?;
    for e in &self.eq_join_conjuncts {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.other_join_conjuncts {
      o_prot.write_field_begin(&TFieldIdentifier::new("other_join_conjuncts", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.add_probe_filters {
      o_prot.write_field_begin(&TFieldIdentifier::new("add_probe_filters", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.vother_join_conjunct {
      o_prot.write_field_begin(&TFieldIdentifier::new("vother_join_conjunct", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.hash_output_slot_ids {
      o_prot.write_field_begin(&TFieldIdentifier::new("hash_output_slot_ids", TType::List, 6))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I32, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i32(*e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.src_expr_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("srcExprList", TType::List, 7))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.voutput_tuple_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("voutput_tuple_id", TType::I32, 8))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.vintermediate_tuple_id_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("vintermediate_tuple_id_list", TType::List, 9))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I32, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i32(*e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_broadcast_join {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_broadcast_join", TType::Bool, 10))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_mark {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_mark", TType::Bool, 11))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.dist_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("dist_type", TType::I32, 12))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.mark_join_conjuncts {
      o_prot.write_field_begin(&TFieldIdentifier::new("mark_join_conjuncts", TType::List, 13))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.use_specific_projections {
      o_prot.write_field_begin(&TFieldIdentifier::new("use_specific_projections", TType::Bool, 14))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TNestedLoopJoinNode
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TNestedLoopJoinNode {
  pub join_op: TJoinOp,
  pub src_expr_list: Option<Vec<exprs::TExpr>>,
  pub voutput_tuple_id: Option<types::TTupleId>,
  pub vintermediate_tuple_id_list: Option<Vec<types::TTupleId>>,
  pub is_output_left_side_only: Option<bool>,
  pub vjoin_conjunct: Option<exprs::TExpr>,
  pub is_mark: Option<bool>,
  pub join_conjuncts: Option<Vec<exprs::TExpr>>,
  pub mark_join_conjuncts: Option<Vec<exprs::TExpr>>,
  pub use_specific_projections: Option<bool>,
}

impl TNestedLoopJoinNode {
  pub fn new<F2, F3, F4, F5, F6, F7, F8, F9, F10>(join_op: TJoinOp, src_expr_list: F2, voutput_tuple_id: F3, vintermediate_tuple_id_list: F4, is_output_left_side_only: F5, vjoin_conjunct: F6, is_mark: F7, join_conjuncts: F8, mark_join_conjuncts: F9, use_specific_projections: F10) -> TNestedLoopJoinNode where F2: Into<Option<Vec<exprs::TExpr>>>, F3: Into<Option<types::TTupleId>>, F4: Into<Option<Vec<types::TTupleId>>>, F5: Into<Option<bool>>, F6: Into<Option<exprs::TExpr>>, F7: Into<Option<bool>>, F8: Into<Option<Vec<exprs::TExpr>>>, F9: Into<Option<Vec<exprs::TExpr>>>, F10: Into<Option<bool>> {
    TNestedLoopJoinNode {
      join_op,
      src_expr_list: src_expr_list.into(),
      voutput_tuple_id: voutput_tuple_id.into(),
      vintermediate_tuple_id_list: vintermediate_tuple_id_list.into(),
      is_output_left_side_only: is_output_left_side_only.into(),
      vjoin_conjunct: vjoin_conjunct.into(),
      is_mark: is_mark.into(),
      join_conjuncts: join_conjuncts.into(),
      mark_join_conjuncts: mark_join_conjuncts.into(),
      use_specific_projections: use_specific_projections.into(),
    }
  }
}

impl TSerializable for TNestedLoopJoinNode {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TNestedLoopJoinNode> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TJoinOp> = None;
    let mut f_2: Option<Vec<exprs::TExpr>> = None;
    let mut f_3: Option<types::TTupleId> = None;
    let mut f_4: Option<Vec<types::TTupleId>> = None;
    let mut f_5: Option<bool> = None;
    let mut f_6: Option<exprs::TExpr> = None;
    let mut f_7: Option<bool> = None;
    let mut f_8: Option<Vec<exprs::TExpr>> = None;
    let mut f_9: Option<Vec<exprs::TExpr>> = None;
    let mut f_10: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TJoinOp::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<exprs::TExpr> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_97 = exprs::TExpr::read_from_in_protocol(i_prot)?;
            val.push(list_elem_97);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::TTupleId> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_98 = i_prot.read_i32()?;
            val.push(list_elem_98);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let val = exprs::TExpr::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bool()?;
          f_7 = Some(val);
        },
        8 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<exprs::TExpr> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_99 = exprs::TExpr::read_from_in_protocol(i_prot)?;
            val.push(list_elem_99);
          }
          i_prot.read_list_end()?;
          f_8 = Some(val);
        },
        9 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<exprs::TExpr> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_100 = exprs::TExpr::read_from_in_protocol(i_prot)?;
            val.push(list_elem_100);
          }
          i_prot.read_list_end()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_bool()?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TNestedLoopJoinNode.join_op", &f_1)?;
    let ret = TNestedLoopJoinNode {
      join_op: f_1.expect("auto-generated code should have checked for presence of required fields"),
      src_expr_list: f_2,
      voutput_tuple_id: f_3,
      vintermediate_tuple_id_list: f_4,
      is_output_left_side_only: f_5,
      vjoin_conjunct: f_6,
      is_mark: f_7,
      join_conjuncts: f_8,
      mark_join_conjuncts: f_9,
      use_specific_projections: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TNestedLoopJoinNode");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("join_op", TType::I32, 1))?;
    self.join_op.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.src_expr_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("srcExprList", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.voutput_tuple_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("voutput_tuple_id", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.vintermediate_tuple_id_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("vintermediate_tuple_id_list", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I32, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i32(*e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_output_left_side_only {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_output_left_side_only", TType::Bool, 5))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.vjoin_conjunct {
      o_prot.write_field_begin(&TFieldIdentifier::new("vjoin_conjunct", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_mark {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_mark", TType::Bool, 7))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.join_conjuncts {
      o_prot.write_field_begin(&TFieldIdentifier::new("join_conjuncts", TType::List, 8))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.mark_join_conjuncts {
      o_prot.write_field_begin(&TFieldIdentifier::new("mark_join_conjuncts", TType::List, 9))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.use_specific_projections {
      o_prot.write_field_begin(&TFieldIdentifier::new("use_specific_projections", TType::Bool, 10))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TMergeJoinNode
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TMergeJoinNode {
  pub cmp_conjuncts: Vec<TEqJoinCondition>,
  pub other_join_conjuncts: Option<Vec<exprs::TExpr>>,
}

impl TMergeJoinNode {
  pub fn new<F2>(cmp_conjuncts: Vec<TEqJoinCondition>, other_join_conjuncts: F2) -> TMergeJoinNode where F2: Into<Option<Vec<exprs::TExpr>>> {
    TMergeJoinNode {
      cmp_conjuncts,
      other_join_conjuncts: other_join_conjuncts.into(),
    }
  }
}

impl TSerializable for TMergeJoinNode {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TMergeJoinNode> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<TEqJoinCondition>> = None;
    let mut f_2: Option<Vec<exprs::TExpr>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TEqJoinCondition> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_101 = TEqJoinCondition::read_from_in_protocol(i_prot)?;
            val.push(list_elem_101);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<exprs::TExpr> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_102 = exprs::TExpr::read_from_in_protocol(i_prot)?;
            val.push(list_elem_102);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TMergeJoinNode.cmp_conjuncts", &f_1)?;
    let ret = TMergeJoinNode {
      cmp_conjuncts: f_1.expect("auto-generated code should have checked for presence of required fields"),
      other_join_conjuncts: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TMergeJoinNode");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("cmp_conjuncts", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.cmp_conjuncts.len() as i32))?;
    for e in &self.cmp_conjuncts {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.other_join_conjuncts {
      o_prot.write_field_begin(&TFieldIdentifier::new("other_join_conjuncts", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TAggregationNode
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TAggregationNode {
  pub grouping_exprs: Option<Vec<exprs::TExpr>>,
  pub aggregate_functions: Vec<exprs::TExpr>,
  pub intermediate_tuple_id: types::TTupleId,
  pub output_tuple_id: types::TTupleId,
  pub need_finalize: bool,
  pub use_streaming_preaggregation: Option<bool>,
  pub agg_sort_infos: Option<Vec<TSortInfo>>,
  pub is_first_phase: Option<bool>,
  pub is_colocate: Option<bool>,
  pub agg_sort_info_by_group_key: Option<TSortInfo>,
}

impl TAggregationNode {
  pub fn new<F1, F6, F7, F8, F9, F10>(grouping_exprs: F1, aggregate_functions: Vec<exprs::TExpr>, intermediate_tuple_id: types::TTupleId, output_tuple_id: types::TTupleId, need_finalize: bool, use_streaming_preaggregation: F6, agg_sort_infos: F7, is_first_phase: F8, is_colocate: F9, agg_sort_info_by_group_key: F10) -> TAggregationNode where F1: Into<Option<Vec<exprs::TExpr>>>, F6: Into<Option<bool>>, F7: Into<Option<Vec<TSortInfo>>>, F8: Into<Option<bool>>, F9: Into<Option<bool>>, F10: Into<Option<TSortInfo>> {
    TAggregationNode {
      grouping_exprs: grouping_exprs.into(),
      aggregate_functions,
      intermediate_tuple_id,
      output_tuple_id,
      need_finalize,
      use_streaming_preaggregation: use_streaming_preaggregation.into(),
      agg_sort_infos: agg_sort_infos.into(),
      is_first_phase: is_first_phase.into(),
      is_colocate: is_colocate.into(),
      agg_sort_info_by_group_key: agg_sort_info_by_group_key.into(),
    }
  }
}

impl TSerializable for TAggregationNode {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TAggregationNode> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<exprs::TExpr>> = None;
    let mut f_2: Option<Vec<exprs::TExpr>> = None;
    let mut f_3: Option<types::TTupleId> = None;
    let mut f_4: Option<types::TTupleId> = None;
    let mut f_5: Option<bool> = None;
    let mut f_6: Option<bool> = None;
    let mut f_7: Option<Vec<TSortInfo>> = None;
    let mut f_8: Option<bool> = None;
    let mut f_9: Option<bool> = None;
    let mut f_10: Option<TSortInfo> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<exprs::TExpr> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_103 = exprs::TExpr::read_from_in_protocol(i_prot)?;
            val.push(list_elem_103);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<exprs::TExpr> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_104 = exprs::TExpr::read_from_in_protocol(i_prot)?;
            val.push(list_elem_104);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        7 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TSortInfo> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_105 = TSortInfo::read_from_in_protocol(i_prot)?;
            val.push(list_elem_105);
          }
          i_prot.read_list_end()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_bool()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_bool()?;
          f_9 = Some(val);
        },
        10 => {
          let val = TSortInfo::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TAggregationNode.aggregate_functions", &f_2)?;
    verify_required_field_exists("TAggregationNode.intermediate_tuple_id", &f_3)?;
    verify_required_field_exists("TAggregationNode.output_tuple_id", &f_4)?;
    verify_required_field_exists("TAggregationNode.need_finalize", &f_5)?;
    let ret = TAggregationNode {
      grouping_exprs: f_1,
      aggregate_functions: f_2.expect("auto-generated code should have checked for presence of required fields"),
      intermediate_tuple_id: f_3.expect("auto-generated code should have checked for presence of required fields"),
      output_tuple_id: f_4.expect("auto-generated code should have checked for presence of required fields"),
      need_finalize: f_5.expect("auto-generated code should have checked for presence of required fields"),
      use_streaming_preaggregation: f_6,
      agg_sort_infos: f_7,
      is_first_phase: f_8,
      is_colocate: f_9,
      agg_sort_info_by_group_key: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TAggregationNode");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.grouping_exprs {
      o_prot.write_field_begin(&TFieldIdentifier::new("grouping_exprs", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_begin(&TFieldIdentifier::new("aggregate_functions", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.aggregate_functions.len() as i32))?;
    for e in &self.aggregate_functions {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("intermediate_tuple_id", TType::I32, 3))?;
    o_prot.write_i32(self.intermediate_tuple_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("output_tuple_id", TType::I32, 4))?;
    o_prot.write_i32(self.output_tuple_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("need_finalize", TType::Bool, 5))?;
    o_prot.write_bool(self.need_finalize)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.use_streaming_preaggregation {
      o_prot.write_field_begin(&TFieldIdentifier::new("use_streaming_preaggregation", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.agg_sort_infos {
      o_prot.write_field_begin(&TFieldIdentifier::new("agg_sort_infos", TType::List, 7))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_first_phase {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_first_phase", TType::Bool, 8))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_colocate {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_colocate", TType::Bool, 9))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.agg_sort_info_by_group_key {
      o_prot.write_field_begin(&TFieldIdentifier::new("agg_sort_info_by_group_key", TType::Struct, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TRepeatNode
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TRepeatNode {
  pub output_tuple_id: types::TTupleId,
  pub slot_id_set_list: Vec<BTreeSet<types::TSlotId>>,
  pub repeat_id_list: Vec<i64>,
  pub grouping_list: Vec<Vec<i64>>,
  pub all_slot_ids: BTreeSet<types::TSlotId>,
  pub exprs: Vec<exprs::TExpr>,
}

impl TRepeatNode {
  pub fn new(output_tuple_id: types::TTupleId, slot_id_set_list: Vec<BTreeSet<types::TSlotId>>, repeat_id_list: Vec<i64>, grouping_list: Vec<Vec<i64>>, all_slot_ids: BTreeSet<types::TSlotId>, exprs: Vec<exprs::TExpr>) -> TRepeatNode {
    TRepeatNode {
      output_tuple_id,
      slot_id_set_list,
      repeat_id_list,
      grouping_list,
      all_slot_ids,
      exprs,
    }
  }
}

impl TSerializable for TRepeatNode {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TRepeatNode> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<types::TTupleId> = None;
    let mut f_2: Option<Vec<BTreeSet<types::TSlotId>>> = None;
    let mut f_3: Option<Vec<i64>> = None;
    let mut f_4: Option<Vec<Vec<i64>>> = None;
    let mut f_5: Option<BTreeSet<types::TSlotId>> = None;
    let mut f_6: Option<Vec<exprs::TExpr>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<BTreeSet<types::TSlotId>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let set_ident = i_prot.read_set_begin()?;
            let mut list_elem_106: BTreeSet<types::TSlotId> = BTreeSet::new();
            for _ in 0..set_ident.size {
              let set_elem_107 = i_prot.read_i32()?;
              list_elem_106.insert(set_elem_107);
            }
            i_prot.read_set_end()?;
            val.push(list_elem_106);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i64> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_108 = i_prot.read_i64()?;
            val.push(list_elem_108);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<i64>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_ident = i_prot.read_list_begin()?;
            let mut list_elem_109: Vec<i64> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_110 = i_prot.read_i64()?;
              list_elem_109.push(list_elem_110);
            }
            i_prot.read_list_end()?;
            val.push(list_elem_109);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let set_ident = i_prot.read_set_begin()?;
          let mut val: BTreeSet<types::TSlotId> = BTreeSet::new();
          for _ in 0..set_ident.size {
            let set_elem_111 = i_prot.read_i32()?;
            val.insert(set_elem_111);
          }
          i_prot.read_set_end()?;
          f_5 = Some(val);
        },
        6 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<exprs::TExpr> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_112 = exprs::TExpr::read_from_in_protocol(i_prot)?;
            val.push(list_elem_112);
          }
          i_prot.read_list_end()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TRepeatNode.output_tuple_id", &f_1)?;
    verify_required_field_exists("TRepeatNode.slot_id_set_list", &f_2)?;
    verify_required_field_exists("TRepeatNode.repeat_id_list", &f_3)?;
    verify_required_field_exists("TRepeatNode.grouping_list", &f_4)?;
    verify_required_field_exists("TRepeatNode.all_slot_ids", &f_5)?;
    verify_required_field_exists("TRepeatNode.exprs", &f_6)?;
    let ret = TRepeatNode {
      output_tuple_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      slot_id_set_list: f_2.expect("auto-generated code should have checked for presence of required fields"),
      repeat_id_list: f_3.expect("auto-generated code should have checked for presence of required fields"),
      grouping_list: f_4.expect("auto-generated code should have checked for presence of required fields"),
      all_slot_ids: f_5.expect("auto-generated code should have checked for presence of required fields"),
      exprs: f_6.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TRepeatNode");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("output_tuple_id", TType::I32, 1))?;
    o_prot.write_i32(self.output_tuple_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("slot_id_set_list", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Set, self.slot_id_set_list.len() as i32))?;
    for e in &self.slot_id_set_list {
      o_prot.write_set_begin(&TSetIdentifier::new(TType::I32, e.len() as i32))?;
      for e in e {
        o_prot.write_i32(*e)?;
      }
      o_prot.write_set_end()?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("repeat_id_list", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I64, self.repeat_id_list.len() as i32))?;
    for e in &self.repeat_id_list {
      o_prot.write_i64(*e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("grouping_list", TType::List, 4))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::List, self.grouping_list.len() as i32))?;
    for e in &self.grouping_list {
      o_prot.write_list_begin(&TListIdentifier::new(TType::I64, e.len() as i32))?;
      for e in e {
        o_prot.write_i64(*e)?;
      }
      o_prot.write_list_end()?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("all_slot_ids", TType::Set, 5))?;
    o_prot.write_set_begin(&TSetIdentifier::new(TType::I32, self.all_slot_ids.len() as i32))?;
    for e in &self.all_slot_ids {
      o_prot.write_i32(*e)?;
    }
    o_prot.write_set_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("exprs", TType::List, 6))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.exprs.len() as i32))?;
    for e in &self.exprs {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TMaterializationNode
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TMaterializationNode {
  pub tuple_id: Option<types::TTupleId>,
  pub intermediate_tuple_id: Option<types::TTupleId>,
  pub nodes_info: Option<descriptors::TPaloNodesInfo>,
  pub fetch_expr_lists: Option<Vec<exprs::TExpr>>,
  pub column_descs_lists: Option<Vec<Vec<descriptors::TColumn>>>,
  pub slot_locs_lists: Option<Vec<Vec<i32>>>,
  pub fetch_row_stores: Option<Vec<bool>>,
  pub gc_id_map: Option<bool>,
  pub column_idxs_lists: Option<Vec<Vec<i32>>>,
}

impl TMaterializationNode {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9>(tuple_id: F1, intermediate_tuple_id: F2, nodes_info: F3, fetch_expr_lists: F4, column_descs_lists: F5, slot_locs_lists: F6, fetch_row_stores: F7, gc_id_map: F8, column_idxs_lists: F9) -> TMaterializationNode where F1: Into<Option<types::TTupleId>>, F2: Into<Option<types::TTupleId>>, F3: Into<Option<descriptors::TPaloNodesInfo>>, F4: Into<Option<Vec<exprs::TExpr>>>, F5: Into<Option<Vec<Vec<descriptors::TColumn>>>>, F6: Into<Option<Vec<Vec<i32>>>>, F7: Into<Option<Vec<bool>>>, F8: Into<Option<bool>>, F9: Into<Option<Vec<Vec<i32>>>> {
    TMaterializationNode {
      tuple_id: tuple_id.into(),
      intermediate_tuple_id: intermediate_tuple_id.into(),
      nodes_info: nodes_info.into(),
      fetch_expr_lists: fetch_expr_lists.into(),
      column_descs_lists: column_descs_lists.into(),
      slot_locs_lists: slot_locs_lists.into(),
      fetch_row_stores: fetch_row_stores.into(),
      gc_id_map: gc_id_map.into(),
      column_idxs_lists: column_idxs_lists.into(),
    }
  }
}

impl TSerializable for TMaterializationNode {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TMaterializationNode> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<types::TTupleId> = None;
    let mut f_2: Option<types::TTupleId> = None;
    let mut f_3: Option<descriptors::TPaloNodesInfo> = None;
    let mut f_4: Option<Vec<exprs::TExpr>> = None;
    let mut f_5: Option<Vec<Vec<descriptors::TColumn>>> = None;
    let mut f_6: Option<Vec<Vec<i32>>> = None;
    let mut f_7: Option<Vec<bool>> = None;
    let mut f_8: Option<bool> = None;
    let mut f_9: Option<Vec<Vec<i32>>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = descriptors::TPaloNodesInfo::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<exprs::TExpr> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_113 = exprs::TExpr::read_from_in_protocol(i_prot)?;
            val.push(list_elem_113);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<descriptors::TColumn>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_ident = i_prot.read_list_begin()?;
            let mut list_elem_114: Vec<descriptors::TColumn> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_115 = descriptors::TColumn::read_from_in_protocol(i_prot)?;
              list_elem_114.push(list_elem_115);
            }
            i_prot.read_list_end()?;
            val.push(list_elem_114);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<i32>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_ident = i_prot.read_list_begin()?;
            let mut list_elem_116: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_117 = i_prot.read_i32()?;
              list_elem_116.push(list_elem_117);
            }
            i_prot.read_list_end()?;
            val.push(list_elem_116);
          }
          i_prot.read_list_end()?;
          f_6 = Some(val);
        },
        7 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<bool> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_118 = i_prot.read_bool()?;
            val.push(list_elem_118);
          }
          i_prot.read_list_end()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_bool()?;
          f_8 = Some(val);
        },
        9 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<i32>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_ident = i_prot.read_list_begin()?;
            let mut list_elem_119: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_120 = i_prot.read_i32()?;
              list_elem_119.push(list_elem_120);
            }
            i_prot.read_list_end()?;
            val.push(list_elem_119);
          }
          i_prot.read_list_end()?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TMaterializationNode {
      tuple_id: f_1,
      intermediate_tuple_id: f_2,
      nodes_info: f_3,
      fetch_expr_lists: f_4,
      column_descs_lists: f_5,
      slot_locs_lists: f_6,
      fetch_row_stores: f_7,
      gc_id_map: f_8,
      column_idxs_lists: f_9,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TMaterializationNode");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.tuple_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("tuple_id", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.intermediate_tuple_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("intermediate_tuple_id", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.nodes_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("nodes_info", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.fetch_expr_lists {
      o_prot.write_field_begin(&TFieldIdentifier::new("fetch_expr_lists", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.column_descs_lists {
      o_prot.write_field_begin(&TFieldIdentifier::new("column_descs_lists", TType::List, 5))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::List, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, e.len() as i32))?;
        for e in e {
          e.write_to_out_protocol(o_prot)?;
        }
        o_prot.write_list_end()?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.slot_locs_lists {
      o_prot.write_field_begin(&TFieldIdentifier::new("slot_locs_lists", TType::List, 6))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::List, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_list_begin(&TListIdentifier::new(TType::I32, e.len() as i32))?;
        for e in e {
          o_prot.write_i32(*e)?;
        }
        o_prot.write_list_end()?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.fetch_row_stores {
      o_prot.write_field_begin(&TFieldIdentifier::new("fetch_row_stores", TType::List, 7))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Bool, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_bool(*e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.gc_id_map {
      o_prot.write_field_begin(&TFieldIdentifier::new("gc_id_map", TType::Bool, 8))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.column_idxs_lists {
      o_prot.write_field_begin(&TFieldIdentifier::new("column_idxs_lists", TType::List, 9))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::List, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_list_begin(&TListIdentifier::new(TType::I32, e.len() as i32))?;
        for e in e {
          o_prot.write_i32(*e)?;
        }
        o_prot.write_list_end()?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TPreAggregationNode
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TPreAggregationNode {
  pub group_exprs: Vec<exprs::TExpr>,
  pub aggregate_exprs: Vec<exprs::TExpr>,
}

impl TPreAggregationNode {
  pub fn new(group_exprs: Vec<exprs::TExpr>, aggregate_exprs: Vec<exprs::TExpr>) -> TPreAggregationNode {
    TPreAggregationNode {
      group_exprs,
      aggregate_exprs,
    }
  }
}

impl TSerializable for TPreAggregationNode {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TPreAggregationNode> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<exprs::TExpr>> = None;
    let mut f_2: Option<Vec<exprs::TExpr>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<exprs::TExpr> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_121 = exprs::TExpr::read_from_in_protocol(i_prot)?;
            val.push(list_elem_121);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<exprs::TExpr> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_122 = exprs::TExpr::read_from_in_protocol(i_prot)?;
            val.push(list_elem_122);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TPreAggregationNode.group_exprs", &f_1)?;
    verify_required_field_exists("TPreAggregationNode.aggregate_exprs", &f_2)?;
    let ret = TPreAggregationNode {
      group_exprs: f_1.expect("auto-generated code should have checked for presence of required fields"),
      aggregate_exprs: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TPreAggregationNode");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("group_exprs", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.group_exprs.len() as i32))?;
    for e in &self.group_exprs {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("aggregate_exprs", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.aggregate_exprs.len() as i32))?;
    for e in &self.aggregate_exprs {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSortNode
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSortNode {
  pub sort_info: TSortInfo,
  pub use_top_n: bool,
  pub offset: Option<i64>,
  pub is_default_limit: Option<bool>,
  pub use_topn_opt: Option<bool>,
  pub merge_by_exchange: Option<bool>,
  pub is_analytic_sort: Option<bool>,
  pub is_colocate: Option<bool>,
  pub algorithm: Option<TSortAlgorithm>,
  pub use_local_merge: Option<bool>,
  pub full_sort_max_buffered_bytes: Option<i64>,
}

impl TSortNode {
  pub fn new<F3, F6, F7, F8, F9, F10, F11, F12, F13>(sort_info: TSortInfo, use_top_n: bool, offset: F3, is_default_limit: F6, use_topn_opt: F7, merge_by_exchange: F8, is_analytic_sort: F9, is_colocate: F10, algorithm: F11, use_local_merge: F12, full_sort_max_buffered_bytes: F13) -> TSortNode where F3: Into<Option<i64>>, F6: Into<Option<bool>>, F7: Into<Option<bool>>, F8: Into<Option<bool>>, F9: Into<Option<bool>>, F10: Into<Option<bool>>, F11: Into<Option<TSortAlgorithm>>, F12: Into<Option<bool>>, F13: Into<Option<i64>> {
    TSortNode {
      sort_info,
      use_top_n,
      offset: offset.into(),
      is_default_limit: is_default_limit.into(),
      use_topn_opt: use_topn_opt.into(),
      merge_by_exchange: merge_by_exchange.into(),
      is_analytic_sort: is_analytic_sort.into(),
      is_colocate: is_colocate.into(),
      algorithm: algorithm.into(),
      use_local_merge: use_local_merge.into(),
      full_sort_max_buffered_bytes: full_sort_max_buffered_bytes.into(),
    }
  }
}

impl TSerializable for TSortNode {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSortNode> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSortInfo> = None;
    let mut f_2: Option<bool> = None;
    let mut f_3: Option<i64> = None;
    let mut f_6: Option<bool> = None;
    let mut f_7: Option<bool> = None;
    let mut f_8: Option<bool> = None;
    let mut f_9: Option<bool> = None;
    let mut f_10: Option<bool> = None;
    let mut f_11: Option<TSortAlgorithm> = None;
    let mut f_12: Option<bool> = None;
    let mut f_13: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSortInfo::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bool()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_bool()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_bool()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_bool()?;
          f_10 = Some(val);
        },
        11 => {
          let val = TSortAlgorithm::read_from_in_protocol(i_prot)?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_bool()?;
          f_12 = Some(val);
        },
        13 => {
          let val = i_prot.read_i64()?;
          f_13 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSortNode.sort_info", &f_1)?;
    verify_required_field_exists("TSortNode.use_top_n", &f_2)?;
    let ret = TSortNode {
      sort_info: f_1.expect("auto-generated code should have checked for presence of required fields"),
      use_top_n: f_2.expect("auto-generated code should have checked for presence of required fields"),
      offset: f_3,
      is_default_limit: f_6,
      use_topn_opt: f_7,
      merge_by_exchange: f_8,
      is_analytic_sort: f_9,
      is_colocate: f_10,
      algorithm: f_11,
      use_local_merge: f_12,
      full_sort_max_buffered_bytes: f_13,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSortNode");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sort_info", TType::Struct, 1))?;
    self.sort_info.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("use_top_n", TType::Bool, 2))?;
    o_prot.write_bool(self.use_top_n)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.offset {
      o_prot.write_field_begin(&TFieldIdentifier::new("offset", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_default_limit {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_default_limit", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.use_topn_opt {
      o_prot.write_field_begin(&TFieldIdentifier::new("use_topn_opt", TType::Bool, 7))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.merge_by_exchange {
      o_prot.write_field_begin(&TFieldIdentifier::new("merge_by_exchange", TType::Bool, 8))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_analytic_sort {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_analytic_sort", TType::Bool, 9))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_colocate {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_colocate", TType::Bool, 10))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.algorithm {
      o_prot.write_field_begin(&TFieldIdentifier::new("algorithm", TType::I32, 11))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.use_local_merge {
      o_prot.write_field_begin(&TFieldIdentifier::new("use_local_merge", TType::Bool, 12))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.full_sort_max_buffered_bytes {
      o_prot.write_field_begin(&TFieldIdentifier::new("full_sort_max_buffered_bytes", TType::I64, 13))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TPartitionSortNode
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TPartitionSortNode {
  pub partition_exprs: Option<Vec<exprs::TExpr>>,
  pub sort_info: Option<TSortInfo>,
  pub has_global_limit: Option<bool>,
  pub top_n_algorithm: Option<TopNAlgorithm>,
  pub partition_inner_limit: Option<i64>,
  pub ptopn_phase: Option<TPartTopNPhase>,
}

impl TPartitionSortNode {
  pub fn new<F1, F2, F3, F4, F5, F6>(partition_exprs: F1, sort_info: F2, has_global_limit: F3, top_n_algorithm: F4, partition_inner_limit: F5, ptopn_phase: F6) -> TPartitionSortNode where F1: Into<Option<Vec<exprs::TExpr>>>, F2: Into<Option<TSortInfo>>, F3: Into<Option<bool>>, F4: Into<Option<TopNAlgorithm>>, F5: Into<Option<i64>>, F6: Into<Option<TPartTopNPhase>> {
    TPartitionSortNode {
      partition_exprs: partition_exprs.into(),
      sort_info: sort_info.into(),
      has_global_limit: has_global_limit.into(),
      top_n_algorithm: top_n_algorithm.into(),
      partition_inner_limit: partition_inner_limit.into(),
      ptopn_phase: ptopn_phase.into(),
    }
  }
}

impl TSerializable for TPartitionSortNode {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TPartitionSortNode> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<exprs::TExpr>> = None;
    let mut f_2: Option<TSortInfo> = None;
    let mut f_3: Option<bool> = None;
    let mut f_4: Option<TopNAlgorithm> = None;
    let mut f_5: Option<i64> = None;
    let mut f_6: Option<TPartTopNPhase> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<exprs::TExpr> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_123 = exprs::TExpr::read_from_in_protocol(i_prot)?;
            val.push(list_elem_123);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = TSortInfo::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = TopNAlgorithm::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        6 => {
          let val = TPartTopNPhase::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TPartitionSortNode {
      partition_exprs: f_1,
      sort_info: f_2,
      has_global_limit: f_3,
      top_n_algorithm: f_4,
      partition_inner_limit: f_5,
      ptopn_phase: f_6,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TPartitionSortNode");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.partition_exprs {
      o_prot.write_field_begin(&TFieldIdentifier::new("partition_exprs", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.sort_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("sort_info", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.has_global_limit {
      o_prot.write_field_begin(&TFieldIdentifier::new("has_global_limit", TType::Bool, 3))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.top_n_algorithm {
      o_prot.write_field_begin(&TFieldIdentifier::new("top_n_algorithm", TType::I32, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.partition_inner_limit {
      o_prot.write_field_begin(&TFieldIdentifier::new("partition_inner_limit", TType::I64, 5))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.ptopn_phase {
      o_prot.write_field_begin(&TFieldIdentifier::new("ptopn_phase", TType::I32, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TAnalyticWindowBoundary
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TAnalyticWindowBoundary {
  pub type_: TAnalyticWindowBoundaryType,
  pub range_offset_predicate: Option<exprs::TExpr>,
  pub rows_offset_value: Option<i64>,
}

impl TAnalyticWindowBoundary {
  pub fn new<F2, F3>(type_: TAnalyticWindowBoundaryType, range_offset_predicate: F2, rows_offset_value: F3) -> TAnalyticWindowBoundary where F2: Into<Option<exprs::TExpr>>, F3: Into<Option<i64>> {
    TAnalyticWindowBoundary {
      type_,
      range_offset_predicate: range_offset_predicate.into(),
      rows_offset_value: rows_offset_value.into(),
    }
  }
}

impl TSerializable for TAnalyticWindowBoundary {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TAnalyticWindowBoundary> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TAnalyticWindowBoundaryType> = None;
    let mut f_2: Option<exprs::TExpr> = None;
    let mut f_3: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TAnalyticWindowBoundaryType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = exprs::TExpr::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TAnalyticWindowBoundary.type_", &f_1)?;
    let ret = TAnalyticWindowBoundary {
      type_: f_1.expect("auto-generated code should have checked for presence of required fields"),
      range_offset_predicate: f_2,
      rows_offset_value: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TAnalyticWindowBoundary");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 1))?;
    self.type_.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.range_offset_predicate {
      o_prot.write_field_begin(&TFieldIdentifier::new("range_offset_predicate", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.rows_offset_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("rows_offset_value", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TAnalyticWindow
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TAnalyticWindow {
  pub type_: TAnalyticWindowType,
  pub window_start: Option<TAnalyticWindowBoundary>,
  pub window_end: Option<TAnalyticWindowBoundary>,
}

impl TAnalyticWindow {
  pub fn new<F2, F3>(type_: TAnalyticWindowType, window_start: F2, window_end: F3) -> TAnalyticWindow where F2: Into<Option<TAnalyticWindowBoundary>>, F3: Into<Option<TAnalyticWindowBoundary>> {
    TAnalyticWindow {
      type_,
      window_start: window_start.into(),
      window_end: window_end.into(),
    }
  }
}

impl TSerializable for TAnalyticWindow {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TAnalyticWindow> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TAnalyticWindowType> = None;
    let mut f_2: Option<TAnalyticWindowBoundary> = None;
    let mut f_3: Option<TAnalyticWindowBoundary> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TAnalyticWindowType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = TAnalyticWindowBoundary::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = TAnalyticWindowBoundary::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TAnalyticWindow.type_", &f_1)?;
    let ret = TAnalyticWindow {
      type_: f_1.expect("auto-generated code should have checked for presence of required fields"),
      window_start: f_2,
      window_end: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TAnalyticWindow");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 1))?;
    self.type_.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.window_start {
      o_prot.write_field_begin(&TFieldIdentifier::new("window_start", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.window_end {
      o_prot.write_field_begin(&TFieldIdentifier::new("window_end", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TAnalyticNode
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TAnalyticNode {
  pub partition_exprs: Vec<exprs::TExpr>,
  pub order_by_exprs: Vec<exprs::TExpr>,
  pub analytic_functions: Vec<exprs::TExpr>,
  pub window: Option<TAnalyticWindow>,
  pub intermediate_tuple_id: types::TTupleId,
  pub output_tuple_id: types::TTupleId,
  pub buffered_tuple_id: Option<types::TTupleId>,
  pub partition_by_eq: Option<exprs::TExpr>,
  pub order_by_eq: Option<exprs::TExpr>,
  pub is_colocate: Option<bool>,
  pub range_between_offset_exprs: Option<Vec<exprs::TExpr>>,
}

impl TAnalyticNode {
  pub fn new<F4, F7, F8, F9, F10, F11>(partition_exprs: Vec<exprs::TExpr>, order_by_exprs: Vec<exprs::TExpr>, analytic_functions: Vec<exprs::TExpr>, window: F4, intermediate_tuple_id: types::TTupleId, output_tuple_id: types::TTupleId, buffered_tuple_id: F7, partition_by_eq: F8, order_by_eq: F9, is_colocate: F10, range_between_offset_exprs: F11) -> TAnalyticNode where F4: Into<Option<TAnalyticWindow>>, F7: Into<Option<types::TTupleId>>, F8: Into<Option<exprs::TExpr>>, F9: Into<Option<exprs::TExpr>>, F10: Into<Option<bool>>, F11: Into<Option<Vec<exprs::TExpr>>> {
    TAnalyticNode {
      partition_exprs,
      order_by_exprs,
      analytic_functions,
      window: window.into(),
      intermediate_tuple_id,
      output_tuple_id,
      buffered_tuple_id: buffered_tuple_id.into(),
      partition_by_eq: partition_by_eq.into(),
      order_by_eq: order_by_eq.into(),
      is_colocate: is_colocate.into(),
      range_between_offset_exprs: range_between_offset_exprs.into(),
    }
  }
}

impl TSerializable for TAnalyticNode {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TAnalyticNode> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<exprs::TExpr>> = None;
    let mut f_2: Option<Vec<exprs::TExpr>> = None;
    let mut f_3: Option<Vec<exprs::TExpr>> = None;
    let mut f_4: Option<TAnalyticWindow> = None;
    let mut f_5: Option<types::TTupleId> = None;
    let mut f_6: Option<types::TTupleId> = None;
    let mut f_7: Option<types::TTupleId> = None;
    let mut f_8: Option<exprs::TExpr> = None;
    let mut f_9: Option<exprs::TExpr> = None;
    let mut f_10: Option<bool> = None;
    let mut f_11: Option<Vec<exprs::TExpr>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<exprs::TExpr> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_124 = exprs::TExpr::read_from_in_protocol(i_prot)?;
            val.push(list_elem_124);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<exprs::TExpr> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_125 = exprs::TExpr::read_from_in_protocol(i_prot)?;
            val.push(list_elem_125);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<exprs::TExpr> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_126 = exprs::TExpr::read_from_in_protocol(i_prot)?;
            val.push(list_elem_126);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = TAnalyticWindow::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i32()?;
          f_7 = Some(val);
        },
        8 => {
          let val = exprs::TExpr::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        9 => {
          let val = exprs::TExpr::read_from_in_protocol(i_prot)?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_bool()?;
          f_10 = Some(val);
        },
        11 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<exprs::TExpr> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_127 = exprs::TExpr::read_from_in_protocol(i_prot)?;
            val.push(list_elem_127);
          }
          i_prot.read_list_end()?;
          f_11 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TAnalyticNode.partition_exprs", &f_1)?;
    verify_required_field_exists("TAnalyticNode.order_by_exprs", &f_2)?;
    verify_required_field_exists("TAnalyticNode.analytic_functions", &f_3)?;
    verify_required_field_exists("TAnalyticNode.intermediate_tuple_id", &f_5)?;
    verify_required_field_exists("TAnalyticNode.output_tuple_id", &f_6)?;
    let ret = TAnalyticNode {
      partition_exprs: f_1.expect("auto-generated code should have checked for presence of required fields"),
      order_by_exprs: f_2.expect("auto-generated code should have checked for presence of required fields"),
      analytic_functions: f_3.expect("auto-generated code should have checked for presence of required fields"),
      window: f_4,
      intermediate_tuple_id: f_5.expect("auto-generated code should have checked for presence of required fields"),
      output_tuple_id: f_6.expect("auto-generated code should have checked for presence of required fields"),
      buffered_tuple_id: f_7,
      partition_by_eq: f_8,
      order_by_eq: f_9,
      is_colocate: f_10,
      range_between_offset_exprs: f_11,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TAnalyticNode");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("partition_exprs", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.partition_exprs.len() as i32))?;
    for e in &self.partition_exprs {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("order_by_exprs", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.order_by_exprs.len() as i32))?;
    for e in &self.order_by_exprs {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("analytic_functions", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.analytic_functions.len() as i32))?;
    for e in &self.analytic_functions {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.window {
      o_prot.write_field_begin(&TFieldIdentifier::new("window", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_begin(&TFieldIdentifier::new("intermediate_tuple_id", TType::I32, 5))?;
    o_prot.write_i32(self.intermediate_tuple_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("output_tuple_id", TType::I32, 6))?;
    o_prot.write_i32(self.output_tuple_id)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.buffered_tuple_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("buffered_tuple_id", TType::I32, 7))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.partition_by_eq {
      o_prot.write_field_begin(&TFieldIdentifier::new("partition_by_eq", TType::Struct, 8))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.order_by_eq {
      o_prot.write_field_begin(&TFieldIdentifier::new("order_by_eq", TType::Struct, 9))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_colocate {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_colocate", TType::Bool, 10))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.range_between_offset_exprs {
      o_prot.write_field_begin(&TFieldIdentifier::new("range_between_offset_exprs", TType::List, 11))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TMergeNode
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TMergeNode {
  pub tuple_id: types::TTupleId,
  pub result_expr_lists: Vec<Vec<exprs::TExpr>>,
  pub const_expr_lists: Vec<Vec<exprs::TExpr>>,
}

impl TMergeNode {
  pub fn new(tuple_id: types::TTupleId, result_expr_lists: Vec<Vec<exprs::TExpr>>, const_expr_lists: Vec<Vec<exprs::TExpr>>) -> TMergeNode {
    TMergeNode {
      tuple_id,
      result_expr_lists,
      const_expr_lists,
    }
  }
}

impl TSerializable for TMergeNode {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TMergeNode> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<types::TTupleId> = None;
    let mut f_2: Option<Vec<Vec<exprs::TExpr>>> = None;
    let mut f_3: Option<Vec<Vec<exprs::TExpr>>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<exprs::TExpr>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_ident = i_prot.read_list_begin()?;
            let mut list_elem_128: Vec<exprs::TExpr> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_129 = exprs::TExpr::read_from_in_protocol(i_prot)?;
              list_elem_128.push(list_elem_129);
            }
            i_prot.read_list_end()?;
            val.push(list_elem_128);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<exprs::TExpr>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_ident = i_prot.read_list_begin()?;
            let mut list_elem_130: Vec<exprs::TExpr> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_131 = exprs::TExpr::read_from_in_protocol(i_prot)?;
              list_elem_130.push(list_elem_131);
            }
            i_prot.read_list_end()?;
            val.push(list_elem_130);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TMergeNode.tuple_id", &f_1)?;
    verify_required_field_exists("TMergeNode.result_expr_lists", &f_2)?;
    verify_required_field_exists("TMergeNode.const_expr_lists", &f_3)?;
    let ret = TMergeNode {
      tuple_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      result_expr_lists: f_2.expect("auto-generated code should have checked for presence of required fields"),
      const_expr_lists: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TMergeNode");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tuple_id", TType::I32, 1))?;
    o_prot.write_i32(self.tuple_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("result_expr_lists", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::List, self.result_expr_lists.len() as i32))?;
    for e in &self.result_expr_lists {
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, e.len() as i32))?;
      for e in e {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("const_expr_lists", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::List, self.const_expr_lists.len() as i32))?;
    for e in &self.const_expr_lists {
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, e.len() as i32))?;
      for e in e {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TUnionNode
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TUnionNode {
  pub tuple_id: types::TTupleId,
  pub result_expr_lists: Vec<Vec<exprs::TExpr>>,
  pub const_expr_lists: Vec<Vec<exprs::TExpr>>,
  pub first_materialized_child_idx: i64,
}

impl TUnionNode {
  pub fn new(tuple_id: types::TTupleId, result_expr_lists: Vec<Vec<exprs::TExpr>>, const_expr_lists: Vec<Vec<exprs::TExpr>>, first_materialized_child_idx: i64) -> TUnionNode {
    TUnionNode {
      tuple_id,
      result_expr_lists,
      const_expr_lists,
      first_materialized_child_idx,
    }
  }
}

impl TSerializable for TUnionNode {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TUnionNode> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<types::TTupleId> = None;
    let mut f_2: Option<Vec<Vec<exprs::TExpr>>> = None;
    let mut f_3: Option<Vec<Vec<exprs::TExpr>>> = None;
    let mut f_4: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<exprs::TExpr>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_ident = i_prot.read_list_begin()?;
            let mut list_elem_132: Vec<exprs::TExpr> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_133 = exprs::TExpr::read_from_in_protocol(i_prot)?;
              list_elem_132.push(list_elem_133);
            }
            i_prot.read_list_end()?;
            val.push(list_elem_132);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<exprs::TExpr>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_ident = i_prot.read_list_begin()?;
            let mut list_elem_134: Vec<exprs::TExpr> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_135 = exprs::TExpr::read_from_in_protocol(i_prot)?;
              list_elem_134.push(list_elem_135);
            }
            i_prot.read_list_end()?;
            val.push(list_elem_134);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TUnionNode.tuple_id", &f_1)?;
    verify_required_field_exists("TUnionNode.result_expr_lists", &f_2)?;
    verify_required_field_exists("TUnionNode.const_expr_lists", &f_3)?;
    verify_required_field_exists("TUnionNode.first_materialized_child_idx", &f_4)?;
    let ret = TUnionNode {
      tuple_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      result_expr_lists: f_2.expect("auto-generated code should have checked for presence of required fields"),
      const_expr_lists: f_3.expect("auto-generated code should have checked for presence of required fields"),
      first_materialized_child_idx: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TUnionNode");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tuple_id", TType::I32, 1))?;
    o_prot.write_i32(self.tuple_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("result_expr_lists", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::List, self.result_expr_lists.len() as i32))?;
    for e in &self.result_expr_lists {
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, e.len() as i32))?;
      for e in e {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("const_expr_lists", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::List, self.const_expr_lists.len() as i32))?;
    for e in &self.const_expr_lists {
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, e.len() as i32))?;
      for e in e {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("first_materialized_child_idx", TType::I64, 4))?;
    o_prot.write_i64(self.first_materialized_child_idx)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TIntersectNode
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TIntersectNode {
  pub tuple_id: types::TTupleId,
  pub result_expr_lists: Vec<Vec<exprs::TExpr>>,
  pub const_expr_lists: Vec<Vec<exprs::TExpr>>,
  pub first_materialized_child_idx: i64,
  pub is_colocate: Option<bool>,
}

impl TIntersectNode {
  pub fn new<F5>(tuple_id: types::TTupleId, result_expr_lists: Vec<Vec<exprs::TExpr>>, const_expr_lists: Vec<Vec<exprs::TExpr>>, first_materialized_child_idx: i64, is_colocate: F5) -> TIntersectNode where F5: Into<Option<bool>> {
    TIntersectNode {
      tuple_id,
      result_expr_lists,
      const_expr_lists,
      first_materialized_child_idx,
      is_colocate: is_colocate.into(),
    }
  }
}

impl TSerializable for TIntersectNode {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TIntersectNode> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<types::TTupleId> = None;
    let mut f_2: Option<Vec<Vec<exprs::TExpr>>> = None;
    let mut f_3: Option<Vec<Vec<exprs::TExpr>>> = None;
    let mut f_4: Option<i64> = None;
    let mut f_5: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<exprs::TExpr>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_ident = i_prot.read_list_begin()?;
            let mut list_elem_136: Vec<exprs::TExpr> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_137 = exprs::TExpr::read_from_in_protocol(i_prot)?;
              list_elem_136.push(list_elem_137);
            }
            i_prot.read_list_end()?;
            val.push(list_elem_136);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<exprs::TExpr>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_ident = i_prot.read_list_begin()?;
            let mut list_elem_138: Vec<exprs::TExpr> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_139 = exprs::TExpr::read_from_in_protocol(i_prot)?;
              list_elem_138.push(list_elem_139);
            }
            i_prot.read_list_end()?;
            val.push(list_elem_138);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TIntersectNode.tuple_id", &f_1)?;
    verify_required_field_exists("TIntersectNode.result_expr_lists", &f_2)?;
    verify_required_field_exists("TIntersectNode.const_expr_lists", &f_3)?;
    verify_required_field_exists("TIntersectNode.first_materialized_child_idx", &f_4)?;
    let ret = TIntersectNode {
      tuple_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      result_expr_lists: f_2.expect("auto-generated code should have checked for presence of required fields"),
      const_expr_lists: f_3.expect("auto-generated code should have checked for presence of required fields"),
      first_materialized_child_idx: f_4.expect("auto-generated code should have checked for presence of required fields"),
      is_colocate: f_5,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TIntersectNode");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tuple_id", TType::I32, 1))?;
    o_prot.write_i32(self.tuple_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("result_expr_lists", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::List, self.result_expr_lists.len() as i32))?;
    for e in &self.result_expr_lists {
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, e.len() as i32))?;
      for e in e {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("const_expr_lists", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::List, self.const_expr_lists.len() as i32))?;
    for e in &self.const_expr_lists {
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, e.len() as i32))?;
      for e in e {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("first_materialized_child_idx", TType::I64, 4))?;
    o_prot.write_i64(self.first_materialized_child_idx)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.is_colocate {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_colocate", TType::Bool, 5))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TExceptNode
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TExceptNode {
  pub tuple_id: types::TTupleId,
  pub result_expr_lists: Vec<Vec<exprs::TExpr>>,
  pub const_expr_lists: Vec<Vec<exprs::TExpr>>,
  pub first_materialized_child_idx: i64,
  pub is_colocate: Option<bool>,
}

impl TExceptNode {
  pub fn new<F5>(tuple_id: types::TTupleId, result_expr_lists: Vec<Vec<exprs::TExpr>>, const_expr_lists: Vec<Vec<exprs::TExpr>>, first_materialized_child_idx: i64, is_colocate: F5) -> TExceptNode where F5: Into<Option<bool>> {
    TExceptNode {
      tuple_id,
      result_expr_lists,
      const_expr_lists,
      first_materialized_child_idx,
      is_colocate: is_colocate.into(),
    }
  }
}

impl TSerializable for TExceptNode {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TExceptNode> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<types::TTupleId> = None;
    let mut f_2: Option<Vec<Vec<exprs::TExpr>>> = None;
    let mut f_3: Option<Vec<Vec<exprs::TExpr>>> = None;
    let mut f_4: Option<i64> = None;
    let mut f_5: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<exprs::TExpr>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_ident = i_prot.read_list_begin()?;
            let mut list_elem_140: Vec<exprs::TExpr> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_141 = exprs::TExpr::read_from_in_protocol(i_prot)?;
              list_elem_140.push(list_elem_141);
            }
            i_prot.read_list_end()?;
            val.push(list_elem_140);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<exprs::TExpr>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_ident = i_prot.read_list_begin()?;
            let mut list_elem_142: Vec<exprs::TExpr> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_143 = exprs::TExpr::read_from_in_protocol(i_prot)?;
              list_elem_142.push(list_elem_143);
            }
            i_prot.read_list_end()?;
            val.push(list_elem_142);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TExceptNode.tuple_id", &f_1)?;
    verify_required_field_exists("TExceptNode.result_expr_lists", &f_2)?;
    verify_required_field_exists("TExceptNode.const_expr_lists", &f_3)?;
    verify_required_field_exists("TExceptNode.first_materialized_child_idx", &f_4)?;
    let ret = TExceptNode {
      tuple_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      result_expr_lists: f_2.expect("auto-generated code should have checked for presence of required fields"),
      const_expr_lists: f_3.expect("auto-generated code should have checked for presence of required fields"),
      first_materialized_child_idx: f_4.expect("auto-generated code should have checked for presence of required fields"),
      is_colocate: f_5,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TExceptNode");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tuple_id", TType::I32, 1))?;
    o_prot.write_i32(self.tuple_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("result_expr_lists", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::List, self.result_expr_lists.len() as i32))?;
    for e in &self.result_expr_lists {
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, e.len() as i32))?;
      for e in e {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("const_expr_lists", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::List, self.const_expr_lists.len() as i32))?;
    for e in &self.const_expr_lists {
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, e.len() as i32))?;
      for e in e {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("first_materialized_child_idx", TType::I64, 4))?;
    o_prot.write_i64(self.first_materialized_child_idx)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.is_colocate {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_colocate", TType::Bool, 5))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TExchangeNode
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TExchangeNode {
  pub input_row_tuples: Vec<types::TTupleId>,
  pub sort_info: Option<TSortInfo>,
  pub offset: Option<i64>,
  pub partition_type: Option<partitions::TPartitionType>,
}

impl TExchangeNode {
  pub fn new<F2, F3, F4>(input_row_tuples: Vec<types::TTupleId>, sort_info: F2, offset: F3, partition_type: F4) -> TExchangeNode where F2: Into<Option<TSortInfo>>, F3: Into<Option<i64>>, F4: Into<Option<partitions::TPartitionType>> {
    TExchangeNode {
      input_row_tuples,
      sort_info: sort_info.into(),
      offset: offset.into(),
      partition_type: partition_type.into(),
    }
  }
}

impl TSerializable for TExchangeNode {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TExchangeNode> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<types::TTupleId>> = None;
    let mut f_2: Option<TSortInfo> = None;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<partitions::TPartitionType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::TTupleId> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_144 = i_prot.read_i32()?;
            val.push(list_elem_144);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = TSortInfo::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = partitions::TPartitionType::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TExchangeNode.input_row_tuples", &f_1)?;
    let ret = TExchangeNode {
      input_row_tuples: f_1.expect("auto-generated code should have checked for presence of required fields"),
      sort_info: f_2,
      offset: f_3,
      partition_type: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TExchangeNode");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("input_row_tuples", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I32, self.input_row_tuples.len() as i32))?;
    for e in &self.input_row_tuples {
      o_prot.write_i32(*e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.sort_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("sort_info", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.offset {
      o_prot.write_field_begin(&TFieldIdentifier::new("offset", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.partition_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("partition_type", TType::I32, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TOlapRewriteNode
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TOlapRewriteNode {
  pub columns: Vec<exprs::TExpr>,
  pub column_types: Vec<types::TColumnType>,
  pub output_tuple_id: types::TTupleId,
}

impl TOlapRewriteNode {
  pub fn new(columns: Vec<exprs::TExpr>, column_types: Vec<types::TColumnType>, output_tuple_id: types::TTupleId) -> TOlapRewriteNode {
    TOlapRewriteNode {
      columns,
      column_types,
      output_tuple_id,
    }
  }
}

impl TSerializable for TOlapRewriteNode {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TOlapRewriteNode> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<exprs::TExpr>> = None;
    let mut f_2: Option<Vec<types::TColumnType>> = None;
    let mut f_3: Option<types::TTupleId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<exprs::TExpr> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_145 = exprs::TExpr::read_from_in_protocol(i_prot)?;
            val.push(list_elem_145);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::TColumnType> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_146 = types::TColumnType::read_from_in_protocol(i_prot)?;
            val.push(list_elem_146);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TOlapRewriteNode.columns", &f_1)?;
    verify_required_field_exists("TOlapRewriteNode.column_types", &f_2)?;
    verify_required_field_exists("TOlapRewriteNode.output_tuple_id", &f_3)?;
    let ret = TOlapRewriteNode {
      columns: f_1.expect("auto-generated code should have checked for presence of required fields"),
      column_types: f_2.expect("auto-generated code should have checked for presence of required fields"),
      output_tuple_id: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TOlapRewriteNode");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("columns", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.columns.len() as i32))?;
    for e in &self.columns {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("column_types", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.column_types.len() as i32))?;
    for e in &self.column_types {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("output_tuple_id", TType::I32, 3))?;
    o_prot.write_i32(self.output_tuple_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TTableFunctionNode
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTableFunctionNode {
  pub fn_call_expr_list: Option<Vec<exprs::TExpr>>,
  pub output_slot_ids: Option<Vec<types::TSlotId>>,
}

impl TTableFunctionNode {
  pub fn new<F1, F2>(fn_call_expr_list: F1, output_slot_ids: F2) -> TTableFunctionNode where F1: Into<Option<Vec<exprs::TExpr>>>, F2: Into<Option<Vec<types::TSlotId>>> {
    TTableFunctionNode {
      fn_call_expr_list: fn_call_expr_list.into(),
      output_slot_ids: output_slot_ids.into(),
    }
  }
}

impl TSerializable for TTableFunctionNode {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTableFunctionNode> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<exprs::TExpr>> = None;
    let mut f_2: Option<Vec<types::TSlotId>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<exprs::TExpr> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_147 = exprs::TExpr::read_from_in_protocol(i_prot)?;
            val.push(list_elem_147);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::TSlotId> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_148 = i_prot.read_i32()?;
            val.push(list_elem_148);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TTableFunctionNode {
      fn_call_expr_list: f_1,
      output_slot_ids: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TTableFunctionNode");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.fn_call_expr_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("fnCallExprList", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.output_slot_ids {
      o_prot.write_field_begin(&TFieldIdentifier::new("outputSlotIds", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I32, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i32(*e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TBackendResourceProfile
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TBackendResourceProfile {
  pub min_reservation: i64,
  pub max_reservation: i64,
  pub spillable_buffer_size: Option<i64>,
  pub max_row_buffer_size: Option<i64>,
}

impl TBackendResourceProfile {
  pub fn new<F3, F4>(min_reservation: i64, max_reservation: i64, spillable_buffer_size: F3, max_row_buffer_size: F4) -> TBackendResourceProfile where F3: Into<Option<i64>>, F4: Into<Option<i64>> {
    TBackendResourceProfile {
      min_reservation,
      max_reservation,
      spillable_buffer_size: spillable_buffer_size.into(),
      max_row_buffer_size: max_row_buffer_size.into(),
    }
  }
}

impl TSerializable for TBackendResourceProfile {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TBackendResourceProfile> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TBackendResourceProfile.min_reservation", &f_1)?;
    verify_required_field_exists("TBackendResourceProfile.max_reservation", &f_2)?;
    let ret = TBackendResourceProfile {
      min_reservation: f_1.expect("auto-generated code should have checked for presence of required fields"),
      max_reservation: f_2.expect("auto-generated code should have checked for presence of required fields"),
      spillable_buffer_size: f_3,
      max_row_buffer_size: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TBackendResourceProfile");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("min_reservation", TType::I64, 1))?;
    o_prot.write_i64(self.min_reservation)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("max_reservation", TType::I64, 2))?;
    o_prot.write_i64(self.max_reservation)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.spillable_buffer_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("spillable_buffer_size", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.max_row_buffer_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("max_row_buffer_size", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TAssertNumRowsNode
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TAssertNumRowsNode {
  pub desired_num_rows: Option<i64>,
  pub subquery_string: Option<String>,
  pub assertion: Option<TAssertion>,
  pub should_convert_output_to_nullable: Option<bool>,
}

impl TAssertNumRowsNode {
  pub fn new<F1, F2, F3, F4>(desired_num_rows: F1, subquery_string: F2, assertion: F3, should_convert_output_to_nullable: F4) -> TAssertNumRowsNode where F1: Into<Option<i64>>, F2: Into<Option<String>>, F3: Into<Option<TAssertion>>, F4: Into<Option<bool>> {
    TAssertNumRowsNode {
      desired_num_rows: desired_num_rows.into(),
      subquery_string: subquery_string.into(),
      assertion: assertion.into(),
      should_convert_output_to_nullable: should_convert_output_to_nullable.into(),
    }
  }
}

impl TSerializable for TAssertNumRowsNode {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TAssertNumRowsNode> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<TAssertion> = None;
    let mut f_4: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = TAssertion::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TAssertNumRowsNode {
      desired_num_rows: f_1,
      subquery_string: f_2,
      assertion: f_3,
      should_convert_output_to_nullable: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TAssertNumRowsNode");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.desired_num_rows {
      o_prot.write_field_begin(&TFieldIdentifier::new("desired_num_rows", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.subquery_string {
      o_prot.write_field_begin(&TFieldIdentifier::new("subquery_string", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.assertion {
      o_prot.write_field_begin(&TFieldIdentifier::new("assertion", TType::I32, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.should_convert_output_to_nullable {
      o_prot.write_field_begin(&TFieldIdentifier::new("should_convert_output_to_nullable", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TTopnFilterDesc
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTopnFilterDesc {
  pub source_node_id: i32,
  pub is_asc: bool,
  pub null_first: bool,
  pub target_node_id_to_target_expr: BTreeMap<types::TPlanNodeId, exprs::TExpr>,
}

impl TTopnFilterDesc {
  pub fn new(source_node_id: i32, is_asc: bool, null_first: bool, target_node_id_to_target_expr: BTreeMap<types::TPlanNodeId, exprs::TExpr>) -> TTopnFilterDesc {
    TTopnFilterDesc {
      source_node_id,
      is_asc,
      null_first,
      target_node_id_to_target_expr,
    }
  }
}

impl TSerializable for TTopnFilterDesc {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTopnFilterDesc> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<bool> = None;
    let mut f_3: Option<bool> = None;
    let mut f_4: Option<BTreeMap<types::TPlanNodeId, exprs::TExpr>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<types::TPlanNodeId, exprs::TExpr> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_149 = i_prot.read_i32()?;
            let map_val_150 = exprs::TExpr::read_from_in_protocol(i_prot)?;
            val.insert(map_key_149, map_val_150);
          }
          i_prot.read_map_end()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TTopnFilterDesc.source_node_id", &f_1)?;
    verify_required_field_exists("TTopnFilterDesc.is_asc", &f_2)?;
    verify_required_field_exists("TTopnFilterDesc.null_first", &f_3)?;
    verify_required_field_exists("TTopnFilterDesc.target_node_id_to_target_expr", &f_4)?;
    let ret = TTopnFilterDesc {
      source_node_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      is_asc: f_2.expect("auto-generated code should have checked for presence of required fields"),
      null_first: f_3.expect("auto-generated code should have checked for presence of required fields"),
      target_node_id_to_target_expr: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TTopnFilterDesc");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("source_node_id", TType::I32, 1))?;
    o_prot.write_i32(self.source_node_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("is_asc", TType::Bool, 2))?;
    o_prot.write_bool(self.is_asc)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("null_first", TType::Bool, 3))?;
    o_prot.write_bool(self.null_first)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("target_node_id_to_target_expr", TType::Map, 4))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::I32, TType::Struct, self.target_node_id_to_target_expr.len() as i32))?;
    for (k, v) in &self.target_node_id_to_target_expr {
      o_prot.write_i32(*k)?;
      v.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_map_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TRuntimeFilterDesc
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TRuntimeFilterDesc {
  pub filter_id: i32,
  pub src_expr: exprs::TExpr,
  pub expr_order: i32,
  pub plan_id_to_target_expr: BTreeMap<types::TPlanNodeId, exprs::TExpr>,
  pub is_broadcast_join: bool,
  pub has_local_targets: bool,
  pub has_remote_targets: bool,
  pub type_: TRuntimeFilterType,
  pub bloom_filter_size_bytes: Option<i64>,
  pub bitmap_target_expr: Option<exprs::TExpr>,
  pub bitmap_filter_not_in: Option<bool>,
  pub opt_remote_rf: Option<bool>,
  pub min_max_type: Option<TMinMaxRuntimeFilterType>,
  pub bloom_filter_size_calculated_by_ndv: Option<bool>,
  pub null_aware: Option<bool>,
  pub sync_filter_size: Option<bool>,
  pub build_bf_by_runtime_size: Option<bool>,
}

impl TRuntimeFilterDesc {
  pub fn new<F9, F10, F11, F12, F13, F14, F15, F16, F17>(filter_id: i32, src_expr: exprs::TExpr, expr_order: i32, plan_id_to_target_expr: BTreeMap<types::TPlanNodeId, exprs::TExpr>, is_broadcast_join: bool, has_local_targets: bool, has_remote_targets: bool, type_: TRuntimeFilterType, bloom_filter_size_bytes: F9, bitmap_target_expr: F10, bitmap_filter_not_in: F11, opt_remote_rf: F12, min_max_type: F13, bloom_filter_size_calculated_by_ndv: F14, null_aware: F15, sync_filter_size: F16, build_bf_by_runtime_size: F17) -> TRuntimeFilterDesc where F9: Into<Option<i64>>, F10: Into<Option<exprs::TExpr>>, F11: Into<Option<bool>>, F12: Into<Option<bool>>, F13: Into<Option<TMinMaxRuntimeFilterType>>, F14: Into<Option<bool>>, F15: Into<Option<bool>>, F16: Into<Option<bool>>, F17: Into<Option<bool>> {
    TRuntimeFilterDesc {
      filter_id,
      src_expr,
      expr_order,
      plan_id_to_target_expr,
      is_broadcast_join,
      has_local_targets,
      has_remote_targets,
      type_,
      bloom_filter_size_bytes: bloom_filter_size_bytes.into(),
      bitmap_target_expr: bitmap_target_expr.into(),
      bitmap_filter_not_in: bitmap_filter_not_in.into(),
      opt_remote_rf: opt_remote_rf.into(),
      min_max_type: min_max_type.into(),
      bloom_filter_size_calculated_by_ndv: bloom_filter_size_calculated_by_ndv.into(),
      null_aware: null_aware.into(),
      sync_filter_size: sync_filter_size.into(),
      build_bf_by_runtime_size: build_bf_by_runtime_size.into(),
    }
  }
}

impl TSerializable for TRuntimeFilterDesc {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TRuntimeFilterDesc> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<exprs::TExpr> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<BTreeMap<types::TPlanNodeId, exprs::TExpr>> = None;
    let mut f_5: Option<bool> = None;
    let mut f_6: Option<bool> = None;
    let mut f_7: Option<bool> = None;
    let mut f_8: Option<TRuntimeFilterType> = None;
    let mut f_9: Option<i64> = None;
    let mut f_10: Option<exprs::TExpr> = None;
    let mut f_11: Option<bool> = None;
    let mut f_12: Option<bool> = None;
    let mut f_13: Option<TMinMaxRuntimeFilterType> = None;
    let mut f_14: Option<bool> = None;
    let mut f_15: Option<bool> = None;
    let mut f_16: Option<bool> = None;
    let mut f_17: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = exprs::TExpr::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<types::TPlanNodeId, exprs::TExpr> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_151 = i_prot.read_i32()?;
            let map_val_152 = exprs::TExpr::read_from_in_protocol(i_prot)?;
            val.insert(map_key_151, map_val_152);
          }
          i_prot.read_map_end()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bool()?;
          f_7 = Some(val);
        },
        8 => {
          let val = TRuntimeFilterType::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_i64()?;
          f_9 = Some(val);
        },
        10 => {
          let val = exprs::TExpr::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_bool()?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_bool()?;
          f_12 = Some(val);
        },
        13 => {
          let val = TMinMaxRuntimeFilterType::read_from_in_protocol(i_prot)?;
          f_13 = Some(val);
        },
        14 => {
          let val = i_prot.read_bool()?;
          f_14 = Some(val);
        },
        15 => {
          let val = i_prot.read_bool()?;
          f_15 = Some(val);
        },
        16 => {
          let val = i_prot.read_bool()?;
          f_16 = Some(val);
        },
        17 => {
          let val = i_prot.read_bool()?;
          f_17 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TRuntimeFilterDesc.filter_id", &f_1)?;
    verify_required_field_exists("TRuntimeFilterDesc.src_expr", &f_2)?;
    verify_required_field_exists("TRuntimeFilterDesc.expr_order", &f_3)?;
    verify_required_field_exists("TRuntimeFilterDesc.plan_id_to_target_expr", &f_4)?;
    verify_required_field_exists("TRuntimeFilterDesc.is_broadcast_join", &f_5)?;
    verify_required_field_exists("TRuntimeFilterDesc.has_local_targets", &f_6)?;
    verify_required_field_exists("TRuntimeFilterDesc.has_remote_targets", &f_7)?;
    verify_required_field_exists("TRuntimeFilterDesc.type_", &f_8)?;
    let ret = TRuntimeFilterDesc {
      filter_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      src_expr: f_2.expect("auto-generated code should have checked for presence of required fields"),
      expr_order: f_3.expect("auto-generated code should have checked for presence of required fields"),
      plan_id_to_target_expr: f_4.expect("auto-generated code should have checked for presence of required fields"),
      is_broadcast_join: f_5.expect("auto-generated code should have checked for presence of required fields"),
      has_local_targets: f_6.expect("auto-generated code should have checked for presence of required fields"),
      has_remote_targets: f_7.expect("auto-generated code should have checked for presence of required fields"),
      type_: f_8.expect("auto-generated code should have checked for presence of required fields"),
      bloom_filter_size_bytes: f_9,
      bitmap_target_expr: f_10,
      bitmap_filter_not_in: f_11,
      opt_remote_rf: f_12,
      min_max_type: f_13,
      bloom_filter_size_calculated_by_ndv: f_14,
      null_aware: f_15,
      sync_filter_size: f_16,
      build_bf_by_runtime_size: f_17,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TRuntimeFilterDesc");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("filter_id", TType::I32, 1))?;
    o_prot.write_i32(self.filter_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("src_expr", TType::Struct, 2))?;
    self.src_expr.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("expr_order", TType::I32, 3))?;
    o_prot.write_i32(self.expr_order)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("planId_to_target_expr", TType::Map, 4))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::I32, TType::Struct, self.plan_id_to_target_expr.len() as i32))?;
    for (k, v) in &self.plan_id_to_target_expr {
      o_prot.write_i32(*k)?;
      v.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_map_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("is_broadcast_join", TType::Bool, 5))?;
    o_prot.write_bool(self.is_broadcast_join)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("has_local_targets", TType::Bool, 6))?;
    o_prot.write_bool(self.has_local_targets)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("has_remote_targets", TType::Bool, 7))?;
    o_prot.write_bool(self.has_remote_targets)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 8))?;
    self.type_.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.bloom_filter_size_bytes {
      o_prot.write_field_begin(&TFieldIdentifier::new("bloom_filter_size_bytes", TType::I64, 9))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.bitmap_target_expr {
      o_prot.write_field_begin(&TFieldIdentifier::new("bitmap_target_expr", TType::Struct, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.bitmap_filter_not_in {
      o_prot.write_field_begin(&TFieldIdentifier::new("bitmap_filter_not_in", TType::Bool, 11))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.opt_remote_rf {
      o_prot.write_field_begin(&TFieldIdentifier::new("opt_remote_rf", TType::Bool, 12))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.min_max_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("min_max_type", TType::I32, 13))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.bloom_filter_size_calculated_by_ndv {
      o_prot.write_field_begin(&TFieldIdentifier::new("bloom_filter_size_calculated_by_ndv", TType::Bool, 14))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.null_aware {
      o_prot.write_field_begin(&TFieldIdentifier::new("null_aware", TType::Bool, 15))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.sync_filter_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("sync_filter_size", TType::Bool, 16))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.build_bf_by_runtime_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("build_bf_by_runtime_size", TType::Bool, 17))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TDataGenScanNode
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDataGenScanNode {
  pub tuple_id: Option<types::TTupleId>,
  pub func_name: Option<TDataGenFunctionName>,
}

impl TDataGenScanNode {
  pub fn new<F1, F2>(tuple_id: F1, func_name: F2) -> TDataGenScanNode where F1: Into<Option<types::TTupleId>>, F2: Into<Option<TDataGenFunctionName>> {
    TDataGenScanNode {
      tuple_id: tuple_id.into(),
      func_name: func_name.into(),
    }
  }
}

impl TSerializable for TDataGenScanNode {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDataGenScanNode> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<types::TTupleId> = None;
    let mut f_2: Option<TDataGenFunctionName> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = TDataGenFunctionName::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TDataGenScanNode {
      tuple_id: f_1,
      func_name: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDataGenScanNode");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.tuple_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("tuple_id", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.func_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("func_name", TType::I32, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TGroupCommitScanNode
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TGroupCommitScanNode {
  pub table_id: Option<i64>,
}

impl TGroupCommitScanNode {
  pub fn new<F1>(table_id: F1) -> TGroupCommitScanNode where F1: Into<Option<i64>> {
    TGroupCommitScanNode {
      table_id: table_id.into(),
    }
  }
}

impl TSerializable for TGroupCommitScanNode {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TGroupCommitScanNode> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TGroupCommitScanNode {
      table_id: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TGroupCommitScanNode");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.table_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_id", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TPlanNode
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TPlanNode {
  pub node_id: types::TPlanNodeId,
  pub node_type: TPlanNodeType,
  pub num_children: i32,
  pub limit: i64,
  pub row_tuples: Vec<types::TTupleId>,
  pub nullable_tuples: Vec<bool>,
  pub conjuncts: Option<Vec<exprs::TExpr>>,
  pub compact_data: bool,
  pub hash_join_node: Option<THashJoinNode>,
  pub agg_node: Option<TAggregationNode>,
  pub sort_node: Option<TSortNode>,
  pub merge_node: Option<TMergeNode>,
  pub exchange_node: Option<TExchangeNode>,
  pub mysql_scan_node: Option<TMySQLScanNode>,
  pub olap_scan_node: Option<TOlapScanNode>,
  pub csv_scan_node: Option<TCsvScanNode>,
  pub broker_scan_node: Option<TBrokerScanNode>,
  pub pre_agg_node: Option<TPreAggregationNode>,
  pub schema_scan_node: Option<TSchemaScanNode>,
  pub merge_join_node: Option<TMergeJoinNode>,
  pub meta_scan_node: Option<TMetaScanNode>,
  pub analytic_node: Option<TAnalyticNode>,
  pub olap_rewrite_node: Option<TOlapRewriteNode>,
  pub union_node: Option<TUnionNode>,
  pub resource_profile: Option<TBackendResourceProfile>,
  pub es_scan_node: Option<TEsScanNode>,
  pub repeat_node: Option<TRepeatNode>,
  pub assert_num_rows_node: Option<TAssertNumRowsNode>,
  pub intersect_node: Option<TIntersectNode>,
  pub except_node: Option<TExceptNode>,
  pub odbc_scan_node: Option<TOdbcScanNode>,
  pub runtime_filters: Option<Vec<TRuntimeFilterDesc>>,
  pub group_commit_scan_node: Option<TGroupCommitScanNode>,
  pub materialization_node: Option<TMaterializationNode>,
  pub vconjunct: Option<exprs::TExpr>,
  pub table_function_node: Option<TTableFunctionNode>,
  pub output_slot_ids: Option<Vec<types::TSlotId>>,
  pub data_gen_scan_node: Option<TDataGenScanNode>,
  pub file_scan_node: Option<TFileScanNode>,
  pub jdbc_scan_node: Option<TJdbcScanNode>,
  pub nested_loop_join_node: Option<TNestedLoopJoinNode>,
  pub test_external_scan_node: Option<TTestExternalScanNode>,
  pub push_down_agg_type_opt: Option<TPushAggOp>,
  pub push_down_count: Option<i64>,
  pub distribute_expr_lists: Option<Vec<Vec<exprs::TExpr>>>,
  pub is_serial_operator: Option<bool>,
  pub projections: Option<Vec<exprs::TExpr>>,
  pub output_tuple_id: Option<types::TTupleId>,
  pub partition_sort_node: Option<TPartitionSortNode>,
  pub intermediate_projections_list: Option<Vec<Vec<exprs::TExpr>>>,
  pub intermediate_output_tuple_id_list: Option<Vec<types::TTupleId>>,
  pub topn_filter_source_node_ids: Option<Vec<i32>>,
  pub nereids_id: Option<i32>,
}

impl TPlanNode {
  pub fn new<F7, F11, F12, F13, F14, F15, F17, F18, F19, F20, F21, F22, F23, F24, F25, F26, F28, F29, F30, F31, F32, F33, F34, F35, F36, F37, F38, F40, F41, F42, F43, F44, F45, F46, F47, F48, F49, F50, F51, F101, F102, F103, F104, F105, F106, F107>(node_id: types::TPlanNodeId, node_type: TPlanNodeType, num_children: i32, limit: i64, row_tuples: Vec<types::TTupleId>, nullable_tuples: Vec<bool>, conjuncts: F7, compact_data: bool, hash_join_node: F11, agg_node: F12, sort_node: F13, merge_node: F14, exchange_node: F15, mysql_scan_node: F17, olap_scan_node: F18, csv_scan_node: F19, broker_scan_node: F20, pre_agg_node: F21, schema_scan_node: F22, merge_join_node: F23, meta_scan_node: F24, analytic_node: F25, olap_rewrite_node: F26, union_node: F28, resource_profile: F29, es_scan_node: F30, repeat_node: F31, assert_num_rows_node: F32, intersect_node: F33, except_node: F34, odbc_scan_node: F35, runtime_filters: F36, group_commit_scan_node: F37, materialization_node: F38, vconjunct: F40, table_function_node: F41, output_slot_ids: F42, data_gen_scan_node: F43, file_scan_node: F44, jdbc_scan_node: F45, nested_loop_join_node: F46, test_external_scan_node: F47, push_down_agg_type_opt: F48, push_down_count: F49, distribute_expr_lists: F50, is_serial_operator: F51, projections: F101, output_tuple_id: F102, partition_sort_node: F103, intermediate_projections_list: F104, intermediate_output_tuple_id_list: F105, topn_filter_source_node_ids: F106, nereids_id: F107) -> TPlanNode where F7: Into<Option<Vec<exprs::TExpr>>>, F11: Into<Option<THashJoinNode>>, F12: Into<Option<TAggregationNode>>, F13: Into<Option<TSortNode>>, F14: Into<Option<TMergeNode>>, F15: Into<Option<TExchangeNode>>, F17: Into<Option<TMySQLScanNode>>, F18: Into<Option<TOlapScanNode>>, F19: Into<Option<TCsvScanNode>>, F20: Into<Option<TBrokerScanNode>>, F21: Into<Option<TPreAggregationNode>>, F22: Into<Option<TSchemaScanNode>>, F23: Into<Option<TMergeJoinNode>>, F24: Into<Option<TMetaScanNode>>, F25: Into<Option<TAnalyticNode>>, F26: Into<Option<TOlapRewriteNode>>, F28: Into<Option<TUnionNode>>, F29: Into<Option<TBackendResourceProfile>>, F30: Into<Option<TEsScanNode>>, F31: Into<Option<TRepeatNode>>, F32: Into<Option<TAssertNumRowsNode>>, F33: Into<Option<TIntersectNode>>, F34: Into<Option<TExceptNode>>, F35: Into<Option<TOdbcScanNode>>, F36: Into<Option<Vec<TRuntimeFilterDesc>>>, F37: Into<Option<TGroupCommitScanNode>>, F38: Into<Option<TMaterializationNode>>, F40: Into<Option<exprs::TExpr>>, F41: Into<Option<TTableFunctionNode>>, F42: Into<Option<Vec<types::TSlotId>>>, F43: Into<Option<TDataGenScanNode>>, F44: Into<Option<TFileScanNode>>, F45: Into<Option<TJdbcScanNode>>, F46: Into<Option<TNestedLoopJoinNode>>, F47: Into<Option<TTestExternalScanNode>>, F48: Into<Option<TPushAggOp>>, F49: Into<Option<i64>>, F50: Into<Option<Vec<Vec<exprs::TExpr>>>>, F51: Into<Option<bool>>, F101: Into<Option<Vec<exprs::TExpr>>>, F102: Into<Option<types::TTupleId>>, F103: Into<Option<TPartitionSortNode>>, F104: Into<Option<Vec<Vec<exprs::TExpr>>>>, F105: Into<Option<Vec<types::TTupleId>>>, F106: Into<Option<Vec<i32>>>, F107: Into<Option<i32>> {
    TPlanNode {
      node_id,
      node_type,
      num_children,
      limit,
      row_tuples,
      nullable_tuples,
      conjuncts: conjuncts.into(),
      compact_data,
      hash_join_node: hash_join_node.into(),
      agg_node: agg_node.into(),
      sort_node: sort_node.into(),
      merge_node: merge_node.into(),
      exchange_node: exchange_node.into(),
      mysql_scan_node: mysql_scan_node.into(),
      olap_scan_node: olap_scan_node.into(),
      csv_scan_node: csv_scan_node.into(),
      broker_scan_node: broker_scan_node.into(),
      pre_agg_node: pre_agg_node.into(),
      schema_scan_node: schema_scan_node.into(),
      merge_join_node: merge_join_node.into(),
      meta_scan_node: meta_scan_node.into(),
      analytic_node: analytic_node.into(),
      olap_rewrite_node: olap_rewrite_node.into(),
      union_node: union_node.into(),
      resource_profile: resource_profile.into(),
      es_scan_node: es_scan_node.into(),
      repeat_node: repeat_node.into(),
      assert_num_rows_node: assert_num_rows_node.into(),
      intersect_node: intersect_node.into(),
      except_node: except_node.into(),
      odbc_scan_node: odbc_scan_node.into(),
      runtime_filters: runtime_filters.into(),
      group_commit_scan_node: group_commit_scan_node.into(),
      materialization_node: materialization_node.into(),
      vconjunct: vconjunct.into(),
      table_function_node: table_function_node.into(),
      output_slot_ids: output_slot_ids.into(),
      data_gen_scan_node: data_gen_scan_node.into(),
      file_scan_node: file_scan_node.into(),
      jdbc_scan_node: jdbc_scan_node.into(),
      nested_loop_join_node: nested_loop_join_node.into(),
      test_external_scan_node: test_external_scan_node.into(),
      push_down_agg_type_opt: push_down_agg_type_opt.into(),
      push_down_count: push_down_count.into(),
      distribute_expr_lists: distribute_expr_lists.into(),
      is_serial_operator: is_serial_operator.into(),
      projections: projections.into(),
      output_tuple_id: output_tuple_id.into(),
      partition_sort_node: partition_sort_node.into(),
      intermediate_projections_list: intermediate_projections_list.into(),
      intermediate_output_tuple_id_list: intermediate_output_tuple_id_list.into(),
      topn_filter_source_node_ids: topn_filter_source_node_ids.into(),
      nereids_id: nereids_id.into(),
    }
  }
}

impl TSerializable for TPlanNode {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TPlanNode> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<types::TPlanNodeId> = None;
    let mut f_2: Option<TPlanNodeType> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<i64> = None;
    let mut f_5: Option<Vec<types::TTupleId>> = None;
    let mut f_6: Option<Vec<bool>> = None;
    let mut f_7: Option<Vec<exprs::TExpr>> = None;
    let mut f_8: Option<bool> = None;
    let mut f_11: Option<THashJoinNode> = None;
    let mut f_12: Option<TAggregationNode> = None;
    let mut f_13: Option<TSortNode> = None;
    let mut f_14: Option<TMergeNode> = None;
    let mut f_15: Option<TExchangeNode> = None;
    let mut f_17: Option<TMySQLScanNode> = None;
    let mut f_18: Option<TOlapScanNode> = None;
    let mut f_19: Option<TCsvScanNode> = None;
    let mut f_20: Option<TBrokerScanNode> = None;
    let mut f_21: Option<TPreAggregationNode> = None;
    let mut f_22: Option<TSchemaScanNode> = None;
    let mut f_23: Option<TMergeJoinNode> = None;
    let mut f_24: Option<TMetaScanNode> = None;
    let mut f_25: Option<TAnalyticNode> = None;
    let mut f_26: Option<TOlapRewriteNode> = None;
    let mut f_28: Option<TUnionNode> = None;
    let mut f_29: Option<TBackendResourceProfile> = None;
    let mut f_30: Option<TEsScanNode> = None;
    let mut f_31: Option<TRepeatNode> = None;
    let mut f_32: Option<TAssertNumRowsNode> = None;
    let mut f_33: Option<TIntersectNode> = None;
    let mut f_34: Option<TExceptNode> = None;
    let mut f_35: Option<TOdbcScanNode> = None;
    let mut f_36: Option<Vec<TRuntimeFilterDesc>> = None;
    let mut f_37: Option<TGroupCommitScanNode> = None;
    let mut f_38: Option<TMaterializationNode> = None;
    let mut f_40: Option<exprs::TExpr> = None;
    let mut f_41: Option<TTableFunctionNode> = None;
    let mut f_42: Option<Vec<types::TSlotId>> = None;
    let mut f_43: Option<TDataGenScanNode> = None;
    let mut f_44: Option<TFileScanNode> = None;
    let mut f_45: Option<TJdbcScanNode> = None;
    let mut f_46: Option<TNestedLoopJoinNode> = None;
    let mut f_47: Option<TTestExternalScanNode> = None;
    let mut f_48: Option<TPushAggOp> = None;
    let mut f_49: Option<i64> = None;
    let mut f_50: Option<Vec<Vec<exprs::TExpr>>> = None;
    let mut f_51: Option<bool> = None;
    let mut f_101: Option<Vec<exprs::TExpr>> = None;
    let mut f_102: Option<types::TTupleId> = None;
    let mut f_103: Option<TPartitionSortNode> = None;
    let mut f_104: Option<Vec<Vec<exprs::TExpr>>> = None;
    let mut f_105: Option<Vec<types::TTupleId>> = None;
    let mut f_106: Option<Vec<i32>> = None;
    let mut f_107: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = TPlanNodeType::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::TTupleId> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_153 = i_prot.read_i32()?;
            val.push(list_elem_153);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<bool> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_154 = i_prot.read_bool()?;
            val.push(list_elem_154);
          }
          i_prot.read_list_end()?;
          f_6 = Some(val);
        },
        7 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<exprs::TExpr> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_155 = exprs::TExpr::read_from_in_protocol(i_prot)?;
            val.push(list_elem_155);
          }
          i_prot.read_list_end()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_bool()?;
          f_8 = Some(val);
        },
        11 => {
          let val = THashJoinNode::read_from_in_protocol(i_prot)?;
          f_11 = Some(val);
        },
        12 => {
          let val = TAggregationNode::read_from_in_protocol(i_prot)?;
          f_12 = Some(val);
        },
        13 => {
          let val = TSortNode::read_from_in_protocol(i_prot)?;
          f_13 = Some(val);
        },
        14 => {
          let val = TMergeNode::read_from_in_protocol(i_prot)?;
          f_14 = Some(val);
        },
        15 => {
          let val = TExchangeNode::read_from_in_protocol(i_prot)?;
          f_15 = Some(val);
        },
        17 => {
          let val = TMySQLScanNode::read_from_in_protocol(i_prot)?;
          f_17 = Some(val);
        },
        18 => {
          let val = TOlapScanNode::read_from_in_protocol(i_prot)?;
          f_18 = Some(val);
        },
        19 => {
          let val = TCsvScanNode::read_from_in_protocol(i_prot)?;
          f_19 = Some(val);
        },
        20 => {
          let val = TBrokerScanNode::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        21 => {
          let val = TPreAggregationNode::read_from_in_protocol(i_prot)?;
          f_21 = Some(val);
        },
        22 => {
          let val = TSchemaScanNode::read_from_in_protocol(i_prot)?;
          f_22 = Some(val);
        },
        23 => {
          let val = TMergeJoinNode::read_from_in_protocol(i_prot)?;
          f_23 = Some(val);
        },
        24 => {
          let val = TMetaScanNode::read_from_in_protocol(i_prot)?;
          f_24 = Some(val);
        },
        25 => {
          let val = TAnalyticNode::read_from_in_protocol(i_prot)?;
          f_25 = Some(val);
        },
        26 => {
          let val = TOlapRewriteNode::read_from_in_protocol(i_prot)?;
          f_26 = Some(val);
        },
        28 => {
          let val = TUnionNode::read_from_in_protocol(i_prot)?;
          f_28 = Some(val);
        },
        29 => {
          let val = TBackendResourceProfile::read_from_in_protocol(i_prot)?;
          f_29 = Some(val);
        },
        30 => {
          let val = TEsScanNode::read_from_in_protocol(i_prot)?;
          f_30 = Some(val);
        },
        31 => {
          let val = TRepeatNode::read_from_in_protocol(i_prot)?;
          f_31 = Some(val);
        },
        32 => {
          let val = TAssertNumRowsNode::read_from_in_protocol(i_prot)?;
          f_32 = Some(val);
        },
        33 => {
          let val = TIntersectNode::read_from_in_protocol(i_prot)?;
          f_33 = Some(val);
        },
        34 => {
          let val = TExceptNode::read_from_in_protocol(i_prot)?;
          f_34 = Some(val);
        },
        35 => {
          let val = TOdbcScanNode::read_from_in_protocol(i_prot)?;
          f_35 = Some(val);
        },
        36 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TRuntimeFilterDesc> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_156 = TRuntimeFilterDesc::read_from_in_protocol(i_prot)?;
            val.push(list_elem_156);
          }
          i_prot.read_list_end()?;
          f_36 = Some(val);
        },
        37 => {
          let val = TGroupCommitScanNode::read_from_in_protocol(i_prot)?;
          f_37 = Some(val);
        },
        38 => {
          let val = TMaterializationNode::read_from_in_protocol(i_prot)?;
          f_38 = Some(val);
        },
        40 => {
          let val = exprs::TExpr::read_from_in_protocol(i_prot)?;
          f_40 = Some(val);
        },
        41 => {
          let val = TTableFunctionNode::read_from_in_protocol(i_prot)?;
          f_41 = Some(val);
        },
        42 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::TSlotId> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_157 = i_prot.read_i32()?;
            val.push(list_elem_157);
          }
          i_prot.read_list_end()?;
          f_42 = Some(val);
        },
        43 => {
          let val = TDataGenScanNode::read_from_in_protocol(i_prot)?;
          f_43 = Some(val);
        },
        44 => {
          let val = TFileScanNode::read_from_in_protocol(i_prot)?;
          f_44 = Some(val);
        },
        45 => {
          let val = TJdbcScanNode::read_from_in_protocol(i_prot)?;
          f_45 = Some(val);
        },
        46 => {
          let val = TNestedLoopJoinNode::read_from_in_protocol(i_prot)?;
          f_46 = Some(val);
        },
        47 => {
          let val = TTestExternalScanNode::read_from_in_protocol(i_prot)?;
          f_47 = Some(val);
        },
        48 => {
          let val = TPushAggOp::read_from_in_protocol(i_prot)?;
          f_48 = Some(val);
        },
        49 => {
          let val = i_prot.read_i64()?;
          f_49 = Some(val);
        },
        50 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<exprs::TExpr>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_ident = i_prot.read_list_begin()?;
            let mut list_elem_158: Vec<exprs::TExpr> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_159 = exprs::TExpr::read_from_in_protocol(i_prot)?;
              list_elem_158.push(list_elem_159);
            }
            i_prot.read_list_end()?;
            val.push(list_elem_158);
          }
          i_prot.read_list_end()?;
          f_50 = Some(val);
        },
        51 => {
          let val = i_prot.read_bool()?;
          f_51 = Some(val);
        },
        101 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<exprs::TExpr> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_160 = exprs::TExpr::read_from_in_protocol(i_prot)?;
            val.push(list_elem_160);
          }
          i_prot.read_list_end()?;
          f_101 = Some(val);
        },
        102 => {
          let val = i_prot.read_i32()?;
          f_102 = Some(val);
        },
        103 => {
          let val = TPartitionSortNode::read_from_in_protocol(i_prot)?;
          f_103 = Some(val);
        },
        104 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<exprs::TExpr>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_ident = i_prot.read_list_begin()?;
            let mut list_elem_161: Vec<exprs::TExpr> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_162 = exprs::TExpr::read_from_in_protocol(i_prot)?;
              list_elem_161.push(list_elem_162);
            }
            i_prot.read_list_end()?;
            val.push(list_elem_161);
          }
          i_prot.read_list_end()?;
          f_104 = Some(val);
        },
        105 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::TTupleId> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_163 = i_prot.read_i32()?;
            val.push(list_elem_163);
          }
          i_prot.read_list_end()?;
          f_105 = Some(val);
        },
        106 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_164 = i_prot.read_i32()?;
            val.push(list_elem_164);
          }
          i_prot.read_list_end()?;
          f_106 = Some(val);
        },
        107 => {
          let val = i_prot.read_i32()?;
          f_107 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TPlanNode.node_id", &f_1)?;
    verify_required_field_exists("TPlanNode.node_type", &f_2)?;
    verify_required_field_exists("TPlanNode.num_children", &f_3)?;
    verify_required_field_exists("TPlanNode.limit", &f_4)?;
    verify_required_field_exists("TPlanNode.row_tuples", &f_5)?;
    verify_required_field_exists("TPlanNode.nullable_tuples", &f_6)?;
    verify_required_field_exists("TPlanNode.compact_data", &f_8)?;
    let ret = TPlanNode {
      node_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      node_type: f_2.expect("auto-generated code should have checked for presence of required fields"),
      num_children: f_3.expect("auto-generated code should have checked for presence of required fields"),
      limit: f_4.expect("auto-generated code should have checked for presence of required fields"),
      row_tuples: f_5.expect("auto-generated code should have checked for presence of required fields"),
      nullable_tuples: f_6.expect("auto-generated code should have checked for presence of required fields"),
      conjuncts: f_7,
      compact_data: f_8.expect("auto-generated code should have checked for presence of required fields"),
      hash_join_node: f_11,
      agg_node: f_12,
      sort_node: f_13,
      merge_node: f_14,
      exchange_node: f_15,
      mysql_scan_node: f_17,
      olap_scan_node: f_18,
      csv_scan_node: f_19,
      broker_scan_node: f_20,
      pre_agg_node: f_21,
      schema_scan_node: f_22,
      merge_join_node: f_23,
      meta_scan_node: f_24,
      analytic_node: f_25,
      olap_rewrite_node: f_26,
      union_node: f_28,
      resource_profile: f_29,
      es_scan_node: f_30,
      repeat_node: f_31,
      assert_num_rows_node: f_32,
      intersect_node: f_33,
      except_node: f_34,
      odbc_scan_node: f_35,
      runtime_filters: f_36,
      group_commit_scan_node: f_37,
      materialization_node: f_38,
      vconjunct: f_40,
      table_function_node: f_41,
      output_slot_ids: f_42,
      data_gen_scan_node: f_43,
      file_scan_node: f_44,
      jdbc_scan_node: f_45,
      nested_loop_join_node: f_46,
      test_external_scan_node: f_47,
      push_down_agg_type_opt: f_48,
      push_down_count: f_49,
      distribute_expr_lists: f_50,
      is_serial_operator: f_51,
      projections: f_101,
      output_tuple_id: f_102,
      partition_sort_node: f_103,
      intermediate_projections_list: f_104,
      intermediate_output_tuple_id_list: f_105,
      topn_filter_source_node_ids: f_106,
      nereids_id: f_107,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TPlanNode");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("node_id", TType::I32, 1))?;
    o_prot.write_i32(self.node_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("node_type", TType::I32, 2))?;
    self.node_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("num_children", TType::I32, 3))?;
    o_prot.write_i32(self.num_children)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("limit", TType::I64, 4))?;
    o_prot.write_i64(self.limit)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("row_tuples", TType::List, 5))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I32, self.row_tuples.len() as i32))?;
    for e in &self.row_tuples {
      o_prot.write_i32(*e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("nullable_tuples", TType::List, 6))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Bool, self.nullable_tuples.len() as i32))?;
    for e in &self.nullable_tuples {
      o_prot.write_bool(*e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.conjuncts {
      o_prot.write_field_begin(&TFieldIdentifier::new("conjuncts", TType::List, 7))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_begin(&TFieldIdentifier::new("compact_data", TType::Bool, 8))?;
    o_prot.write_bool(self.compact_data)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.hash_join_node {
      o_prot.write_field_begin(&TFieldIdentifier::new("hash_join_node", TType::Struct, 11))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.agg_node {
      o_prot.write_field_begin(&TFieldIdentifier::new("agg_node", TType::Struct, 12))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.sort_node {
      o_prot.write_field_begin(&TFieldIdentifier::new("sort_node", TType::Struct, 13))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.merge_node {
      o_prot.write_field_begin(&TFieldIdentifier::new("merge_node", TType::Struct, 14))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.exchange_node {
      o_prot.write_field_begin(&TFieldIdentifier::new("exchange_node", TType::Struct, 15))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.mysql_scan_node {
      o_prot.write_field_begin(&TFieldIdentifier::new("mysql_scan_node", TType::Struct, 17))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.olap_scan_node {
      o_prot.write_field_begin(&TFieldIdentifier::new("olap_scan_node", TType::Struct, 18))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.csv_scan_node {
      o_prot.write_field_begin(&TFieldIdentifier::new("csv_scan_node", TType::Struct, 19))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.broker_scan_node {
      o_prot.write_field_begin(&TFieldIdentifier::new("broker_scan_node", TType::Struct, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.pre_agg_node {
      o_prot.write_field_begin(&TFieldIdentifier::new("pre_agg_node", TType::Struct, 21))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.schema_scan_node {
      o_prot.write_field_begin(&TFieldIdentifier::new("schema_scan_node", TType::Struct, 22))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.merge_join_node {
      o_prot.write_field_begin(&TFieldIdentifier::new("merge_join_node", TType::Struct, 23))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.meta_scan_node {
      o_prot.write_field_begin(&TFieldIdentifier::new("meta_scan_node", TType::Struct, 24))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.analytic_node {
      o_prot.write_field_begin(&TFieldIdentifier::new("analytic_node", TType::Struct, 25))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.olap_rewrite_node {
      o_prot.write_field_begin(&TFieldIdentifier::new("olap_rewrite_node", TType::Struct, 26))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.union_node {
      o_prot.write_field_begin(&TFieldIdentifier::new("union_node", TType::Struct, 28))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.resource_profile {
      o_prot.write_field_begin(&TFieldIdentifier::new("resource_profile", TType::Struct, 29))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.es_scan_node {
      o_prot.write_field_begin(&TFieldIdentifier::new("es_scan_node", TType::Struct, 30))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.repeat_node {
      o_prot.write_field_begin(&TFieldIdentifier::new("repeat_node", TType::Struct, 31))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.assert_num_rows_node {
      o_prot.write_field_begin(&TFieldIdentifier::new("assert_num_rows_node", TType::Struct, 32))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.intersect_node {
      o_prot.write_field_begin(&TFieldIdentifier::new("intersect_node", TType::Struct, 33))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.except_node {
      o_prot.write_field_begin(&TFieldIdentifier::new("except_node", TType::Struct, 34))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.odbc_scan_node {
      o_prot.write_field_begin(&TFieldIdentifier::new("odbc_scan_node", TType::Struct, 35))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.runtime_filters {
      o_prot.write_field_begin(&TFieldIdentifier::new("runtime_filters", TType::List, 36))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.group_commit_scan_node {
      o_prot.write_field_begin(&TFieldIdentifier::new("group_commit_scan_node", TType::Struct, 37))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.materialization_node {
      o_prot.write_field_begin(&TFieldIdentifier::new("materialization_node", TType::Struct, 38))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.vconjunct {
      o_prot.write_field_begin(&TFieldIdentifier::new("vconjunct", TType::Struct, 40))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.table_function_node {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_function_node", TType::Struct, 41))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.output_slot_ids {
      o_prot.write_field_begin(&TFieldIdentifier::new("output_slot_ids", TType::List, 42))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I32, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i32(*e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.data_gen_scan_node {
      o_prot.write_field_begin(&TFieldIdentifier::new("data_gen_scan_node", TType::Struct, 43))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.file_scan_node {
      o_prot.write_field_begin(&TFieldIdentifier::new("file_scan_node", TType::Struct, 44))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.jdbc_scan_node {
      o_prot.write_field_begin(&TFieldIdentifier::new("jdbc_scan_node", TType::Struct, 45))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.nested_loop_join_node {
      o_prot.write_field_begin(&TFieldIdentifier::new("nested_loop_join_node", TType::Struct, 46))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.test_external_scan_node {
      o_prot.write_field_begin(&TFieldIdentifier::new("test_external_scan_node", TType::Struct, 47))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.push_down_agg_type_opt {
      o_prot.write_field_begin(&TFieldIdentifier::new("push_down_agg_type_opt", TType::I32, 48))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.push_down_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("push_down_count", TType::I64, 49))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.distribute_expr_lists {
      o_prot.write_field_begin(&TFieldIdentifier::new("distribute_expr_lists", TType::List, 50))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::List, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, e.len() as i32))?;
        for e in e {
          e.write_to_out_protocol(o_prot)?;
        }
        o_prot.write_list_end()?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_serial_operator {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_serial_operator", TType::Bool, 51))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.projections {
      o_prot.write_field_begin(&TFieldIdentifier::new("projections", TType::List, 101))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.output_tuple_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("output_tuple_id", TType::I32, 102))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.partition_sort_node {
      o_prot.write_field_begin(&TFieldIdentifier::new("partition_sort_node", TType::Struct, 103))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.intermediate_projections_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("intermediate_projections_list", TType::List, 104))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::List, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, e.len() as i32))?;
        for e in e {
          e.write_to_out_protocol(o_prot)?;
        }
        o_prot.write_list_end()?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.intermediate_output_tuple_id_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("intermediate_output_tuple_id_list", TType::List, 105))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I32, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i32(*e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.topn_filter_source_node_ids {
      o_prot.write_field_begin(&TFieldIdentifier::new("topn_filter_source_node_ids", TType::List, 106))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I32, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i32(*e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.nereids_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("nereids_id", TType::I32, 107))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TPlan
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TPlan {
  pub nodes: Vec<TPlanNode>,
}

impl TPlan {
  pub fn new(nodes: Vec<TPlanNode>) -> TPlan {
    TPlan {
      nodes,
    }
  }
}

impl TSerializable for TPlan {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TPlan> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<TPlanNode>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TPlanNode> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_165 = TPlanNode::read_from_in_protocol(i_prot)?;
            val.push(list_elem_165);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TPlan.nodes", &f_1)?;
    let ret = TPlan {
      nodes: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TPlan");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("nodes", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.nodes.len() as i32))?;
    for e in &self.nodes {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

