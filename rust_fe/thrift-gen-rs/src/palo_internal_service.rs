// Autogenerated by Thrift Compiler (0.19.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(dead_code)]
#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![allow(clippy::too_many_arguments, clippy::type_complexity, clippy::vec_box, clippy::wrong_self_convention)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;

use thrift::OrderedFloat;
use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSerializable, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

use crate::data;
use crate::data_sinks;
use crate::descriptors;
use crate::exprs;
use crate::plan_nodes;
use crate::planner;
use crate::runtime_profile;
use crate::status;
use crate::types;

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TQueryType(pub i32);

impl TQueryType {
  pub const SELECT: TQueryType = TQueryType(0);
  pub const LOAD: TQueryType = TQueryType(1);
  pub const EXTERNAL: TQueryType = TQueryType(2);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::SELECT,
    Self::LOAD,
    Self::EXTERNAL,
  ];
}

impl TSerializable for TQueryType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TQueryType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TQueryType::from(enum_value))
  }
}

impl From<i32> for TQueryType {
  fn from(i: i32) -> Self {
    match i {
      0 => TQueryType::SELECT,
      1 => TQueryType::LOAD,
      2 => TQueryType::EXTERNAL,
      _ => TQueryType(i)
    }
  }
}

impl From<&i32> for TQueryType {
  fn from(i: &i32) -> Self {
    TQueryType::from(*i)
  }
}

impl From<TQueryType> for i32 {
  fn from(e: TQueryType) -> i32 {
    e.0
  }
}

impl From<&TQueryType> for i32 {
  fn from(e: &TQueryType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TErrorHubType(pub i32);

impl TErrorHubType {
  pub const MYSQL: TErrorHubType = TErrorHubType(0);
  pub const BROKER: TErrorHubType = TErrorHubType(1);
  pub const NULL_TYPE: TErrorHubType = TErrorHubType(2);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::MYSQL,
    Self::BROKER,
    Self::NULL_TYPE,
  ];
}

impl TSerializable for TErrorHubType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TErrorHubType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TErrorHubType::from(enum_value))
  }
}

impl From<i32> for TErrorHubType {
  fn from(i: i32) -> Self {
    match i {
      0 => TErrorHubType::MYSQL,
      1 => TErrorHubType::BROKER,
      2 => TErrorHubType::NULL_TYPE,
      _ => TErrorHubType(i)
    }
  }
}

impl From<&i32> for TErrorHubType {
  fn from(i: &i32) -> Self {
    TErrorHubType::from(*i)
  }
}

impl From<TErrorHubType> for i32 {
  fn from(e: TErrorHubType) -> i32 {
    e.0
  }
}

impl From<&TErrorHubType> for i32 {
  fn from(e: &TErrorHubType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TPrefetchMode(pub i32);

impl TPrefetchMode {
  pub const NONE: TPrefetchMode = TPrefetchMode(0);
  pub const HT_BUCKET: TPrefetchMode = TPrefetchMode(1);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::HT_BUCKET,
  ];
}

impl TSerializable for TPrefetchMode {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TPrefetchMode> {
    let enum_value = i_prot.read_i32()?;
    Ok(TPrefetchMode::from(enum_value))
  }
}

impl From<i32> for TPrefetchMode {
  fn from(i: i32) -> Self {
    match i {
      0 => TPrefetchMode::NONE,
      1 => TPrefetchMode::HT_BUCKET,
      _ => TPrefetchMode(i)
    }
  }
}

impl From<&i32> for TPrefetchMode {
  fn from(i: &i32) -> Self {
    TPrefetchMode::from(*i)
  }
}

impl From<TPrefetchMode> for i32 {
  fn from(e: TPrefetchMode) -> i32 {
    e.0
  }
}

impl From<&TPrefetchMode> for i32 {
  fn from(e: &TPrefetchMode) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSerdeDialect(pub i32);

impl TSerdeDialect {
  pub const DORIS: TSerdeDialect = TSerdeDialect(0);
  pub const PRESTO: TSerdeDialect = TSerdeDialect(1);
  pub const HIVE: TSerdeDialect = TSerdeDialect(2);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::DORIS,
    Self::PRESTO,
    Self::HIVE,
  ];
}

impl TSerializable for TSerdeDialect {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSerdeDialect> {
    let enum_value = i_prot.read_i32()?;
    Ok(TSerdeDialect::from(enum_value))
  }
}

impl From<i32> for TSerdeDialect {
  fn from(i: i32) -> Self {
    match i {
      0 => TSerdeDialect::DORIS,
      1 => TSerdeDialect::PRESTO,
      2 => TSerdeDialect::HIVE,
      _ => TSerdeDialect(i)
    }
  }
}

impl From<&i32> for TSerdeDialect {
  fn from(i: &i32) -> Self {
    TSerdeDialect::from(*i)
  }
}

impl From<TSerdeDialect> for i32 {
  fn from(e: TSerdeDialect) -> i32 {
    e.0
  }
}

impl From<&TSerdeDialect> for i32 {
  fn from(e: &TSerdeDialect) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PaloInternalServiceVersion(pub i32);

impl PaloInternalServiceVersion {
  pub const V1: PaloInternalServiceVersion = PaloInternalServiceVersion(0);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::V1,
  ];
}

impl TSerializable for PaloInternalServiceVersion {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PaloInternalServiceVersion> {
    let enum_value = i_prot.read_i32()?;
    Ok(PaloInternalServiceVersion::from(enum_value))
  }
}

impl From<i32> for PaloInternalServiceVersion {
  fn from(i: i32) -> Self {
    match i {
      0 => PaloInternalServiceVersion::V1,
      _ => PaloInternalServiceVersion(i)
    }
  }
}

impl From<&i32> for PaloInternalServiceVersion {
  fn from(i: &i32) -> Self {
    PaloInternalServiceVersion::from(*i)
  }
}

impl From<PaloInternalServiceVersion> for i32 {
  fn from(e: PaloInternalServiceVersion) -> i32 {
    e.0
  }
}

impl From<&PaloInternalServiceVersion> for i32 {
  fn from(e: &PaloInternalServiceVersion) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TCompoundType(pub i32);

impl TCompoundType {
  pub const UNKNOWN: TCompoundType = TCompoundType(0);
  pub const AND: TCompoundType = TCompoundType(1);
  pub const OR: TCompoundType = TCompoundType(2);
  pub const NOT: TCompoundType = TCompoundType(3);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::UNKNOWN,
    Self::AND,
    Self::OR,
    Self::NOT,
  ];
}

impl TSerializable for TCompoundType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCompoundType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TCompoundType::from(enum_value))
  }
}

impl From<i32> for TCompoundType {
  fn from(i: i32) -> Self {
    match i {
      0 => TCompoundType::UNKNOWN,
      1 => TCompoundType::AND,
      2 => TCompoundType::OR,
      3 => TCompoundType::NOT,
      _ => TCompoundType(i)
    }
  }
}

impl From<&i32> for TCompoundType {
  fn from(i: &i32) -> Self {
    TCompoundType::from(*i)
  }
}

impl From<TCompoundType> for i32 {
  fn from(e: TCompoundType) -> i32 {
    e.0
  }
}

impl From<&TCompoundType> for i32 {
  fn from(e: &TCompoundType) -> i32 {
    e.0
  }
}

//
// TMysqlErrorHubInfo
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TMysqlErrorHubInfo {
  pub host: String,
  pub port: i32,
  pub user: String,
  pub passwd: String,
  pub db: String,
  pub table: String,
}

impl TMysqlErrorHubInfo {
  pub fn new(host: String, port: i32, user: String, passwd: String, db: String, table: String) -> TMysqlErrorHubInfo {
    TMysqlErrorHubInfo {
      host,
      port,
      user,
      passwd,
      db,
      table,
    }
  }
}

impl TSerializable for TMysqlErrorHubInfo {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TMysqlErrorHubInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TMysqlErrorHubInfo.host", &f_1)?;
    verify_required_field_exists("TMysqlErrorHubInfo.port", &f_2)?;
    verify_required_field_exists("TMysqlErrorHubInfo.user", &f_3)?;
    verify_required_field_exists("TMysqlErrorHubInfo.passwd", &f_4)?;
    verify_required_field_exists("TMysqlErrorHubInfo.db", &f_5)?;
    verify_required_field_exists("TMysqlErrorHubInfo.table", &f_6)?;
    let ret = TMysqlErrorHubInfo {
      host: f_1.expect("auto-generated code should have checked for presence of required fields"),
      port: f_2.expect("auto-generated code should have checked for presence of required fields"),
      user: f_3.expect("auto-generated code should have checked for presence of required fields"),
      passwd: f_4.expect("auto-generated code should have checked for presence of required fields"),
      db: f_5.expect("auto-generated code should have checked for presence of required fields"),
      table: f_6.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TMysqlErrorHubInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("host", TType::String, 1))?;
    o_prot.write_string(&self.host)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("port", TType::I32, 2))?;
    o_prot.write_i32(self.port)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("user", TType::String, 3))?;
    o_prot.write_string(&self.user)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("passwd", TType::String, 4))?;
    o_prot.write_string(&self.passwd)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("db", TType::String, 5))?;
    o_prot.write_string(&self.db)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table", TType::String, 6))?;
    o_prot.write_string(&self.table)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TBrokerErrorHubInfo
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TBrokerErrorHubInfo {
  pub broker_addr: types::TNetworkAddress,
  pub path: String,
  pub prop: BTreeMap<String, String>,
}

impl TBrokerErrorHubInfo {
  pub fn new(broker_addr: types::TNetworkAddress, path: String, prop: BTreeMap<String, String>) -> TBrokerErrorHubInfo {
    TBrokerErrorHubInfo {
      broker_addr,
      path,
      prop,
    }
  }
}

impl TSerializable for TBrokerErrorHubInfo {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TBrokerErrorHubInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<types::TNetworkAddress> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<BTreeMap<String, String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = types::TNetworkAddress::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_0 = i_prot.read_string()?;
            let map_val_1 = i_prot.read_string()?;
            val.insert(map_key_0, map_val_1);
          }
          i_prot.read_map_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TBrokerErrorHubInfo.broker_addr", &f_1)?;
    verify_required_field_exists("TBrokerErrorHubInfo.path", &f_2)?;
    verify_required_field_exists("TBrokerErrorHubInfo.prop", &f_3)?;
    let ret = TBrokerErrorHubInfo {
      broker_addr: f_1.expect("auto-generated code should have checked for presence of required fields"),
      path: f_2.expect("auto-generated code should have checked for presence of required fields"),
      prop: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TBrokerErrorHubInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("broker_addr", TType::Struct, 1))?;
    self.broker_addr.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("path", TType::String, 2))?;
    o_prot.write_string(&self.path)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("prop", TType::Map, 3))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, self.prop.len() as i32))?;
    for (k, v) in &self.prop {
      o_prot.write_string(k)?;
      o_prot.write_string(v)?;
    }
    o_prot.write_map_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TLoadErrorHubInfo
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TLoadErrorHubInfo {
  pub type_: TErrorHubType,
  pub mysql_info: Option<TMysqlErrorHubInfo>,
  pub broker_info: Option<TBrokerErrorHubInfo>,
}

impl TLoadErrorHubInfo {
  pub fn new<F2, F3>(type_: TErrorHubType, mysql_info: F2, broker_info: F3) -> TLoadErrorHubInfo where F2: Into<Option<TMysqlErrorHubInfo>>, F3: Into<Option<TBrokerErrorHubInfo>> {
    TLoadErrorHubInfo {
      type_,
      mysql_info: mysql_info.into(),
      broker_info: broker_info.into(),
    }
  }
}

impl TSerializable for TLoadErrorHubInfo {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TLoadErrorHubInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TErrorHubType> = None;
    let mut f_2: Option<TMysqlErrorHubInfo> = None;
    let mut f_3: Option<TBrokerErrorHubInfo> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TErrorHubType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = TMysqlErrorHubInfo::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = TBrokerErrorHubInfo::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TLoadErrorHubInfo.type_", &f_1)?;
    let ret = TLoadErrorHubInfo {
      type_: f_1.expect("auto-generated code should have checked for presence of required fields"),
      mysql_info: f_2,
      broker_info: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TLoadErrorHubInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 1))?;
    self.type_.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.mysql_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("mysql_info", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.broker_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("broker_info", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TResourceLimit
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TResourceLimit {
  pub cpu_limit: Option<i32>,
}

impl TResourceLimit {
  pub fn new<F1>(cpu_limit: F1) -> TResourceLimit where F1: Into<Option<i32>> {
    TResourceLimit {
      cpu_limit: cpu_limit.into(),
    }
  }
}

impl TSerializable for TResourceLimit {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TResourceLimit> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TResourceLimit {
      cpu_limit: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TResourceLimit");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.cpu_limit {
      o_prot.write_field_begin(&TFieldIdentifier::new("cpu_limit", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TQueryOptions
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TQueryOptions {
  pub abort_on_error: Option<bool>,
  pub max_errors: Option<i32>,
  pub disable_codegen: Option<bool>,
  pub batch_size: Option<i32>,
  pub num_nodes: Option<i32>,
  pub max_scan_range_length: Option<i64>,
  pub num_scanner_threads: Option<i32>,
  pub max_io_buffers: Option<i32>,
  pub allow_unsupported_formats: Option<bool>,
  pub default_order_by_limit: Option<i64>,
  pub mem_limit: Option<i64>,
  pub abort_on_default_limit_exceeded: Option<bool>,
  pub query_timeout: Option<i32>,
  pub is_report_success: Option<bool>,
  pub codegen_level: Option<i32>,
  pub kudu_latest_observed_ts: Option<i64>,
  pub query_type: Option<TQueryType>,
  pub min_reservation: Option<i64>,
  pub max_reservation: Option<i64>,
  pub initial_reservation_total_claims: Option<i64>,
  pub buffer_pool_limit: Option<i64>,
  pub default_spillable_buffer_size: Option<i64>,
  pub min_spillable_buffer_size: Option<i64>,
  pub max_row_size: Option<i64>,
  pub disable_stream_preaggregations: Option<bool>,
  pub mt_dop: Option<i32>,
  pub load_mem_limit: Option<i64>,
  pub max_scan_key_num: Option<i32>,
  pub max_pushdown_conditions_per_column: Option<i32>,
  pub enable_spilling: Option<bool>,
  pub enable_enable_exchange_node_parallel_merge: Option<bool>,
  pub runtime_filter_wait_time_ms: Option<i32>,
  pub runtime_filter_max_in_num: Option<i32>,
  pub resource_limit: Option<TResourceLimit>,
  pub return_object_data_as_binary: Option<bool>,
  pub trim_tailing_spaces_for_external_table_query: Option<bool>,
  pub enable_function_pushdown: Option<bool>,
  pub fragment_transmission_compression_codec: Option<String>,
  pub enable_local_exchange: Option<bool>,
  pub skip_storage_engine_merge: Option<bool>,
  pub skip_delete_predicate: Option<bool>,
  pub enable_new_shuffle_hash_method: Option<bool>,
  pub be_exec_version: Option<i32>,
  pub partitioned_hash_join_rows_threshold: Option<i32>,
  pub enable_share_hash_table_for_broadcast_join: Option<bool>,
  pub check_overflow_for_decimal: Option<bool>,
  pub skip_delete_bitmap: Option<bool>,
  pub enable_pipeline_engine: Option<bool>,
  pub repeat_max_num: Option<i32>,
  pub external_sort_bytes_threshold: Option<i64>,
  pub partitioned_hash_agg_rows_threshold: Option<i32>,
  pub enable_file_cache: Option<bool>,
  pub insert_timeout: Option<i32>,
  pub execution_timeout: Option<i32>,
  pub dry_run_query: Option<bool>,
  pub enable_common_expr_pushdown: Option<bool>,
  pub parallel_instance: Option<i32>,
  pub mysql_row_binary_format: Option<bool>,
  pub external_agg_bytes_threshold: Option<i64>,
  pub external_agg_partition_bits: Option<i32>,
  pub file_cache_base_path: Option<String>,
  pub enable_parquet_lazy_mat: Option<bool>,
  pub enable_orc_lazy_mat: Option<bool>,
  pub scan_queue_mem_limit: Option<i64>,
  pub enable_scan_node_run_serial: Option<bool>,
  pub enable_insert_strict: Option<bool>,
  pub enable_inverted_index_query: Option<bool>,
  pub truncate_char_or_varchar_columns: Option<bool>,
  pub enable_hash_join_early_start_probe: Option<bool>,
  pub enable_pipeline_x_engine: Option<bool>,
  pub enable_memtable_on_sink_node: Option<bool>,
  pub enable_delete_sub_predicate_v2: Option<bool>,
  pub fe_process_uuid: Option<i64>,
  pub inverted_index_conjunction_opt_threshold: Option<i32>,
  pub enable_profile: Option<bool>,
  pub enable_page_cache: Option<bool>,
  pub analyze_timeout: Option<i32>,
  pub faster_float_convert: Option<bool>,
  pub enable_decimal256: Option<bool>,
  pub enable_local_shuffle: Option<bool>,
  pub skip_missing_version: Option<bool>,
  pub runtime_filter_wait_infinitely: Option<bool>,
  pub condition_cache_digest: Option<i32>,
  pub inverted_index_max_expansions: Option<i32>,
  pub inverted_index_skip_threshold: Option<i32>,
  pub enable_parallel_scan: Option<bool>,
  pub parallel_scan_max_scanners_count: Option<i32>,
  pub parallel_scan_min_rows_per_scanner: Option<i64>,
  pub skip_bad_tablet: Option<bool>,
  pub scanner_scale_up_ratio: Option<OrderedFloat<f64>>,
  pub enable_distinct_streaming_aggregation: Option<bool>,
  pub enable_join_spill: Option<bool>,
  pub enable_sort_spill: Option<bool>,
  pub enable_agg_spill: Option<bool>,
  pub min_revocable_mem: Option<i64>,
  pub spill_streaming_agg_mem_limit: Option<i64>,
  pub data_queue_max_blocks: Option<i64>,
  pub enable_common_expr_pushdown_for_inverted_index: Option<bool>,
  pub local_exchange_free_blocks_limit: Option<i64>,
  pub enable_force_spill: Option<bool>,
  pub enable_parquet_filter_by_min_max: Option<bool>,
  pub enable_orc_filter_by_min_max: Option<bool>,
  pub max_column_reader_num: Option<i32>,
  pub enable_local_merge_sort: Option<bool>,
  pub enable_parallel_result_sink: Option<bool>,
  pub enable_short_circuit_query_access_column_store: Option<bool>,
  pub enable_no_need_read_data_opt: Option<bool>,
  pub read_csv_empty_line_as_null: Option<bool>,
  pub serde_dialect: Option<TSerdeDialect>,
  pub enable_match_without_inverted_index: Option<bool>,
  pub enable_fallback_on_missing_inverted_index: Option<bool>,
  pub keep_carriage_return: Option<bool>,
  pub runtime_bloom_filter_min_size: Option<i32>,
  pub hive_parquet_use_column_names: Option<bool>,
  pub hive_orc_use_column_names: Option<bool>,
  pub enable_segment_cache: Option<bool>,
  pub runtime_bloom_filter_max_size: Option<i32>,
  pub in_list_value_count_threshold: Option<i32>,
  pub enable_verbose_profile: Option<bool>,
  pub rpc_verbose_profile_max_instance_count: Option<i32>,
  pub enable_adaptive_pipeline_task_serial_read_on_limit: Option<bool>,
  pub adaptive_pipeline_task_serial_read_on_limit: Option<i32>,
  pub parallel_prepare_threshold: Option<i32>,
  pub partition_topn_max_partitions: Option<i32>,
  pub partition_topn_pre_partition_rows: Option<i32>,
  pub enable_parallel_outfile: Option<bool>,
  pub enable_phrase_query_sequential_opt: Option<bool>,
  pub enable_auto_create_when_overwrite: Option<bool>,
  pub orc_tiny_stripe_threshold_bytes: Option<i64>,
  pub orc_once_max_read_bytes: Option<i64>,
  pub orc_max_merge_distance_bytes: Option<i64>,
  pub ignore_runtime_filter_error: Option<bool>,
  pub enable_fixed_len_to_uint32_v2: Option<bool>,
  pub enable_shared_exchange_sink_buffer: Option<bool>,
  pub enable_inverted_index_searcher_cache: Option<bool>,
  pub enable_inverted_index_query_cache: Option<bool>,
  pub enable_condition_cache: Option<bool>,
  pub profile_level: Option<i32>,
  pub min_scanner_concurrency: Option<i32>,
  pub min_scan_scheduler_concurrency: Option<i32>,
  pub enable_runtime_filter_partition_prune: Option<bool>,
  pub minimum_operator_memory_required_kb: Option<i32>,
  pub enable_mem_overcommit: Option<bool>,
  pub query_slot_count: Option<i32>,
  pub enable_spill: Option<bool>,
  pub enable_reserve_memory: Option<bool>,
  pub revocable_memory_high_watermark_percent: Option<i32>,
  pub spill_sort_mem_limit: Option<i64>,
  pub spill_sort_batch_bytes: Option<i64>,
  pub spill_aggregation_partition_count: Option<i32>,
  pub spill_hash_join_partition_count: Option<i32>,
  pub low_memory_mode_buffer_limit: Option<i64>,
  pub dump_heap_profile_when_mem_limit_exceeded: Option<bool>,
  pub inverted_index_compatible_read: Option<bool>,
  pub check_orc_init_sargs_success: Option<bool>,
  pub exchange_multi_blocks_byte_size: Option<i32>,
  pub enable_strict_cast: Option<bool>,
  pub new_version_unix_timestamp: Option<bool>,
  pub hnsw_ef_search: Option<i32>,
  pub hnsw_check_relative_distance: Option<bool>,
  pub hnsw_bounded_queue: Option<bool>,
  pub optimize_index_scan_parallelism: Option<bool>,
  pub enable_prefer_cached_rowset: Option<bool>,
  pub query_freshness_tolerance_ms: Option<i64>,
  pub merge_read_slice_size: Option<i64>,
  pub enable_fuzzy_blockable_task: Option<bool>,
  pub shuffled_agg_ids: Option<Vec<i32>>,
  pub enable_extended_regex: Option<bool>,
  pub iceberg_write_target_file_size_bytes: Option<i64>,
  pub disable_file_cache: Option<bool>,
}

impl TQueryOptions {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F12, F13, F14, F15, F16, F17, F18, F19, F20, F21, F22, F23, F24, F25, F26, F27, F28, F29, F30, F31, F32, F33, F34, F42, F43, F44, F45, F46, F48, F49, F50, F51, F52, F53, F54, F55, F56, F57, F58, F59, F60, F61, F62, F63, F64, F65, F66, F67, F68, F69, F70, F71, F72, F73, F74, F75, F76, F77, F78, F79, F80, F81, F82, F83, F84, F85, F86, F87, F88, F89, F90, F91, F92, F93, F94, F95, F96, F97, F98, F99, F100, F101, F102, F103, F104, F105, F106, F107, F108, F109, F110, F111, F112, F113, F114, F115, F116, F117, F118, F119, F120, F121, F122, F123, F124, F125, F126, F127, F128, F129, F130, F131, F132, F133, F134, F135, F136, F137, F138, F139, F140, F141, F142, F143, F144, F145, F146, F147, F148, F149, F150, F151, F152, F153, F154, F155, F156, F157, F158, F159, F160, F161, F162, F163, F164, F165, F166, F167, F168, F169, F170, F171, F172, F173, F174, F175, F176, F177, F178, F1000>(abort_on_error: F1, max_errors: F2, disable_codegen: F3, batch_size: F4, num_nodes: F5, max_scan_range_length: F6, num_scanner_threads: F7, max_io_buffers: F8, allow_unsupported_formats: F9, default_order_by_limit: F10, mem_limit: F12, abort_on_default_limit_exceeded: F13, query_timeout: F14, is_report_success: F15, codegen_level: F16, kudu_latest_observed_ts: F17, query_type: F18, min_reservation: F19, max_reservation: F20, initial_reservation_total_claims: F21, buffer_pool_limit: F22, default_spillable_buffer_size: F23, min_spillable_buffer_size: F24, max_row_size: F25, disable_stream_preaggregations: F26, mt_dop: F27, load_mem_limit: F28, max_scan_key_num: F29, max_pushdown_conditions_per_column: F30, enable_spilling: F31, enable_enable_exchange_node_parallel_merge: F32, runtime_filter_wait_time_ms: F33, runtime_filter_max_in_num: F34, resource_limit: F42, return_object_data_as_binary: F43, trim_tailing_spaces_for_external_table_query: F44, enable_function_pushdown: F45, fragment_transmission_compression_codec: F46, enable_local_exchange: F48, skip_storage_engine_merge: F49, skip_delete_predicate: F50, enable_new_shuffle_hash_method: F51, be_exec_version: F52, partitioned_hash_join_rows_threshold: F53, enable_share_hash_table_for_broadcast_join: F54, check_overflow_for_decimal: F55, skip_delete_bitmap: F56, enable_pipeline_engine: F57, repeat_max_num: F58, external_sort_bytes_threshold: F59, partitioned_hash_agg_rows_threshold: F60, enable_file_cache: F61, insert_timeout: F62, execution_timeout: F63, dry_run_query: F64, enable_common_expr_pushdown: F65, parallel_instance: F66, mysql_row_binary_format: F67, external_agg_bytes_threshold: F68, external_agg_partition_bits: F69, file_cache_base_path: F70, enable_parquet_lazy_mat: F71, enable_orc_lazy_mat: F72, scan_queue_mem_limit: F73, enable_scan_node_run_serial: F74, enable_insert_strict: F75, enable_inverted_index_query: F76, truncate_char_or_varchar_columns: F77, enable_hash_join_early_start_probe: F78, enable_pipeline_x_engine: F79, enable_memtable_on_sink_node: F80, enable_delete_sub_predicate_v2: F81, fe_process_uuid: F82, inverted_index_conjunction_opt_threshold: F83, enable_profile: F84, enable_page_cache: F85, analyze_timeout: F86, faster_float_convert: F87, enable_decimal256: F88, enable_local_shuffle: F89, skip_missing_version: F90, runtime_filter_wait_infinitely: F91, condition_cache_digest: F92, inverted_index_max_expansions: F93, inverted_index_skip_threshold: F94, enable_parallel_scan: F95, parallel_scan_max_scanners_count: F96, parallel_scan_min_rows_per_scanner: F97, skip_bad_tablet: F98, scanner_scale_up_ratio: F99, enable_distinct_streaming_aggregation: F100, enable_join_spill: F101, enable_sort_spill: F102, enable_agg_spill: F103, min_revocable_mem: F104, spill_streaming_agg_mem_limit: F105, data_queue_max_blocks: F106, enable_common_expr_pushdown_for_inverted_index: F107, local_exchange_free_blocks_limit: F108, enable_force_spill: F109, enable_parquet_filter_by_min_max: F110, enable_orc_filter_by_min_max: F111, max_column_reader_num: F112, enable_local_merge_sort: F113, enable_parallel_result_sink: F114, enable_short_circuit_query_access_column_store: F115, enable_no_need_read_data_opt: F116, read_csv_empty_line_as_null: F117, serde_dialect: F118, enable_match_without_inverted_index: F119, enable_fallback_on_missing_inverted_index: F120, keep_carriage_return: F121, runtime_bloom_filter_min_size: F122, hive_parquet_use_column_names: F123, hive_orc_use_column_names: F124, enable_segment_cache: F125, runtime_bloom_filter_max_size: F126, in_list_value_count_threshold: F127, enable_verbose_profile: F128, rpc_verbose_profile_max_instance_count: F129, enable_adaptive_pipeline_task_serial_read_on_limit: F130, adaptive_pipeline_task_serial_read_on_limit: F131, parallel_prepare_threshold: F132, partition_topn_max_partitions: F133, partition_topn_pre_partition_rows: F134, enable_parallel_outfile: F135, enable_phrase_query_sequential_opt: F136, enable_auto_create_when_overwrite: F137, orc_tiny_stripe_threshold_bytes: F138, orc_once_max_read_bytes: F139, orc_max_merge_distance_bytes: F140, ignore_runtime_filter_error: F141, enable_fixed_len_to_uint32_v2: F142, enable_shared_exchange_sink_buffer: F143, enable_inverted_index_searcher_cache: F144, enable_inverted_index_query_cache: F145, enable_condition_cache: F146, profile_level: F147, min_scanner_concurrency: F148, min_scan_scheduler_concurrency: F149, enable_runtime_filter_partition_prune: F150, minimum_operator_memory_required_kb: F151, enable_mem_overcommit: F152, query_slot_count: F153, enable_spill: F154, enable_reserve_memory: F155, revocable_memory_high_watermark_percent: F156, spill_sort_mem_limit: F157, spill_sort_batch_bytes: F158, spill_aggregation_partition_count: F159, spill_hash_join_partition_count: F160, low_memory_mode_buffer_limit: F161, dump_heap_profile_when_mem_limit_exceeded: F162, inverted_index_compatible_read: F163, check_orc_init_sargs_success: F164, exchange_multi_blocks_byte_size: F165, enable_strict_cast: F166, new_version_unix_timestamp: F167, hnsw_ef_search: F168, hnsw_check_relative_distance: F169, hnsw_bounded_queue: F170, optimize_index_scan_parallelism: F171, enable_prefer_cached_rowset: F172, query_freshness_tolerance_ms: F173, merge_read_slice_size: F174, enable_fuzzy_blockable_task: F175, shuffled_agg_ids: F176, enable_extended_regex: F177, iceberg_write_target_file_size_bytes: F178, disable_file_cache: F1000) -> TQueryOptions where F1: Into<Option<bool>>, F2: Into<Option<i32>>, F3: Into<Option<bool>>, F4: Into<Option<i32>>, F5: Into<Option<i32>>, F6: Into<Option<i64>>, F7: Into<Option<i32>>, F8: Into<Option<i32>>, F9: Into<Option<bool>>, F10: Into<Option<i64>>, F12: Into<Option<i64>>, F13: Into<Option<bool>>, F14: Into<Option<i32>>, F15: Into<Option<bool>>, F16: Into<Option<i32>>, F17: Into<Option<i64>>, F18: Into<Option<TQueryType>>, F19: Into<Option<i64>>, F20: Into<Option<i64>>, F21: Into<Option<i64>>, F22: Into<Option<i64>>, F23: Into<Option<i64>>, F24: Into<Option<i64>>, F25: Into<Option<i64>>, F26: Into<Option<bool>>, F27: Into<Option<i32>>, F28: Into<Option<i64>>, F29: Into<Option<i32>>, F30: Into<Option<i32>>, F31: Into<Option<bool>>, F32: Into<Option<bool>>, F33: Into<Option<i32>>, F34: Into<Option<i32>>, F42: Into<Option<TResourceLimit>>, F43: Into<Option<bool>>, F44: Into<Option<bool>>, F45: Into<Option<bool>>, F46: Into<Option<String>>, F48: Into<Option<bool>>, F49: Into<Option<bool>>, F50: Into<Option<bool>>, F51: Into<Option<bool>>, F52: Into<Option<i32>>, F53: Into<Option<i32>>, F54: Into<Option<bool>>, F55: Into<Option<bool>>, F56: Into<Option<bool>>, F57: Into<Option<bool>>, F58: Into<Option<i32>>, F59: Into<Option<i64>>, F60: Into<Option<i32>>, F61: Into<Option<bool>>, F62: Into<Option<i32>>, F63: Into<Option<i32>>, F64: Into<Option<bool>>, F65: Into<Option<bool>>, F66: Into<Option<i32>>, F67: Into<Option<bool>>, F68: Into<Option<i64>>, F69: Into<Option<i32>>, F70: Into<Option<String>>, F71: Into<Option<bool>>, F72: Into<Option<bool>>, F73: Into<Option<i64>>, F74: Into<Option<bool>>, F75: Into<Option<bool>>, F76: Into<Option<bool>>, F77: Into<Option<bool>>, F78: Into<Option<bool>>, F79: Into<Option<bool>>, F80: Into<Option<bool>>, F81: Into<Option<bool>>, F82: Into<Option<i64>>, F83: Into<Option<i32>>, F84: Into<Option<bool>>, F85: Into<Option<bool>>, F86: Into<Option<i32>>, F87: Into<Option<bool>>, F88: Into<Option<bool>>, F89: Into<Option<bool>>, F90: Into<Option<bool>>, F91: Into<Option<bool>>, F92: Into<Option<i32>>, F93: Into<Option<i32>>, F94: Into<Option<i32>>, F95: Into<Option<bool>>, F96: Into<Option<i32>>, F97: Into<Option<i64>>, F98: Into<Option<bool>>, F99: Into<Option<OrderedFloat<f64>>>, F100: Into<Option<bool>>, F101: Into<Option<bool>>, F102: Into<Option<bool>>, F103: Into<Option<bool>>, F104: Into<Option<i64>>, F105: Into<Option<i64>>, F106: Into<Option<i64>>, F107: Into<Option<bool>>, F108: Into<Option<i64>>, F109: Into<Option<bool>>, F110: Into<Option<bool>>, F111: Into<Option<bool>>, F112: Into<Option<i32>>, F113: Into<Option<bool>>, F114: Into<Option<bool>>, F115: Into<Option<bool>>, F116: Into<Option<bool>>, F117: Into<Option<bool>>, F118: Into<Option<TSerdeDialect>>, F119: Into<Option<bool>>, F120: Into<Option<bool>>, F121: Into<Option<bool>>, F122: Into<Option<i32>>, F123: Into<Option<bool>>, F124: Into<Option<bool>>, F125: Into<Option<bool>>, F126: Into<Option<i32>>, F127: Into<Option<i32>>, F128: Into<Option<bool>>, F129: Into<Option<i32>>, F130: Into<Option<bool>>, F131: Into<Option<i32>>, F132: Into<Option<i32>>, F133: Into<Option<i32>>, F134: Into<Option<i32>>, F135: Into<Option<bool>>, F136: Into<Option<bool>>, F137: Into<Option<bool>>, F138: Into<Option<i64>>, F139: Into<Option<i64>>, F140: Into<Option<i64>>, F141: Into<Option<bool>>, F142: Into<Option<bool>>, F143: Into<Option<bool>>, F144: Into<Option<bool>>, F145: Into<Option<bool>>, F146: Into<Option<bool>>, F147: Into<Option<i32>>, F148: Into<Option<i32>>, F149: Into<Option<i32>>, F150: Into<Option<bool>>, F151: Into<Option<i32>>, F152: Into<Option<bool>>, F153: Into<Option<i32>>, F154: Into<Option<bool>>, F155: Into<Option<bool>>, F156: Into<Option<i32>>, F157: Into<Option<i64>>, F158: Into<Option<i64>>, F159: Into<Option<i32>>, F160: Into<Option<i32>>, F161: Into<Option<i64>>, F162: Into<Option<bool>>, F163: Into<Option<bool>>, F164: Into<Option<bool>>, F165: Into<Option<i32>>, F166: Into<Option<bool>>, F167: Into<Option<bool>>, F168: Into<Option<i32>>, F169: Into<Option<bool>>, F170: Into<Option<bool>>, F171: Into<Option<bool>>, F172: Into<Option<bool>>, F173: Into<Option<i64>>, F174: Into<Option<i64>>, F175: Into<Option<bool>>, F176: Into<Option<Vec<i32>>>, F177: Into<Option<bool>>, F178: Into<Option<i64>>, F1000: Into<Option<bool>> {
    TQueryOptions {
      abort_on_error: abort_on_error.into(),
      max_errors: max_errors.into(),
      disable_codegen: disable_codegen.into(),
      batch_size: batch_size.into(),
      num_nodes: num_nodes.into(),
      max_scan_range_length: max_scan_range_length.into(),
      num_scanner_threads: num_scanner_threads.into(),
      max_io_buffers: max_io_buffers.into(),
      allow_unsupported_formats: allow_unsupported_formats.into(),
      default_order_by_limit: default_order_by_limit.into(),
      mem_limit: mem_limit.into(),
      abort_on_default_limit_exceeded: abort_on_default_limit_exceeded.into(),
      query_timeout: query_timeout.into(),
      is_report_success: is_report_success.into(),
      codegen_level: codegen_level.into(),
      kudu_latest_observed_ts: kudu_latest_observed_ts.into(),
      query_type: query_type.into(),
      min_reservation: min_reservation.into(),
      max_reservation: max_reservation.into(),
      initial_reservation_total_claims: initial_reservation_total_claims.into(),
      buffer_pool_limit: buffer_pool_limit.into(),
      default_spillable_buffer_size: default_spillable_buffer_size.into(),
      min_spillable_buffer_size: min_spillable_buffer_size.into(),
      max_row_size: max_row_size.into(),
      disable_stream_preaggregations: disable_stream_preaggregations.into(),
      mt_dop: mt_dop.into(),
      load_mem_limit: load_mem_limit.into(),
      max_scan_key_num: max_scan_key_num.into(),
      max_pushdown_conditions_per_column: max_pushdown_conditions_per_column.into(),
      enable_spilling: enable_spilling.into(),
      enable_enable_exchange_node_parallel_merge: enable_enable_exchange_node_parallel_merge.into(),
      runtime_filter_wait_time_ms: runtime_filter_wait_time_ms.into(),
      runtime_filter_max_in_num: runtime_filter_max_in_num.into(),
      resource_limit: resource_limit.into(),
      return_object_data_as_binary: return_object_data_as_binary.into(),
      trim_tailing_spaces_for_external_table_query: trim_tailing_spaces_for_external_table_query.into(),
      enable_function_pushdown: enable_function_pushdown.into(),
      fragment_transmission_compression_codec: fragment_transmission_compression_codec.into(),
      enable_local_exchange: enable_local_exchange.into(),
      skip_storage_engine_merge: skip_storage_engine_merge.into(),
      skip_delete_predicate: skip_delete_predicate.into(),
      enable_new_shuffle_hash_method: enable_new_shuffle_hash_method.into(),
      be_exec_version: be_exec_version.into(),
      partitioned_hash_join_rows_threshold: partitioned_hash_join_rows_threshold.into(),
      enable_share_hash_table_for_broadcast_join: enable_share_hash_table_for_broadcast_join.into(),
      check_overflow_for_decimal: check_overflow_for_decimal.into(),
      skip_delete_bitmap: skip_delete_bitmap.into(),
      enable_pipeline_engine: enable_pipeline_engine.into(),
      repeat_max_num: repeat_max_num.into(),
      external_sort_bytes_threshold: external_sort_bytes_threshold.into(),
      partitioned_hash_agg_rows_threshold: partitioned_hash_agg_rows_threshold.into(),
      enable_file_cache: enable_file_cache.into(),
      insert_timeout: insert_timeout.into(),
      execution_timeout: execution_timeout.into(),
      dry_run_query: dry_run_query.into(),
      enable_common_expr_pushdown: enable_common_expr_pushdown.into(),
      parallel_instance: parallel_instance.into(),
      mysql_row_binary_format: mysql_row_binary_format.into(),
      external_agg_bytes_threshold: external_agg_bytes_threshold.into(),
      external_agg_partition_bits: external_agg_partition_bits.into(),
      file_cache_base_path: file_cache_base_path.into(),
      enable_parquet_lazy_mat: enable_parquet_lazy_mat.into(),
      enable_orc_lazy_mat: enable_orc_lazy_mat.into(),
      scan_queue_mem_limit: scan_queue_mem_limit.into(),
      enable_scan_node_run_serial: enable_scan_node_run_serial.into(),
      enable_insert_strict: enable_insert_strict.into(),
      enable_inverted_index_query: enable_inverted_index_query.into(),
      truncate_char_or_varchar_columns: truncate_char_or_varchar_columns.into(),
      enable_hash_join_early_start_probe: enable_hash_join_early_start_probe.into(),
      enable_pipeline_x_engine: enable_pipeline_x_engine.into(),
      enable_memtable_on_sink_node: enable_memtable_on_sink_node.into(),
      enable_delete_sub_predicate_v2: enable_delete_sub_predicate_v2.into(),
      fe_process_uuid: fe_process_uuid.into(),
      inverted_index_conjunction_opt_threshold: inverted_index_conjunction_opt_threshold.into(),
      enable_profile: enable_profile.into(),
      enable_page_cache: enable_page_cache.into(),
      analyze_timeout: analyze_timeout.into(),
      faster_float_convert: faster_float_convert.into(),
      enable_decimal256: enable_decimal256.into(),
      enable_local_shuffle: enable_local_shuffle.into(),
      skip_missing_version: skip_missing_version.into(),
      runtime_filter_wait_infinitely: runtime_filter_wait_infinitely.into(),
      condition_cache_digest: condition_cache_digest.into(),
      inverted_index_max_expansions: inverted_index_max_expansions.into(),
      inverted_index_skip_threshold: inverted_index_skip_threshold.into(),
      enable_parallel_scan: enable_parallel_scan.into(),
      parallel_scan_max_scanners_count: parallel_scan_max_scanners_count.into(),
      parallel_scan_min_rows_per_scanner: parallel_scan_min_rows_per_scanner.into(),
      skip_bad_tablet: skip_bad_tablet.into(),
      scanner_scale_up_ratio: scanner_scale_up_ratio.into(),
      enable_distinct_streaming_aggregation: enable_distinct_streaming_aggregation.into(),
      enable_join_spill: enable_join_spill.into(),
      enable_sort_spill: enable_sort_spill.into(),
      enable_agg_spill: enable_agg_spill.into(),
      min_revocable_mem: min_revocable_mem.into(),
      spill_streaming_agg_mem_limit: spill_streaming_agg_mem_limit.into(),
      data_queue_max_blocks: data_queue_max_blocks.into(),
      enable_common_expr_pushdown_for_inverted_index: enable_common_expr_pushdown_for_inverted_index.into(),
      local_exchange_free_blocks_limit: local_exchange_free_blocks_limit.into(),
      enable_force_spill: enable_force_spill.into(),
      enable_parquet_filter_by_min_max: enable_parquet_filter_by_min_max.into(),
      enable_orc_filter_by_min_max: enable_orc_filter_by_min_max.into(),
      max_column_reader_num: max_column_reader_num.into(),
      enable_local_merge_sort: enable_local_merge_sort.into(),
      enable_parallel_result_sink: enable_parallel_result_sink.into(),
      enable_short_circuit_query_access_column_store: enable_short_circuit_query_access_column_store.into(),
      enable_no_need_read_data_opt: enable_no_need_read_data_opt.into(),
      read_csv_empty_line_as_null: read_csv_empty_line_as_null.into(),
      serde_dialect: serde_dialect.into(),
      enable_match_without_inverted_index: enable_match_without_inverted_index.into(),
      enable_fallback_on_missing_inverted_index: enable_fallback_on_missing_inverted_index.into(),
      keep_carriage_return: keep_carriage_return.into(),
      runtime_bloom_filter_min_size: runtime_bloom_filter_min_size.into(),
      hive_parquet_use_column_names: hive_parquet_use_column_names.into(),
      hive_orc_use_column_names: hive_orc_use_column_names.into(),
      enable_segment_cache: enable_segment_cache.into(),
      runtime_bloom_filter_max_size: runtime_bloom_filter_max_size.into(),
      in_list_value_count_threshold: in_list_value_count_threshold.into(),
      enable_verbose_profile: enable_verbose_profile.into(),
      rpc_verbose_profile_max_instance_count: rpc_verbose_profile_max_instance_count.into(),
      enable_adaptive_pipeline_task_serial_read_on_limit: enable_adaptive_pipeline_task_serial_read_on_limit.into(),
      adaptive_pipeline_task_serial_read_on_limit: adaptive_pipeline_task_serial_read_on_limit.into(),
      parallel_prepare_threshold: parallel_prepare_threshold.into(),
      partition_topn_max_partitions: partition_topn_max_partitions.into(),
      partition_topn_pre_partition_rows: partition_topn_pre_partition_rows.into(),
      enable_parallel_outfile: enable_parallel_outfile.into(),
      enable_phrase_query_sequential_opt: enable_phrase_query_sequential_opt.into(),
      enable_auto_create_when_overwrite: enable_auto_create_when_overwrite.into(),
      orc_tiny_stripe_threshold_bytes: orc_tiny_stripe_threshold_bytes.into(),
      orc_once_max_read_bytes: orc_once_max_read_bytes.into(),
      orc_max_merge_distance_bytes: orc_max_merge_distance_bytes.into(),
      ignore_runtime_filter_error: ignore_runtime_filter_error.into(),
      enable_fixed_len_to_uint32_v2: enable_fixed_len_to_uint32_v2.into(),
      enable_shared_exchange_sink_buffer: enable_shared_exchange_sink_buffer.into(),
      enable_inverted_index_searcher_cache: enable_inverted_index_searcher_cache.into(),
      enable_inverted_index_query_cache: enable_inverted_index_query_cache.into(),
      enable_condition_cache: enable_condition_cache.into(),
      profile_level: profile_level.into(),
      min_scanner_concurrency: min_scanner_concurrency.into(),
      min_scan_scheduler_concurrency: min_scan_scheduler_concurrency.into(),
      enable_runtime_filter_partition_prune: enable_runtime_filter_partition_prune.into(),
      minimum_operator_memory_required_kb: minimum_operator_memory_required_kb.into(),
      enable_mem_overcommit: enable_mem_overcommit.into(),
      query_slot_count: query_slot_count.into(),
      enable_spill: enable_spill.into(),
      enable_reserve_memory: enable_reserve_memory.into(),
      revocable_memory_high_watermark_percent: revocable_memory_high_watermark_percent.into(),
      spill_sort_mem_limit: spill_sort_mem_limit.into(),
      spill_sort_batch_bytes: spill_sort_batch_bytes.into(),
      spill_aggregation_partition_count: spill_aggregation_partition_count.into(),
      spill_hash_join_partition_count: spill_hash_join_partition_count.into(),
      low_memory_mode_buffer_limit: low_memory_mode_buffer_limit.into(),
      dump_heap_profile_when_mem_limit_exceeded: dump_heap_profile_when_mem_limit_exceeded.into(),
      inverted_index_compatible_read: inverted_index_compatible_read.into(),
      check_orc_init_sargs_success: check_orc_init_sargs_success.into(),
      exchange_multi_blocks_byte_size: exchange_multi_blocks_byte_size.into(),
      enable_strict_cast: enable_strict_cast.into(),
      new_version_unix_timestamp: new_version_unix_timestamp.into(),
      hnsw_ef_search: hnsw_ef_search.into(),
      hnsw_check_relative_distance: hnsw_check_relative_distance.into(),
      hnsw_bounded_queue: hnsw_bounded_queue.into(),
      optimize_index_scan_parallelism: optimize_index_scan_parallelism.into(),
      enable_prefer_cached_rowset: enable_prefer_cached_rowset.into(),
      query_freshness_tolerance_ms: query_freshness_tolerance_ms.into(),
      merge_read_slice_size: merge_read_slice_size.into(),
      enable_fuzzy_blockable_task: enable_fuzzy_blockable_task.into(),
      shuffled_agg_ids: shuffled_agg_ids.into(),
      enable_extended_regex: enable_extended_regex.into(),
      iceberg_write_target_file_size_bytes: iceberg_write_target_file_size_bytes.into(),
      disable_file_cache: disable_file_cache.into(),
    }
  }
}

impl TSerializable for TQueryOptions {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TQueryOptions> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<bool> = None;
    let mut f_4: Option<i32> = None;
    let mut f_5: Option<i32> = None;
    let mut f_6: Option<i64> = None;
    let mut f_7: Option<i32> = None;
    let mut f_8: Option<i32> = None;
    let mut f_9: Option<bool> = None;
    let mut f_10: Option<i64> = None;
    let mut f_12: Option<i64> = None;
    let mut f_13: Option<bool> = None;
    let mut f_14: Option<i32> = None;
    let mut f_15: Option<bool> = None;
    let mut f_16: Option<i32> = None;
    let mut f_17: Option<i64> = None;
    let mut f_18: Option<TQueryType> = None;
    let mut f_19: Option<i64> = None;
    let mut f_20: Option<i64> = None;
    let mut f_21: Option<i64> = None;
    let mut f_22: Option<i64> = None;
    let mut f_23: Option<i64> = None;
    let mut f_24: Option<i64> = None;
    let mut f_25: Option<i64> = None;
    let mut f_26: Option<bool> = None;
    let mut f_27: Option<i32> = None;
    let mut f_28: Option<i64> = None;
    let mut f_29: Option<i32> = None;
    let mut f_30: Option<i32> = None;
    let mut f_31: Option<bool> = None;
    let mut f_32: Option<bool> = None;
    let mut f_33: Option<i32> = None;
    let mut f_34: Option<i32> = None;
    let mut f_42: Option<TResourceLimit> = None;
    let mut f_43: Option<bool> = None;
    let mut f_44: Option<bool> = None;
    let mut f_45: Option<bool> = None;
    let mut f_46: Option<String> = None;
    let mut f_48: Option<bool> = None;
    let mut f_49: Option<bool> = None;
    let mut f_50: Option<bool> = None;
    let mut f_51: Option<bool> = None;
    let mut f_52: Option<i32> = None;
    let mut f_53: Option<i32> = None;
    let mut f_54: Option<bool> = None;
    let mut f_55: Option<bool> = None;
    let mut f_56: Option<bool> = None;
    let mut f_57: Option<bool> = None;
    let mut f_58: Option<i32> = None;
    let mut f_59: Option<i64> = None;
    let mut f_60: Option<i32> = None;
    let mut f_61: Option<bool> = None;
    let mut f_62: Option<i32> = None;
    let mut f_63: Option<i32> = None;
    let mut f_64: Option<bool> = None;
    let mut f_65: Option<bool> = None;
    let mut f_66: Option<i32> = None;
    let mut f_67: Option<bool> = None;
    let mut f_68: Option<i64> = None;
    let mut f_69: Option<i32> = None;
    let mut f_70: Option<String> = None;
    let mut f_71: Option<bool> = None;
    let mut f_72: Option<bool> = None;
    let mut f_73: Option<i64> = None;
    let mut f_74: Option<bool> = None;
    let mut f_75: Option<bool> = None;
    let mut f_76: Option<bool> = None;
    let mut f_77: Option<bool> = None;
    let mut f_78: Option<bool> = None;
    let mut f_79: Option<bool> = None;
    let mut f_80: Option<bool> = None;
    let mut f_81: Option<bool> = None;
    let mut f_82: Option<i64> = None;
    let mut f_83: Option<i32> = None;
    let mut f_84: Option<bool> = None;
    let mut f_85: Option<bool> = None;
    let mut f_86: Option<i32> = None;
    let mut f_87: Option<bool> = None;
    let mut f_88: Option<bool> = None;
    let mut f_89: Option<bool> = None;
    let mut f_90: Option<bool> = None;
    let mut f_91: Option<bool> = None;
    let mut f_92: Option<i32> = None;
    let mut f_93: Option<i32> = None;
    let mut f_94: Option<i32> = None;
    let mut f_95: Option<bool> = None;
    let mut f_96: Option<i32> = None;
    let mut f_97: Option<i64> = None;
    let mut f_98: Option<bool> = None;
    let mut f_99: Option<OrderedFloat<f64>> = None;
    let mut f_100: Option<bool> = None;
    let mut f_101: Option<bool> = None;
    let mut f_102: Option<bool> = None;
    let mut f_103: Option<bool> = None;
    let mut f_104: Option<i64> = None;
    let mut f_105: Option<i64> = None;
    let mut f_106: Option<i64> = None;
    let mut f_107: Option<bool> = None;
    let mut f_108: Option<i64> = None;
    let mut f_109: Option<bool> = None;
    let mut f_110: Option<bool> = None;
    let mut f_111: Option<bool> = None;
    let mut f_112: Option<i32> = None;
    let mut f_113: Option<bool> = None;
    let mut f_114: Option<bool> = None;
    let mut f_115: Option<bool> = None;
    let mut f_116: Option<bool> = None;
    let mut f_117: Option<bool> = None;
    let mut f_118: Option<TSerdeDialect> = None;
    let mut f_119: Option<bool> = None;
    let mut f_120: Option<bool> = None;
    let mut f_121: Option<bool> = None;
    let mut f_122: Option<i32> = None;
    let mut f_123: Option<bool> = None;
    let mut f_124: Option<bool> = None;
    let mut f_125: Option<bool> = None;
    let mut f_126: Option<i32> = None;
    let mut f_127: Option<i32> = None;
    let mut f_128: Option<bool> = None;
    let mut f_129: Option<i32> = None;
    let mut f_130: Option<bool> = None;
    let mut f_131: Option<i32> = None;
    let mut f_132: Option<i32> = None;
    let mut f_133: Option<i32> = None;
    let mut f_134: Option<i32> = None;
    let mut f_135: Option<bool> = None;
    let mut f_136: Option<bool> = None;
    let mut f_137: Option<bool> = None;
    let mut f_138: Option<i64> = None;
    let mut f_139: Option<i64> = None;
    let mut f_140: Option<i64> = None;
    let mut f_141: Option<bool> = None;
    let mut f_142: Option<bool> = None;
    let mut f_143: Option<bool> = None;
    let mut f_144: Option<bool> = None;
    let mut f_145: Option<bool> = None;
    let mut f_146: Option<bool> = None;
    let mut f_147: Option<i32> = None;
    let mut f_148: Option<i32> = None;
    let mut f_149: Option<i32> = None;
    let mut f_150: Option<bool> = None;
    let mut f_151: Option<i32> = None;
    let mut f_152: Option<bool> = None;
    let mut f_153: Option<i32> = None;
    let mut f_154: Option<bool> = None;
    let mut f_155: Option<bool> = None;
    let mut f_156: Option<i32> = None;
    let mut f_157: Option<i64> = None;
    let mut f_158: Option<i64> = None;
    let mut f_159: Option<i32> = None;
    let mut f_160: Option<i32> = None;
    let mut f_161: Option<i64> = None;
    let mut f_162: Option<bool> = None;
    let mut f_163: Option<bool> = None;
    let mut f_164: Option<bool> = None;
    let mut f_165: Option<i32> = None;
    let mut f_166: Option<bool> = None;
    let mut f_167: Option<bool> = None;
    let mut f_168: Option<i32> = None;
    let mut f_169: Option<bool> = None;
    let mut f_170: Option<bool> = None;
    let mut f_171: Option<bool> = None;
    let mut f_172: Option<bool> = None;
    let mut f_173: Option<i64> = None;
    let mut f_174: Option<i64> = None;
    let mut f_175: Option<bool> = None;
    let mut f_176: Option<Vec<i32>> = None;
    let mut f_177: Option<bool> = None;
    let mut f_178: Option<i64> = None;
    let mut f_1000: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i64()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i32()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i32()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_bool()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_i64()?;
          f_10 = Some(val);
        },
        12 => {
          let val = i_prot.read_i64()?;
          f_12 = Some(val);
        },
        13 => {
          let val = i_prot.read_bool()?;
          f_13 = Some(val);
        },
        14 => {
          let val = i_prot.read_i32()?;
          f_14 = Some(val);
        },
        15 => {
          let val = i_prot.read_bool()?;
          f_15 = Some(val);
        },
        16 => {
          let val = i_prot.read_i32()?;
          f_16 = Some(val);
        },
        17 => {
          let val = i_prot.read_i64()?;
          f_17 = Some(val);
        },
        18 => {
          let val = TQueryType::read_from_in_protocol(i_prot)?;
          f_18 = Some(val);
        },
        19 => {
          let val = i_prot.read_i64()?;
          f_19 = Some(val);
        },
        20 => {
          let val = i_prot.read_i64()?;
          f_20 = Some(val);
        },
        21 => {
          let val = i_prot.read_i64()?;
          f_21 = Some(val);
        },
        22 => {
          let val = i_prot.read_i64()?;
          f_22 = Some(val);
        },
        23 => {
          let val = i_prot.read_i64()?;
          f_23 = Some(val);
        },
        24 => {
          let val = i_prot.read_i64()?;
          f_24 = Some(val);
        },
        25 => {
          let val = i_prot.read_i64()?;
          f_25 = Some(val);
        },
        26 => {
          let val = i_prot.read_bool()?;
          f_26 = Some(val);
        },
        27 => {
          let val = i_prot.read_i32()?;
          f_27 = Some(val);
        },
        28 => {
          let val = i_prot.read_i64()?;
          f_28 = Some(val);
        },
        29 => {
          let val = i_prot.read_i32()?;
          f_29 = Some(val);
        },
        30 => {
          let val = i_prot.read_i32()?;
          f_30 = Some(val);
        },
        31 => {
          let val = i_prot.read_bool()?;
          f_31 = Some(val);
        },
        32 => {
          let val = i_prot.read_bool()?;
          f_32 = Some(val);
        },
        33 => {
          let val = i_prot.read_i32()?;
          f_33 = Some(val);
        },
        34 => {
          let val = i_prot.read_i32()?;
          f_34 = Some(val);
        },
        42 => {
          let val = TResourceLimit::read_from_in_protocol(i_prot)?;
          f_42 = Some(val);
        },
        43 => {
          let val = i_prot.read_bool()?;
          f_43 = Some(val);
        },
        44 => {
          let val = i_prot.read_bool()?;
          f_44 = Some(val);
        },
        45 => {
          let val = i_prot.read_bool()?;
          f_45 = Some(val);
        },
        46 => {
          let val = i_prot.read_string()?;
          f_46 = Some(val);
        },
        48 => {
          let val = i_prot.read_bool()?;
          f_48 = Some(val);
        },
        49 => {
          let val = i_prot.read_bool()?;
          f_49 = Some(val);
        },
        50 => {
          let val = i_prot.read_bool()?;
          f_50 = Some(val);
        },
        51 => {
          let val = i_prot.read_bool()?;
          f_51 = Some(val);
        },
        52 => {
          let val = i_prot.read_i32()?;
          f_52 = Some(val);
        },
        53 => {
          let val = i_prot.read_i32()?;
          f_53 = Some(val);
        },
        54 => {
          let val = i_prot.read_bool()?;
          f_54 = Some(val);
        },
        55 => {
          let val = i_prot.read_bool()?;
          f_55 = Some(val);
        },
        56 => {
          let val = i_prot.read_bool()?;
          f_56 = Some(val);
        },
        57 => {
          let val = i_prot.read_bool()?;
          f_57 = Some(val);
        },
        58 => {
          let val = i_prot.read_i32()?;
          f_58 = Some(val);
        },
        59 => {
          let val = i_prot.read_i64()?;
          f_59 = Some(val);
        },
        60 => {
          let val = i_prot.read_i32()?;
          f_60 = Some(val);
        },
        61 => {
          let val = i_prot.read_bool()?;
          f_61 = Some(val);
        },
        62 => {
          let val = i_prot.read_i32()?;
          f_62 = Some(val);
        },
        63 => {
          let val = i_prot.read_i32()?;
          f_63 = Some(val);
        },
        64 => {
          let val = i_prot.read_bool()?;
          f_64 = Some(val);
        },
        65 => {
          let val = i_prot.read_bool()?;
          f_65 = Some(val);
        },
        66 => {
          let val = i_prot.read_i32()?;
          f_66 = Some(val);
        },
        67 => {
          let val = i_prot.read_bool()?;
          f_67 = Some(val);
        },
        68 => {
          let val = i_prot.read_i64()?;
          f_68 = Some(val);
        },
        69 => {
          let val = i_prot.read_i32()?;
          f_69 = Some(val);
        },
        70 => {
          let val = i_prot.read_string()?;
          f_70 = Some(val);
        },
        71 => {
          let val = i_prot.read_bool()?;
          f_71 = Some(val);
        },
        72 => {
          let val = i_prot.read_bool()?;
          f_72 = Some(val);
        },
        73 => {
          let val = i_prot.read_i64()?;
          f_73 = Some(val);
        },
        74 => {
          let val = i_prot.read_bool()?;
          f_74 = Some(val);
        },
        75 => {
          let val = i_prot.read_bool()?;
          f_75 = Some(val);
        },
        76 => {
          let val = i_prot.read_bool()?;
          f_76 = Some(val);
        },
        77 => {
          let val = i_prot.read_bool()?;
          f_77 = Some(val);
        },
        78 => {
          let val = i_prot.read_bool()?;
          f_78 = Some(val);
        },
        79 => {
          let val = i_prot.read_bool()?;
          f_79 = Some(val);
        },
        80 => {
          let val = i_prot.read_bool()?;
          f_80 = Some(val);
        },
        81 => {
          let val = i_prot.read_bool()?;
          f_81 = Some(val);
        },
        82 => {
          let val = i_prot.read_i64()?;
          f_82 = Some(val);
        },
        83 => {
          let val = i_prot.read_i32()?;
          f_83 = Some(val);
        },
        84 => {
          let val = i_prot.read_bool()?;
          f_84 = Some(val);
        },
        85 => {
          let val = i_prot.read_bool()?;
          f_85 = Some(val);
        },
        86 => {
          let val = i_prot.read_i32()?;
          f_86 = Some(val);
        },
        87 => {
          let val = i_prot.read_bool()?;
          f_87 = Some(val);
        },
        88 => {
          let val = i_prot.read_bool()?;
          f_88 = Some(val);
        },
        89 => {
          let val = i_prot.read_bool()?;
          f_89 = Some(val);
        },
        90 => {
          let val = i_prot.read_bool()?;
          f_90 = Some(val);
        },
        91 => {
          let val = i_prot.read_bool()?;
          f_91 = Some(val);
        },
        92 => {
          let val = i_prot.read_i32()?;
          f_92 = Some(val);
        },
        93 => {
          let val = i_prot.read_i32()?;
          f_93 = Some(val);
        },
        94 => {
          let val = i_prot.read_i32()?;
          f_94 = Some(val);
        },
        95 => {
          let val = i_prot.read_bool()?;
          f_95 = Some(val);
        },
        96 => {
          let val = i_prot.read_i32()?;
          f_96 = Some(val);
        },
        97 => {
          let val = i_prot.read_i64()?;
          f_97 = Some(val);
        },
        98 => {
          let val = i_prot.read_bool()?;
          f_98 = Some(val);
        },
        99 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_99 = Some(val);
        },
        100 => {
          let val = i_prot.read_bool()?;
          f_100 = Some(val);
        },
        101 => {
          let val = i_prot.read_bool()?;
          f_101 = Some(val);
        },
        102 => {
          let val = i_prot.read_bool()?;
          f_102 = Some(val);
        },
        103 => {
          let val = i_prot.read_bool()?;
          f_103 = Some(val);
        },
        104 => {
          let val = i_prot.read_i64()?;
          f_104 = Some(val);
        },
        105 => {
          let val = i_prot.read_i64()?;
          f_105 = Some(val);
        },
        106 => {
          let val = i_prot.read_i64()?;
          f_106 = Some(val);
        },
        107 => {
          let val = i_prot.read_bool()?;
          f_107 = Some(val);
        },
        108 => {
          let val = i_prot.read_i64()?;
          f_108 = Some(val);
        },
        109 => {
          let val = i_prot.read_bool()?;
          f_109 = Some(val);
        },
        110 => {
          let val = i_prot.read_bool()?;
          f_110 = Some(val);
        },
        111 => {
          let val = i_prot.read_bool()?;
          f_111 = Some(val);
        },
        112 => {
          let val = i_prot.read_i32()?;
          f_112 = Some(val);
        },
        113 => {
          let val = i_prot.read_bool()?;
          f_113 = Some(val);
        },
        114 => {
          let val = i_prot.read_bool()?;
          f_114 = Some(val);
        },
        115 => {
          let val = i_prot.read_bool()?;
          f_115 = Some(val);
        },
        116 => {
          let val = i_prot.read_bool()?;
          f_116 = Some(val);
        },
        117 => {
          let val = i_prot.read_bool()?;
          f_117 = Some(val);
        },
        118 => {
          let val = TSerdeDialect::read_from_in_protocol(i_prot)?;
          f_118 = Some(val);
        },
        119 => {
          let val = i_prot.read_bool()?;
          f_119 = Some(val);
        },
        120 => {
          let val = i_prot.read_bool()?;
          f_120 = Some(val);
        },
        121 => {
          let val = i_prot.read_bool()?;
          f_121 = Some(val);
        },
        122 => {
          let val = i_prot.read_i32()?;
          f_122 = Some(val);
        },
        123 => {
          let val = i_prot.read_bool()?;
          f_123 = Some(val);
        },
        124 => {
          let val = i_prot.read_bool()?;
          f_124 = Some(val);
        },
        125 => {
          let val = i_prot.read_bool()?;
          f_125 = Some(val);
        },
        126 => {
          let val = i_prot.read_i32()?;
          f_126 = Some(val);
        },
        127 => {
          let val = i_prot.read_i32()?;
          f_127 = Some(val);
        },
        128 => {
          let val = i_prot.read_bool()?;
          f_128 = Some(val);
        },
        129 => {
          let val = i_prot.read_i32()?;
          f_129 = Some(val);
        },
        130 => {
          let val = i_prot.read_bool()?;
          f_130 = Some(val);
        },
        131 => {
          let val = i_prot.read_i32()?;
          f_131 = Some(val);
        },
        132 => {
          let val = i_prot.read_i32()?;
          f_132 = Some(val);
        },
        133 => {
          let val = i_prot.read_i32()?;
          f_133 = Some(val);
        },
        134 => {
          let val = i_prot.read_i32()?;
          f_134 = Some(val);
        },
        135 => {
          let val = i_prot.read_bool()?;
          f_135 = Some(val);
        },
        136 => {
          let val = i_prot.read_bool()?;
          f_136 = Some(val);
        },
        137 => {
          let val = i_prot.read_bool()?;
          f_137 = Some(val);
        },
        138 => {
          let val = i_prot.read_i64()?;
          f_138 = Some(val);
        },
        139 => {
          let val = i_prot.read_i64()?;
          f_139 = Some(val);
        },
        140 => {
          let val = i_prot.read_i64()?;
          f_140 = Some(val);
        },
        141 => {
          let val = i_prot.read_bool()?;
          f_141 = Some(val);
        },
        142 => {
          let val = i_prot.read_bool()?;
          f_142 = Some(val);
        },
        143 => {
          let val = i_prot.read_bool()?;
          f_143 = Some(val);
        },
        144 => {
          let val = i_prot.read_bool()?;
          f_144 = Some(val);
        },
        145 => {
          let val = i_prot.read_bool()?;
          f_145 = Some(val);
        },
        146 => {
          let val = i_prot.read_bool()?;
          f_146 = Some(val);
        },
        147 => {
          let val = i_prot.read_i32()?;
          f_147 = Some(val);
        },
        148 => {
          let val = i_prot.read_i32()?;
          f_148 = Some(val);
        },
        149 => {
          let val = i_prot.read_i32()?;
          f_149 = Some(val);
        },
        150 => {
          let val = i_prot.read_bool()?;
          f_150 = Some(val);
        },
        151 => {
          let val = i_prot.read_i32()?;
          f_151 = Some(val);
        },
        152 => {
          let val = i_prot.read_bool()?;
          f_152 = Some(val);
        },
        153 => {
          let val = i_prot.read_i32()?;
          f_153 = Some(val);
        },
        154 => {
          let val = i_prot.read_bool()?;
          f_154 = Some(val);
        },
        155 => {
          let val = i_prot.read_bool()?;
          f_155 = Some(val);
        },
        156 => {
          let val = i_prot.read_i32()?;
          f_156 = Some(val);
        },
        157 => {
          let val = i_prot.read_i64()?;
          f_157 = Some(val);
        },
        158 => {
          let val = i_prot.read_i64()?;
          f_158 = Some(val);
        },
        159 => {
          let val = i_prot.read_i32()?;
          f_159 = Some(val);
        },
        160 => {
          let val = i_prot.read_i32()?;
          f_160 = Some(val);
        },
        161 => {
          let val = i_prot.read_i64()?;
          f_161 = Some(val);
        },
        162 => {
          let val = i_prot.read_bool()?;
          f_162 = Some(val);
        },
        163 => {
          let val = i_prot.read_bool()?;
          f_163 = Some(val);
        },
        164 => {
          let val = i_prot.read_bool()?;
          f_164 = Some(val);
        },
        165 => {
          let val = i_prot.read_i32()?;
          f_165 = Some(val);
        },
        166 => {
          let val = i_prot.read_bool()?;
          f_166 = Some(val);
        },
        167 => {
          let val = i_prot.read_bool()?;
          f_167 = Some(val);
        },
        168 => {
          let val = i_prot.read_i32()?;
          f_168 = Some(val);
        },
        169 => {
          let val = i_prot.read_bool()?;
          f_169 = Some(val);
        },
        170 => {
          let val = i_prot.read_bool()?;
          f_170 = Some(val);
        },
        171 => {
          let val = i_prot.read_bool()?;
          f_171 = Some(val);
        },
        172 => {
          let val = i_prot.read_bool()?;
          f_172 = Some(val);
        },
        173 => {
          let val = i_prot.read_i64()?;
          f_173 = Some(val);
        },
        174 => {
          let val = i_prot.read_i64()?;
          f_174 = Some(val);
        },
        175 => {
          let val = i_prot.read_bool()?;
          f_175 = Some(val);
        },
        176 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_2 = i_prot.read_i32()?;
            val.push(list_elem_2);
          }
          i_prot.read_list_end()?;
          f_176 = Some(val);
        },
        177 => {
          let val = i_prot.read_bool()?;
          f_177 = Some(val);
        },
        178 => {
          let val = i_prot.read_i64()?;
          f_178 = Some(val);
        },
        1000 => {
          let val = i_prot.read_bool()?;
          f_1000 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TQueryOptions {
      abort_on_error: f_1,
      max_errors: f_2,
      disable_codegen: f_3,
      batch_size: f_4,
      num_nodes: f_5,
      max_scan_range_length: f_6,
      num_scanner_threads: f_7,
      max_io_buffers: f_8,
      allow_unsupported_formats: f_9,
      default_order_by_limit: f_10,
      mem_limit: f_12,
      abort_on_default_limit_exceeded: f_13,
      query_timeout: f_14,
      is_report_success: f_15,
      codegen_level: f_16,
      kudu_latest_observed_ts: f_17,
      query_type: f_18,
      min_reservation: f_19,
      max_reservation: f_20,
      initial_reservation_total_claims: f_21,
      buffer_pool_limit: f_22,
      default_spillable_buffer_size: f_23,
      min_spillable_buffer_size: f_24,
      max_row_size: f_25,
      disable_stream_preaggregations: f_26,
      mt_dop: f_27,
      load_mem_limit: f_28,
      max_scan_key_num: f_29,
      max_pushdown_conditions_per_column: f_30,
      enable_spilling: f_31,
      enable_enable_exchange_node_parallel_merge: f_32,
      runtime_filter_wait_time_ms: f_33,
      runtime_filter_max_in_num: f_34,
      resource_limit: f_42,
      return_object_data_as_binary: f_43,
      trim_tailing_spaces_for_external_table_query: f_44,
      enable_function_pushdown: f_45,
      fragment_transmission_compression_codec: f_46,
      enable_local_exchange: f_48,
      skip_storage_engine_merge: f_49,
      skip_delete_predicate: f_50,
      enable_new_shuffle_hash_method: f_51,
      be_exec_version: f_52,
      partitioned_hash_join_rows_threshold: f_53,
      enable_share_hash_table_for_broadcast_join: f_54,
      check_overflow_for_decimal: f_55,
      skip_delete_bitmap: f_56,
      enable_pipeline_engine: f_57,
      repeat_max_num: f_58,
      external_sort_bytes_threshold: f_59,
      partitioned_hash_agg_rows_threshold: f_60,
      enable_file_cache: f_61,
      insert_timeout: f_62,
      execution_timeout: f_63,
      dry_run_query: f_64,
      enable_common_expr_pushdown: f_65,
      parallel_instance: f_66,
      mysql_row_binary_format: f_67,
      external_agg_bytes_threshold: f_68,
      external_agg_partition_bits: f_69,
      file_cache_base_path: f_70,
      enable_parquet_lazy_mat: f_71,
      enable_orc_lazy_mat: f_72,
      scan_queue_mem_limit: f_73,
      enable_scan_node_run_serial: f_74,
      enable_insert_strict: f_75,
      enable_inverted_index_query: f_76,
      truncate_char_or_varchar_columns: f_77,
      enable_hash_join_early_start_probe: f_78,
      enable_pipeline_x_engine: f_79,
      enable_memtable_on_sink_node: f_80,
      enable_delete_sub_predicate_v2: f_81,
      fe_process_uuid: f_82,
      inverted_index_conjunction_opt_threshold: f_83,
      enable_profile: f_84,
      enable_page_cache: f_85,
      analyze_timeout: f_86,
      faster_float_convert: f_87,
      enable_decimal256: f_88,
      enable_local_shuffle: f_89,
      skip_missing_version: f_90,
      runtime_filter_wait_infinitely: f_91,
      condition_cache_digest: f_92,
      inverted_index_max_expansions: f_93,
      inverted_index_skip_threshold: f_94,
      enable_parallel_scan: f_95,
      parallel_scan_max_scanners_count: f_96,
      parallel_scan_min_rows_per_scanner: f_97,
      skip_bad_tablet: f_98,
      scanner_scale_up_ratio: f_99,
      enable_distinct_streaming_aggregation: f_100,
      enable_join_spill: f_101,
      enable_sort_spill: f_102,
      enable_agg_spill: f_103,
      min_revocable_mem: f_104,
      spill_streaming_agg_mem_limit: f_105,
      data_queue_max_blocks: f_106,
      enable_common_expr_pushdown_for_inverted_index: f_107,
      local_exchange_free_blocks_limit: f_108,
      enable_force_spill: f_109,
      enable_parquet_filter_by_min_max: f_110,
      enable_orc_filter_by_min_max: f_111,
      max_column_reader_num: f_112,
      enable_local_merge_sort: f_113,
      enable_parallel_result_sink: f_114,
      enable_short_circuit_query_access_column_store: f_115,
      enable_no_need_read_data_opt: f_116,
      read_csv_empty_line_as_null: f_117,
      serde_dialect: f_118,
      enable_match_without_inverted_index: f_119,
      enable_fallback_on_missing_inverted_index: f_120,
      keep_carriage_return: f_121,
      runtime_bloom_filter_min_size: f_122,
      hive_parquet_use_column_names: f_123,
      hive_orc_use_column_names: f_124,
      enable_segment_cache: f_125,
      runtime_bloom_filter_max_size: f_126,
      in_list_value_count_threshold: f_127,
      enable_verbose_profile: f_128,
      rpc_verbose_profile_max_instance_count: f_129,
      enable_adaptive_pipeline_task_serial_read_on_limit: f_130,
      adaptive_pipeline_task_serial_read_on_limit: f_131,
      parallel_prepare_threshold: f_132,
      partition_topn_max_partitions: f_133,
      partition_topn_pre_partition_rows: f_134,
      enable_parallel_outfile: f_135,
      enable_phrase_query_sequential_opt: f_136,
      enable_auto_create_when_overwrite: f_137,
      orc_tiny_stripe_threshold_bytes: f_138,
      orc_once_max_read_bytes: f_139,
      orc_max_merge_distance_bytes: f_140,
      ignore_runtime_filter_error: f_141,
      enable_fixed_len_to_uint32_v2: f_142,
      enable_shared_exchange_sink_buffer: f_143,
      enable_inverted_index_searcher_cache: f_144,
      enable_inverted_index_query_cache: f_145,
      enable_condition_cache: f_146,
      profile_level: f_147,
      min_scanner_concurrency: f_148,
      min_scan_scheduler_concurrency: f_149,
      enable_runtime_filter_partition_prune: f_150,
      minimum_operator_memory_required_kb: f_151,
      enable_mem_overcommit: f_152,
      query_slot_count: f_153,
      enable_spill: f_154,
      enable_reserve_memory: f_155,
      revocable_memory_high_watermark_percent: f_156,
      spill_sort_mem_limit: f_157,
      spill_sort_batch_bytes: f_158,
      spill_aggregation_partition_count: f_159,
      spill_hash_join_partition_count: f_160,
      low_memory_mode_buffer_limit: f_161,
      dump_heap_profile_when_mem_limit_exceeded: f_162,
      inverted_index_compatible_read: f_163,
      check_orc_init_sargs_success: f_164,
      exchange_multi_blocks_byte_size: f_165,
      enable_strict_cast: f_166,
      new_version_unix_timestamp: f_167,
      hnsw_ef_search: f_168,
      hnsw_check_relative_distance: f_169,
      hnsw_bounded_queue: f_170,
      optimize_index_scan_parallelism: f_171,
      enable_prefer_cached_rowset: f_172,
      query_freshness_tolerance_ms: f_173,
      merge_read_slice_size: f_174,
      enable_fuzzy_blockable_task: f_175,
      shuffled_agg_ids: f_176,
      enable_extended_regex: f_177,
      iceberg_write_target_file_size_bytes: f_178,
      disable_file_cache: f_1000,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TQueryOptions");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.abort_on_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("abort_on_error", TType::Bool, 1))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.max_errors {
      o_prot.write_field_begin(&TFieldIdentifier::new("max_errors", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.disable_codegen {
      o_prot.write_field_begin(&TFieldIdentifier::new("disable_codegen", TType::Bool, 3))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.batch_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("batch_size", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.num_nodes {
      o_prot.write_field_begin(&TFieldIdentifier::new("num_nodes", TType::I32, 5))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.max_scan_range_length {
      o_prot.write_field_begin(&TFieldIdentifier::new("max_scan_range_length", TType::I64, 6))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.num_scanner_threads {
      o_prot.write_field_begin(&TFieldIdentifier::new("num_scanner_threads", TType::I32, 7))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.max_io_buffers {
      o_prot.write_field_begin(&TFieldIdentifier::new("max_io_buffers", TType::I32, 8))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.allow_unsupported_formats {
      o_prot.write_field_begin(&TFieldIdentifier::new("allow_unsupported_formats", TType::Bool, 9))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.default_order_by_limit {
      o_prot.write_field_begin(&TFieldIdentifier::new("default_order_by_limit", TType::I64, 10))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.mem_limit {
      o_prot.write_field_begin(&TFieldIdentifier::new("mem_limit", TType::I64, 12))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.abort_on_default_limit_exceeded {
      o_prot.write_field_begin(&TFieldIdentifier::new("abort_on_default_limit_exceeded", TType::Bool, 13))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.query_timeout {
      o_prot.write_field_begin(&TFieldIdentifier::new("query_timeout", TType::I32, 14))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_report_success {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_report_success", TType::Bool, 15))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.codegen_level {
      o_prot.write_field_begin(&TFieldIdentifier::new("codegen_level", TType::I32, 16))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.kudu_latest_observed_ts {
      o_prot.write_field_begin(&TFieldIdentifier::new("kudu_latest_observed_ts", TType::I64, 17))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.query_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("query_type", TType::I32, 18))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.min_reservation {
      o_prot.write_field_begin(&TFieldIdentifier::new("min_reservation", TType::I64, 19))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.max_reservation {
      o_prot.write_field_begin(&TFieldIdentifier::new("max_reservation", TType::I64, 20))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.initial_reservation_total_claims {
      o_prot.write_field_begin(&TFieldIdentifier::new("initial_reservation_total_claims", TType::I64, 21))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.buffer_pool_limit {
      o_prot.write_field_begin(&TFieldIdentifier::new("buffer_pool_limit", TType::I64, 22))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.default_spillable_buffer_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("default_spillable_buffer_size", TType::I64, 23))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.min_spillable_buffer_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("min_spillable_buffer_size", TType::I64, 24))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.max_row_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("max_row_size", TType::I64, 25))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.disable_stream_preaggregations {
      o_prot.write_field_begin(&TFieldIdentifier::new("disable_stream_preaggregations", TType::Bool, 26))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.mt_dop {
      o_prot.write_field_begin(&TFieldIdentifier::new("mt_dop", TType::I32, 27))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.load_mem_limit {
      o_prot.write_field_begin(&TFieldIdentifier::new("load_mem_limit", TType::I64, 28))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.max_scan_key_num {
      o_prot.write_field_begin(&TFieldIdentifier::new("max_scan_key_num", TType::I32, 29))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.max_pushdown_conditions_per_column {
      o_prot.write_field_begin(&TFieldIdentifier::new("max_pushdown_conditions_per_column", TType::I32, 30))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_spilling {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_spilling", TType::Bool, 31))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_enable_exchange_node_parallel_merge {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_enable_exchange_node_parallel_merge", TType::Bool, 32))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.runtime_filter_wait_time_ms {
      o_prot.write_field_begin(&TFieldIdentifier::new("runtime_filter_wait_time_ms", TType::I32, 33))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.runtime_filter_max_in_num {
      o_prot.write_field_begin(&TFieldIdentifier::new("runtime_filter_max_in_num", TType::I32, 34))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.resource_limit {
      o_prot.write_field_begin(&TFieldIdentifier::new("resource_limit", TType::Struct, 42))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.return_object_data_as_binary {
      o_prot.write_field_begin(&TFieldIdentifier::new("return_object_data_as_binary", TType::Bool, 43))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.trim_tailing_spaces_for_external_table_query {
      o_prot.write_field_begin(&TFieldIdentifier::new("trim_tailing_spaces_for_external_table_query", TType::Bool, 44))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_function_pushdown {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_function_pushdown", TType::Bool, 45))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.fragment_transmission_compression_codec {
      o_prot.write_field_begin(&TFieldIdentifier::new("fragment_transmission_compression_codec", TType::String, 46))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_local_exchange {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_local_exchange", TType::Bool, 48))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.skip_storage_engine_merge {
      o_prot.write_field_begin(&TFieldIdentifier::new("skip_storage_engine_merge", TType::Bool, 49))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.skip_delete_predicate {
      o_prot.write_field_begin(&TFieldIdentifier::new("skip_delete_predicate", TType::Bool, 50))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_new_shuffle_hash_method {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_new_shuffle_hash_method", TType::Bool, 51))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.be_exec_version {
      o_prot.write_field_begin(&TFieldIdentifier::new("be_exec_version", TType::I32, 52))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.partitioned_hash_join_rows_threshold {
      o_prot.write_field_begin(&TFieldIdentifier::new("partitioned_hash_join_rows_threshold", TType::I32, 53))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_share_hash_table_for_broadcast_join {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_share_hash_table_for_broadcast_join", TType::Bool, 54))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.check_overflow_for_decimal {
      o_prot.write_field_begin(&TFieldIdentifier::new("check_overflow_for_decimal", TType::Bool, 55))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.skip_delete_bitmap {
      o_prot.write_field_begin(&TFieldIdentifier::new("skip_delete_bitmap", TType::Bool, 56))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_pipeline_engine {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_pipeline_engine", TType::Bool, 57))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.repeat_max_num {
      o_prot.write_field_begin(&TFieldIdentifier::new("repeat_max_num", TType::I32, 58))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.external_sort_bytes_threshold {
      o_prot.write_field_begin(&TFieldIdentifier::new("external_sort_bytes_threshold", TType::I64, 59))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.partitioned_hash_agg_rows_threshold {
      o_prot.write_field_begin(&TFieldIdentifier::new("partitioned_hash_agg_rows_threshold", TType::I32, 60))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_file_cache {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_file_cache", TType::Bool, 61))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.insert_timeout {
      o_prot.write_field_begin(&TFieldIdentifier::new("insert_timeout", TType::I32, 62))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.execution_timeout {
      o_prot.write_field_begin(&TFieldIdentifier::new("execution_timeout", TType::I32, 63))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.dry_run_query {
      o_prot.write_field_begin(&TFieldIdentifier::new("dry_run_query", TType::Bool, 64))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_common_expr_pushdown {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_common_expr_pushdown", TType::Bool, 65))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.parallel_instance {
      o_prot.write_field_begin(&TFieldIdentifier::new("parallel_instance", TType::I32, 66))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.mysql_row_binary_format {
      o_prot.write_field_begin(&TFieldIdentifier::new("mysql_row_binary_format", TType::Bool, 67))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.external_agg_bytes_threshold {
      o_prot.write_field_begin(&TFieldIdentifier::new("external_agg_bytes_threshold", TType::I64, 68))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.external_agg_partition_bits {
      o_prot.write_field_begin(&TFieldIdentifier::new("external_agg_partition_bits", TType::I32, 69))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.file_cache_base_path {
      o_prot.write_field_begin(&TFieldIdentifier::new("file_cache_base_path", TType::String, 70))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_parquet_lazy_mat {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_parquet_lazy_mat", TType::Bool, 71))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_orc_lazy_mat {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_orc_lazy_mat", TType::Bool, 72))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.scan_queue_mem_limit {
      o_prot.write_field_begin(&TFieldIdentifier::new("scan_queue_mem_limit", TType::I64, 73))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_scan_node_run_serial {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_scan_node_run_serial", TType::Bool, 74))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_insert_strict {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_insert_strict", TType::Bool, 75))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_inverted_index_query {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_inverted_index_query", TType::Bool, 76))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.truncate_char_or_varchar_columns {
      o_prot.write_field_begin(&TFieldIdentifier::new("truncate_char_or_varchar_columns", TType::Bool, 77))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_hash_join_early_start_probe {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_hash_join_early_start_probe", TType::Bool, 78))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_pipeline_x_engine {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_pipeline_x_engine", TType::Bool, 79))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_memtable_on_sink_node {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_memtable_on_sink_node", TType::Bool, 80))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_delete_sub_predicate_v2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_delete_sub_predicate_v2", TType::Bool, 81))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.fe_process_uuid {
      o_prot.write_field_begin(&TFieldIdentifier::new("fe_process_uuid", TType::I64, 82))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.inverted_index_conjunction_opt_threshold {
      o_prot.write_field_begin(&TFieldIdentifier::new("inverted_index_conjunction_opt_threshold", TType::I32, 83))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_profile {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_profile", TType::Bool, 84))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_page_cache {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_page_cache", TType::Bool, 85))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.analyze_timeout {
      o_prot.write_field_begin(&TFieldIdentifier::new("analyze_timeout", TType::I32, 86))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.faster_float_convert {
      o_prot.write_field_begin(&TFieldIdentifier::new("faster_float_convert", TType::Bool, 87))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_decimal256 {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_decimal256", TType::Bool, 88))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_local_shuffle {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_local_shuffle", TType::Bool, 89))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.skip_missing_version {
      o_prot.write_field_begin(&TFieldIdentifier::new("skip_missing_version", TType::Bool, 90))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.runtime_filter_wait_infinitely {
      o_prot.write_field_begin(&TFieldIdentifier::new("runtime_filter_wait_infinitely", TType::Bool, 91))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.condition_cache_digest {
      o_prot.write_field_begin(&TFieldIdentifier::new("condition_cache_digest", TType::I32, 92))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.inverted_index_max_expansions {
      o_prot.write_field_begin(&TFieldIdentifier::new("inverted_index_max_expansions", TType::I32, 93))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.inverted_index_skip_threshold {
      o_prot.write_field_begin(&TFieldIdentifier::new("inverted_index_skip_threshold", TType::I32, 94))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_parallel_scan {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_parallel_scan", TType::Bool, 95))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.parallel_scan_max_scanners_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("parallel_scan_max_scanners_count", TType::I32, 96))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.parallel_scan_min_rows_per_scanner {
      o_prot.write_field_begin(&TFieldIdentifier::new("parallel_scan_min_rows_per_scanner", TType::I64, 97))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.skip_bad_tablet {
      o_prot.write_field_begin(&TFieldIdentifier::new("skip_bad_tablet", TType::Bool, 98))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.scanner_scale_up_ratio {
      o_prot.write_field_begin(&TFieldIdentifier::new("scanner_scale_up_ratio", TType::Double, 99))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_distinct_streaming_aggregation {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_distinct_streaming_aggregation", TType::Bool, 100))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_join_spill {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_join_spill", TType::Bool, 101))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_sort_spill {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_sort_spill", TType::Bool, 102))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_agg_spill {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_agg_spill", TType::Bool, 103))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.min_revocable_mem {
      o_prot.write_field_begin(&TFieldIdentifier::new("min_revocable_mem", TType::I64, 104))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.spill_streaming_agg_mem_limit {
      o_prot.write_field_begin(&TFieldIdentifier::new("spill_streaming_agg_mem_limit", TType::I64, 105))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.data_queue_max_blocks {
      o_prot.write_field_begin(&TFieldIdentifier::new("data_queue_max_blocks", TType::I64, 106))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_common_expr_pushdown_for_inverted_index {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_common_expr_pushdown_for_inverted_index", TType::Bool, 107))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.local_exchange_free_blocks_limit {
      o_prot.write_field_begin(&TFieldIdentifier::new("local_exchange_free_blocks_limit", TType::I64, 108))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_force_spill {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_force_spill", TType::Bool, 109))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_parquet_filter_by_min_max {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_parquet_filter_by_min_max", TType::Bool, 110))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_orc_filter_by_min_max {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_orc_filter_by_min_max", TType::Bool, 111))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.max_column_reader_num {
      o_prot.write_field_begin(&TFieldIdentifier::new("max_column_reader_num", TType::I32, 112))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_local_merge_sort {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_local_merge_sort", TType::Bool, 113))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_parallel_result_sink {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_parallel_result_sink", TType::Bool, 114))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_short_circuit_query_access_column_store {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_short_circuit_query_access_column_store", TType::Bool, 115))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_no_need_read_data_opt {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_no_need_read_data_opt", TType::Bool, 116))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.read_csv_empty_line_as_null {
      o_prot.write_field_begin(&TFieldIdentifier::new("read_csv_empty_line_as_null", TType::Bool, 117))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.serde_dialect {
      o_prot.write_field_begin(&TFieldIdentifier::new("serde_dialect", TType::I32, 118))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_match_without_inverted_index {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_match_without_inverted_index", TType::Bool, 119))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_fallback_on_missing_inverted_index {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_fallback_on_missing_inverted_index", TType::Bool, 120))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.keep_carriage_return {
      o_prot.write_field_begin(&TFieldIdentifier::new("keep_carriage_return", TType::Bool, 121))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.runtime_bloom_filter_min_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("runtime_bloom_filter_min_size", TType::I32, 122))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.hive_parquet_use_column_names {
      o_prot.write_field_begin(&TFieldIdentifier::new("hive_parquet_use_column_names", TType::Bool, 123))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.hive_orc_use_column_names {
      o_prot.write_field_begin(&TFieldIdentifier::new("hive_orc_use_column_names", TType::Bool, 124))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_segment_cache {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_segment_cache", TType::Bool, 125))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.runtime_bloom_filter_max_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("runtime_bloom_filter_max_size", TType::I32, 126))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.in_list_value_count_threshold {
      o_prot.write_field_begin(&TFieldIdentifier::new("in_list_value_count_threshold", TType::I32, 127))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_verbose_profile {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_verbose_profile", TType::Bool, 128))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.rpc_verbose_profile_max_instance_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("rpc_verbose_profile_max_instance_count", TType::I32, 129))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_adaptive_pipeline_task_serial_read_on_limit {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_adaptive_pipeline_task_serial_read_on_limit", TType::Bool, 130))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.adaptive_pipeline_task_serial_read_on_limit {
      o_prot.write_field_begin(&TFieldIdentifier::new("adaptive_pipeline_task_serial_read_on_limit", TType::I32, 131))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.parallel_prepare_threshold {
      o_prot.write_field_begin(&TFieldIdentifier::new("parallel_prepare_threshold", TType::I32, 132))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.partition_topn_max_partitions {
      o_prot.write_field_begin(&TFieldIdentifier::new("partition_topn_max_partitions", TType::I32, 133))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.partition_topn_pre_partition_rows {
      o_prot.write_field_begin(&TFieldIdentifier::new("partition_topn_pre_partition_rows", TType::I32, 134))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_parallel_outfile {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_parallel_outfile", TType::Bool, 135))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_phrase_query_sequential_opt {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_phrase_query_sequential_opt", TType::Bool, 136))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_auto_create_when_overwrite {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_auto_create_when_overwrite", TType::Bool, 137))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.orc_tiny_stripe_threshold_bytes {
      o_prot.write_field_begin(&TFieldIdentifier::new("orc_tiny_stripe_threshold_bytes", TType::I64, 138))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.orc_once_max_read_bytes {
      o_prot.write_field_begin(&TFieldIdentifier::new("orc_once_max_read_bytes", TType::I64, 139))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.orc_max_merge_distance_bytes {
      o_prot.write_field_begin(&TFieldIdentifier::new("orc_max_merge_distance_bytes", TType::I64, 140))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.ignore_runtime_filter_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("ignore_runtime_filter_error", TType::Bool, 141))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_fixed_len_to_uint32_v2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_fixed_len_to_uint32_v2", TType::Bool, 142))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_shared_exchange_sink_buffer {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_shared_exchange_sink_buffer", TType::Bool, 143))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_inverted_index_searcher_cache {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_inverted_index_searcher_cache", TType::Bool, 144))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_inverted_index_query_cache {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_inverted_index_query_cache", TType::Bool, 145))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_condition_cache {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_condition_cache", TType::Bool, 146))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.profile_level {
      o_prot.write_field_begin(&TFieldIdentifier::new("profile_level", TType::I32, 147))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.min_scanner_concurrency {
      o_prot.write_field_begin(&TFieldIdentifier::new("min_scanner_concurrency", TType::I32, 148))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.min_scan_scheduler_concurrency {
      o_prot.write_field_begin(&TFieldIdentifier::new("min_scan_scheduler_concurrency", TType::I32, 149))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_runtime_filter_partition_prune {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_runtime_filter_partition_prune", TType::Bool, 150))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.minimum_operator_memory_required_kb {
      o_prot.write_field_begin(&TFieldIdentifier::new("minimum_operator_memory_required_kb", TType::I32, 151))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_mem_overcommit {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_mem_overcommit", TType::Bool, 152))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.query_slot_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("query_slot_count", TType::I32, 153))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_spill {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_spill", TType::Bool, 154))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_reserve_memory {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_reserve_memory", TType::Bool, 155))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.revocable_memory_high_watermark_percent {
      o_prot.write_field_begin(&TFieldIdentifier::new("revocable_memory_high_watermark_percent", TType::I32, 156))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.spill_sort_mem_limit {
      o_prot.write_field_begin(&TFieldIdentifier::new("spill_sort_mem_limit", TType::I64, 157))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.spill_sort_batch_bytes {
      o_prot.write_field_begin(&TFieldIdentifier::new("spill_sort_batch_bytes", TType::I64, 158))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.spill_aggregation_partition_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("spill_aggregation_partition_count", TType::I32, 159))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.spill_hash_join_partition_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("spill_hash_join_partition_count", TType::I32, 160))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.low_memory_mode_buffer_limit {
      o_prot.write_field_begin(&TFieldIdentifier::new("low_memory_mode_buffer_limit", TType::I64, 161))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.dump_heap_profile_when_mem_limit_exceeded {
      o_prot.write_field_begin(&TFieldIdentifier::new("dump_heap_profile_when_mem_limit_exceeded", TType::Bool, 162))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.inverted_index_compatible_read {
      o_prot.write_field_begin(&TFieldIdentifier::new("inverted_index_compatible_read", TType::Bool, 163))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.check_orc_init_sargs_success {
      o_prot.write_field_begin(&TFieldIdentifier::new("check_orc_init_sargs_success", TType::Bool, 164))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.exchange_multi_blocks_byte_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("exchange_multi_blocks_byte_size", TType::I32, 165))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_strict_cast {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_strict_cast", TType::Bool, 166))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.new_version_unix_timestamp {
      o_prot.write_field_begin(&TFieldIdentifier::new("new_version_unix_timestamp", TType::Bool, 167))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.hnsw_ef_search {
      o_prot.write_field_begin(&TFieldIdentifier::new("hnsw_ef_search", TType::I32, 168))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.hnsw_check_relative_distance {
      o_prot.write_field_begin(&TFieldIdentifier::new("hnsw_check_relative_distance", TType::Bool, 169))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.hnsw_bounded_queue {
      o_prot.write_field_begin(&TFieldIdentifier::new("hnsw_bounded_queue", TType::Bool, 170))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.optimize_index_scan_parallelism {
      o_prot.write_field_begin(&TFieldIdentifier::new("optimize_index_scan_parallelism", TType::Bool, 171))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_prefer_cached_rowset {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_prefer_cached_rowset", TType::Bool, 172))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.query_freshness_tolerance_ms {
      o_prot.write_field_begin(&TFieldIdentifier::new("query_freshness_tolerance_ms", TType::I64, 173))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.merge_read_slice_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("merge_read_slice_size", TType::I64, 174))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_fuzzy_blockable_task {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_fuzzy_blockable_task", TType::Bool, 175))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.shuffled_agg_ids {
      o_prot.write_field_begin(&TFieldIdentifier::new("shuffled_agg_ids", TType::List, 176))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I32, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i32(*e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_extended_regex {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_extended_regex", TType::Bool, 177))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.iceberg_write_target_file_size_bytes {
      o_prot.write_field_begin(&TFieldIdentifier::new("iceberg_write_target_file_size_bytes", TType::I64, 178))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.disable_file_cache {
      o_prot.write_field_begin(&TFieldIdentifier::new("disable_file_cache", TType::Bool, 1000))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TScanRangeParams
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TScanRangeParams {
  pub scan_range: plan_nodes::TScanRange,
  pub volume_id: Option<i32>,
}

impl TScanRangeParams {
  pub fn new<F2>(scan_range: plan_nodes::TScanRange, volume_id: F2) -> TScanRangeParams where F2: Into<Option<i32>> {
    TScanRangeParams {
      scan_range,
      volume_id: volume_id.into(),
    }
  }
}

impl TSerializable for TScanRangeParams {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TScanRangeParams> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<plan_nodes::TScanRange> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = plan_nodes::TScanRange::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TScanRangeParams.scan_range", &f_1)?;
    let ret = TScanRangeParams {
      scan_range: f_1.expect("auto-generated code should have checked for presence of required fields"),
      volume_id: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TScanRangeParams");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("scan_range", TType::Struct, 1))?;
    self.scan_range.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.volume_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("volume_id", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TRuntimeFilterTargetParams
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TRuntimeFilterTargetParams {
  pub target_fragment_instance_id: types::TUniqueId,
  pub target_fragment_instance_addr: types::TNetworkAddress,
}

impl TRuntimeFilterTargetParams {
  pub fn new(target_fragment_instance_id: types::TUniqueId, target_fragment_instance_addr: types::TNetworkAddress) -> TRuntimeFilterTargetParams {
    TRuntimeFilterTargetParams {
      target_fragment_instance_id,
      target_fragment_instance_addr,
    }
  }
}

impl TSerializable for TRuntimeFilterTargetParams {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TRuntimeFilterTargetParams> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<types::TUniqueId> = None;
    let mut f_2: Option<types::TNetworkAddress> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = types::TUniqueId::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = types::TNetworkAddress::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TRuntimeFilterTargetParams.target_fragment_instance_id", &f_1)?;
    verify_required_field_exists("TRuntimeFilterTargetParams.target_fragment_instance_addr", &f_2)?;
    let ret = TRuntimeFilterTargetParams {
      target_fragment_instance_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      target_fragment_instance_addr: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TRuntimeFilterTargetParams");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("target_fragment_instance_id", TType::Struct, 1))?;
    self.target_fragment_instance_id.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("target_fragment_instance_addr", TType::Struct, 2))?;
    self.target_fragment_instance_addr.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TRuntimeFilterTargetParamsV2
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TRuntimeFilterTargetParamsV2 {
  pub target_fragment_instance_ids: Vec<types::TUniqueId>,
  pub target_fragment_instance_addr: types::TNetworkAddress,
  pub target_fragment_ids: Option<Vec<i32>>,
}

impl TRuntimeFilterTargetParamsV2 {
  pub fn new<F3>(target_fragment_instance_ids: Vec<types::TUniqueId>, target_fragment_instance_addr: types::TNetworkAddress, target_fragment_ids: F3) -> TRuntimeFilterTargetParamsV2 where F3: Into<Option<Vec<i32>>> {
    TRuntimeFilterTargetParamsV2 {
      target_fragment_instance_ids,
      target_fragment_instance_addr,
      target_fragment_ids: target_fragment_ids.into(),
    }
  }
}

impl TSerializable for TRuntimeFilterTargetParamsV2 {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TRuntimeFilterTargetParamsV2> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<types::TUniqueId>> = None;
    let mut f_2: Option<types::TNetworkAddress> = None;
    let mut f_3: Option<Vec<i32>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::TUniqueId> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_3 = types::TUniqueId::read_from_in_protocol(i_prot)?;
            val.push(list_elem_3);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = types::TNetworkAddress::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_4 = i_prot.read_i32()?;
            val.push(list_elem_4);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TRuntimeFilterTargetParamsV2.target_fragment_instance_ids", &f_1)?;
    verify_required_field_exists("TRuntimeFilterTargetParamsV2.target_fragment_instance_addr", &f_2)?;
    let ret = TRuntimeFilterTargetParamsV2 {
      target_fragment_instance_ids: f_1.expect("auto-generated code should have checked for presence of required fields"),
      target_fragment_instance_addr: f_2.expect("auto-generated code should have checked for presence of required fields"),
      target_fragment_ids: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TRuntimeFilterTargetParamsV2");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("target_fragment_instance_ids", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.target_fragment_instance_ids.len() as i32))?;
    for e in &self.target_fragment_instance_ids {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("target_fragment_instance_addr", TType::Struct, 2))?;
    self.target_fragment_instance_addr.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.target_fragment_ids {
      o_prot.write_field_begin(&TFieldIdentifier::new("target_fragment_ids", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I32, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i32(*e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TRuntimeFilterParams
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TRuntimeFilterParams {
  pub runtime_filter_merge_addr: Option<types::TNetworkAddress>,
  pub rid_to_target_param: Option<BTreeMap<i32, Vec<TRuntimeFilterTargetParams>>>,
  pub rid_to_runtime_filter: Option<BTreeMap<i32, plan_nodes::TRuntimeFilterDesc>>,
  pub runtime_filter_builder_num: Option<BTreeMap<i32, i32>>,
  pub rid_to_target_paramv2: Option<BTreeMap<i32, Vec<TRuntimeFilterTargetParamsV2>>>,
}

impl TRuntimeFilterParams {
  pub fn new<F1, F2, F3, F4, F5>(runtime_filter_merge_addr: F1, rid_to_target_param: F2, rid_to_runtime_filter: F3, runtime_filter_builder_num: F4, rid_to_target_paramv2: F5) -> TRuntimeFilterParams where F1: Into<Option<types::TNetworkAddress>>, F2: Into<Option<BTreeMap<i32, Vec<TRuntimeFilterTargetParams>>>>, F3: Into<Option<BTreeMap<i32, plan_nodes::TRuntimeFilterDesc>>>, F4: Into<Option<BTreeMap<i32, i32>>>, F5: Into<Option<BTreeMap<i32, Vec<TRuntimeFilterTargetParamsV2>>>> {
    TRuntimeFilterParams {
      runtime_filter_merge_addr: runtime_filter_merge_addr.into(),
      rid_to_target_param: rid_to_target_param.into(),
      rid_to_runtime_filter: rid_to_runtime_filter.into(),
      runtime_filter_builder_num: runtime_filter_builder_num.into(),
      rid_to_target_paramv2: rid_to_target_paramv2.into(),
    }
  }
}

impl TSerializable for TRuntimeFilterParams {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TRuntimeFilterParams> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<types::TNetworkAddress> = None;
    let mut f_2: Option<BTreeMap<i32, Vec<TRuntimeFilterTargetParams>>> = None;
    let mut f_3: Option<BTreeMap<i32, plan_nodes::TRuntimeFilterDesc>> = None;
    let mut f_4: Option<BTreeMap<i32, i32>> = None;
    let mut f_5: Option<BTreeMap<i32, Vec<TRuntimeFilterTargetParamsV2>>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = types::TNetworkAddress::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<i32, Vec<TRuntimeFilterTargetParams>> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_5 = i_prot.read_i32()?;
            let list_ident = i_prot.read_list_begin()?;
            let mut map_val_6: Vec<TRuntimeFilterTargetParams> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_7 = TRuntimeFilterTargetParams::read_from_in_protocol(i_prot)?;
              map_val_6.push(list_elem_7);
            }
            i_prot.read_list_end()?;
            val.insert(map_key_5, map_val_6);
          }
          i_prot.read_map_end()?;
          f_2 = Some(val);
        },
        3 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<i32, plan_nodes::TRuntimeFilterDesc> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_8 = i_prot.read_i32()?;
            let map_val_9 = plan_nodes::TRuntimeFilterDesc::read_from_in_protocol(i_prot)?;
            val.insert(map_key_8, map_val_9);
          }
          i_prot.read_map_end()?;
          f_3 = Some(val);
        },
        4 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<i32, i32> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_10 = i_prot.read_i32()?;
            let map_val_11 = i_prot.read_i32()?;
            val.insert(map_key_10, map_val_11);
          }
          i_prot.read_map_end()?;
          f_4 = Some(val);
        },
        5 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<i32, Vec<TRuntimeFilterTargetParamsV2>> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_12 = i_prot.read_i32()?;
            let list_ident = i_prot.read_list_begin()?;
            let mut map_val_13: Vec<TRuntimeFilterTargetParamsV2> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_14 = TRuntimeFilterTargetParamsV2::read_from_in_protocol(i_prot)?;
              map_val_13.push(list_elem_14);
            }
            i_prot.read_list_end()?;
            val.insert(map_key_12, map_val_13);
          }
          i_prot.read_map_end()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TRuntimeFilterParams {
      runtime_filter_merge_addr: f_1,
      rid_to_target_param: f_2,
      rid_to_runtime_filter: f_3,
      runtime_filter_builder_num: f_4,
      rid_to_target_paramv2: f_5,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TRuntimeFilterParams");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.runtime_filter_merge_addr {
      o_prot.write_field_begin(&TFieldIdentifier::new("runtime_filter_merge_addr", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.rid_to_target_param {
      o_prot.write_field_begin(&TFieldIdentifier::new("rid_to_target_param", TType::Map, 2))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::I32, TType::List, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_i32(*k)?;
        o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, v.len() as i32))?;
        for e in v {
          e.write_to_out_protocol(o_prot)?;
        }
        o_prot.write_list_end()?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.rid_to_runtime_filter {
      o_prot.write_field_begin(&TFieldIdentifier::new("rid_to_runtime_filter", TType::Map, 3))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::I32, TType::Struct, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_i32(*k)?;
        v.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.runtime_filter_builder_num {
      o_prot.write_field_begin(&TFieldIdentifier::new("runtime_filter_builder_num", TType::Map, 4))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::I32, TType::I32, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_i32(*k)?;
        o_prot.write_i32(*v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.rid_to_target_paramv2 {
      o_prot.write_field_begin(&TFieldIdentifier::new("rid_to_target_paramv2", TType::Map, 5))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::I32, TType::List, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_i32(*k)?;
        o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, v.len() as i32))?;
        for e in v {
          e.write_to_out_protocol(o_prot)?;
        }
        o_prot.write_list_end()?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TPlanFragmentExecParams
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TPlanFragmentExecParams {
  pub query_id: types::TUniqueId,
  pub fragment_instance_id: types::TUniqueId,
}

impl TPlanFragmentExecParams {
  pub fn new(query_id: types::TUniqueId, fragment_instance_id: types::TUniqueId) -> TPlanFragmentExecParams {
    TPlanFragmentExecParams {
      query_id,
      fragment_instance_id,
    }
  }
}

impl TSerializable for TPlanFragmentExecParams {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TPlanFragmentExecParams> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<types::TUniqueId> = None;
    let mut f_2: Option<types::TUniqueId> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = types::TUniqueId::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = types::TUniqueId::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TPlanFragmentExecParams.query_id", &f_1)?;
    verify_required_field_exists("TPlanFragmentExecParams.fragment_instance_id", &f_2)?;
    let ret = TPlanFragmentExecParams {
      query_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      fragment_instance_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TPlanFragmentExecParams");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("query_id", TType::Struct, 1))?;
    self.query_id.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("fragment_instance_id", TType::Struct, 2))?;
    self.fragment_instance_id.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TQueryGlobals
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TQueryGlobals {
  pub now_string: String,
  pub timestamp_ms: Option<i64>,
  pub time_zone: Option<String>,
  pub load_zero_tolerance: Option<bool>,
  pub nano_seconds: Option<i32>,
  pub lc_time_names: Option<String>,
}

impl TQueryGlobals {
  pub fn new<F2, F3, F4, F5, F6>(now_string: String, timestamp_ms: F2, time_zone: F3, load_zero_tolerance: F4, nano_seconds: F5, lc_time_names: F6) -> TQueryGlobals where F2: Into<Option<i64>>, F3: Into<Option<String>>, F4: Into<Option<bool>>, F5: Into<Option<i32>>, F6: Into<Option<String>> {
    TQueryGlobals {
      now_string,
      timestamp_ms: timestamp_ms.into(),
      time_zone: time_zone.into(),
      load_zero_tolerance: load_zero_tolerance.into(),
      nano_seconds: nano_seconds.into(),
      lc_time_names: lc_time_names.into(),
    }
  }
}

impl TSerializable for TQueryGlobals {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TQueryGlobals> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<bool> = None;
    let mut f_5: Option<i32> = None;
    let mut f_6: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TQueryGlobals.now_string", &f_1)?;
    let ret = TQueryGlobals {
      now_string: f_1.expect("auto-generated code should have checked for presence of required fields"),
      timestamp_ms: f_2,
      time_zone: f_3,
      load_zero_tolerance: f_4,
      nano_seconds: f_5,
      lc_time_names: f_6,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TQueryGlobals");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("now_string", TType::String, 1))?;
    o_prot.write_string(&self.now_string)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.timestamp_ms {
      o_prot.write_field_begin(&TFieldIdentifier::new("timestamp_ms", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.time_zone {
      o_prot.write_field_begin(&TFieldIdentifier::new("time_zone", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.load_zero_tolerance {
      o_prot.write_field_begin(&TFieldIdentifier::new("load_zero_tolerance", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.nano_seconds {
      o_prot.write_field_begin(&TFieldIdentifier::new("nano_seconds", TType::I32, 5))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.lc_time_names {
      o_prot.write_field_begin(&TFieldIdentifier::new("lc_time_names", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TTxnParams
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTxnParams {
  pub need_txn: Option<bool>,
  pub token: Option<String>,
  pub thrift_rpc_timeout_ms: Option<i64>,
  pub db: Option<String>,
  pub tbl: Option<String>,
  pub user_ip: Option<String>,
  pub txn_id: Option<i64>,
  pub fragment_instance_id: Option<types::TUniqueId>,
  pub db_id: Option<i64>,
  pub max_filter_ratio: Option<OrderedFloat<f64>>,
  pub enable_pipeline_txn_load: Option<bool>,
}

impl TTxnParams {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11>(need_txn: F1, token: F2, thrift_rpc_timeout_ms: F3, db: F4, tbl: F5, user_ip: F6, txn_id: F7, fragment_instance_id: F8, db_id: F9, max_filter_ratio: F10, enable_pipeline_txn_load: F11) -> TTxnParams where F1: Into<Option<bool>>, F2: Into<Option<String>>, F3: Into<Option<i64>>, F4: Into<Option<String>>, F5: Into<Option<String>>, F6: Into<Option<String>>, F7: Into<Option<i64>>, F8: Into<Option<types::TUniqueId>>, F9: Into<Option<i64>>, F10: Into<Option<OrderedFloat<f64>>>, F11: Into<Option<bool>> {
    TTxnParams {
      need_txn: need_txn.into(),
      token: token.into(),
      thrift_rpc_timeout_ms: thrift_rpc_timeout_ms.into(),
      db: db.into(),
      tbl: tbl.into(),
      user_ip: user_ip.into(),
      txn_id: txn_id.into(),
      fragment_instance_id: fragment_instance_id.into(),
      db_id: db_id.into(),
      max_filter_ratio: max_filter_ratio.into(),
      enable_pipeline_txn_load: enable_pipeline_txn_load.into(),
    }
  }
}

impl TSerializable for TTxnParams {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTxnParams> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<String> = None;
    let mut f_7: Option<i64> = None;
    let mut f_8: Option<types::TUniqueId> = None;
    let mut f_9: Option<i64> = None;
    let mut f_10: Option<OrderedFloat<f64>> = None;
    let mut f_11: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i64()?;
          f_7 = Some(val);
        },
        8 => {
          let val = types::TUniqueId::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_i64()?;
          f_9 = Some(val);
        },
        10 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_bool()?;
          f_11 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TTxnParams {
      need_txn: f_1,
      token: f_2,
      thrift_rpc_timeout_ms: f_3,
      db: f_4,
      tbl: f_5,
      user_ip: f_6,
      txn_id: f_7,
      fragment_instance_id: f_8,
      db_id: f_9,
      max_filter_ratio: f_10,
      enable_pipeline_txn_load: f_11,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TTxnParams");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.need_txn {
      o_prot.write_field_begin(&TFieldIdentifier::new("need_txn", TType::Bool, 1))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.token {
      o_prot.write_field_begin(&TFieldIdentifier::new("token", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.thrift_rpc_timeout_ms {
      o_prot.write_field_begin(&TFieldIdentifier::new("thrift_rpc_timeout_ms", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.db {
      o_prot.write_field_begin(&TFieldIdentifier::new("db", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.tbl {
      o_prot.write_field_begin(&TFieldIdentifier::new("tbl", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.user_ip {
      o_prot.write_field_begin(&TFieldIdentifier::new("user_ip", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.txn_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("txn_id", TType::I64, 7))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.fragment_instance_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("fragment_instance_id", TType::Struct, 8))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.db_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("db_id", TType::I64, 9))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.max_filter_ratio {
      o_prot.write_field_begin(&TFieldIdentifier::new("max_filter_ratio", TType::Double, 10))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_pipeline_txn_load {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable_pipeline_txn_load", TType::Bool, 11))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TColumnDict
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TColumnDict {
  pub type_: Option<types::TPrimitiveType>,
  pub str_dict: Option<Vec<String>>,
}

impl TColumnDict {
  pub fn new<F1, F2>(type_: F1, str_dict: F2) -> TColumnDict where F1: Into<Option<types::TPrimitiveType>>, F2: Into<Option<Vec<String>>> {
    TColumnDict {
      type_: type_.into(),
      str_dict: str_dict.into(),
    }
  }
}

impl TSerializable for TColumnDict {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TColumnDict> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<types::TPrimitiveType> = None;
    let mut f_2: Option<Vec<String>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = types::TPrimitiveType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_15 = i_prot.read_string()?;
            val.push(list_elem_15);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TColumnDict {
      type_: f_1,
      str_dict: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TColumnDict");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.type_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.str_dict {
      o_prot.write_field_begin(&TFieldIdentifier::new("str_dict", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TGlobalDict
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TGlobalDict {
  pub dicts: Option<BTreeMap<i32, TColumnDict>>,
  pub slot_dicts: Option<BTreeMap<i32, i32>>,
}

impl TGlobalDict {
  pub fn new<F1, F2>(dicts: F1, slot_dicts: F2) -> TGlobalDict where F1: Into<Option<BTreeMap<i32, TColumnDict>>>, F2: Into<Option<BTreeMap<i32, i32>>> {
    TGlobalDict {
      dicts: dicts.into(),
      slot_dicts: slot_dicts.into(),
    }
  }
}

impl TSerializable for TGlobalDict {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TGlobalDict> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<BTreeMap<i32, TColumnDict>> = None;
    let mut f_2: Option<BTreeMap<i32, i32>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<i32, TColumnDict> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_16 = i_prot.read_i32()?;
            let map_val_17 = TColumnDict::read_from_in_protocol(i_prot)?;
            val.insert(map_key_16, map_val_17);
          }
          i_prot.read_map_end()?;
          f_1 = Some(val);
        },
        2 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<i32, i32> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_18 = i_prot.read_i32()?;
            let map_val_19 = i_prot.read_i32()?;
            val.insert(map_key_18, map_val_19);
          }
          i_prot.read_map_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TGlobalDict {
      dicts: f_1,
      slot_dicts: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TGlobalDict");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.dicts {
      o_prot.write_field_begin(&TFieldIdentifier::new("dicts", TType::Map, 1))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::I32, TType::Struct, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_i32(*k)?;
        v.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.slot_dicts {
      o_prot.write_field_begin(&TFieldIdentifier::new("slot_dicts", TType::Map, 2))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::I32, TType::I32, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_i32(*k)?;
        o_prot.write_i32(*v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TPipelineWorkloadGroup
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TPipelineWorkloadGroup {
  pub id: Option<i64>,
  pub name: Option<String>,
  pub properties: Option<BTreeMap<String, String>>,
  pub version: Option<i64>,
}

impl TPipelineWorkloadGroup {
  pub fn new<F1, F2, F3, F4>(id: F1, name: F2, properties: F3, version: F4) -> TPipelineWorkloadGroup where F1: Into<Option<i64>>, F2: Into<Option<String>>, F3: Into<Option<BTreeMap<String, String>>>, F4: Into<Option<i64>> {
    TPipelineWorkloadGroup {
      id: id.into(),
      name: name.into(),
      properties: properties.into(),
      version: version.into(),
    }
  }
}

impl TSerializable for TPipelineWorkloadGroup {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TPipelineWorkloadGroup> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<BTreeMap<String, String>> = None;
    let mut f_4: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_20 = i_prot.read_string()?;
            let map_val_21 = i_prot.read_string()?;
            val.insert(map_key_20, map_val_21);
          }
          i_prot.read_map_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TPipelineWorkloadGroup {
      id: f_1,
      name: f_2,
      properties: f_3,
      version: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TPipelineWorkloadGroup");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.id {
      o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.properties {
      o_prot.write_field_begin(&TFieldIdentifier::new("properties", TType::Map, 3))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.version {
      o_prot.write_field_begin(&TFieldIdentifier::new("version", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TFoldConstantParams
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TFoldConstantParams {
  pub expr_map: BTreeMap<String, BTreeMap<String, exprs::TExpr>>,
  pub query_globals: TQueryGlobals,
  pub vec_exec: Option<bool>,
  pub query_options: Option<TQueryOptions>,
  pub query_id: Option<types::TUniqueId>,
  pub is_nereids: Option<bool>,
}

impl TFoldConstantParams {
  pub fn new<F3, F4, F5, F6>(expr_map: BTreeMap<String, BTreeMap<String, exprs::TExpr>>, query_globals: TQueryGlobals, vec_exec: F3, query_options: F4, query_id: F5, is_nereids: F6) -> TFoldConstantParams where F3: Into<Option<bool>>, F4: Into<Option<TQueryOptions>>, F5: Into<Option<types::TUniqueId>>, F6: Into<Option<bool>> {
    TFoldConstantParams {
      expr_map,
      query_globals,
      vec_exec: vec_exec.into(),
      query_options: query_options.into(),
      query_id: query_id.into(),
      is_nereids: is_nereids.into(),
    }
  }
}

impl TSerializable for TFoldConstantParams {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TFoldConstantParams> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<BTreeMap<String, BTreeMap<String, exprs::TExpr>>> = None;
    let mut f_2: Option<TQueryGlobals> = None;
    let mut f_3: Option<bool> = None;
    let mut f_4: Option<TQueryOptions> = None;
    let mut f_5: Option<types::TUniqueId> = None;
    let mut f_6: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, BTreeMap<String, exprs::TExpr>> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_22 = i_prot.read_string()?;
            let map_ident = i_prot.read_map_begin()?;
            let mut map_val_23: BTreeMap<String, exprs::TExpr> = BTreeMap::new();
            for _ in 0..map_ident.size {
              let map_key_24 = i_prot.read_string()?;
              let map_val_25 = exprs::TExpr::read_from_in_protocol(i_prot)?;
              map_val_23.insert(map_key_24, map_val_25);
            }
            i_prot.read_map_end()?;
            val.insert(map_key_22, map_val_23);
          }
          i_prot.read_map_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = TQueryGlobals::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = TQueryOptions::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = types::TUniqueId::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TFoldConstantParams.expr_map", &f_1)?;
    verify_required_field_exists("TFoldConstantParams.query_globals", &f_2)?;
    let ret = TFoldConstantParams {
      expr_map: f_1.expect("auto-generated code should have checked for presence of required fields"),
      query_globals: f_2.expect("auto-generated code should have checked for presence of required fields"),
      vec_exec: f_3,
      query_options: f_4,
      query_id: f_5,
      is_nereids: f_6,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TFoldConstantParams");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("expr_map", TType::Map, 1))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Map, self.expr_map.len() as i32))?;
    for (k, v) in &self.expr_map {
      o_prot.write_string(k)?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Struct, v.len() as i32))?;
      for (k, v) in v {
        o_prot.write_string(k)?;
        v.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_map_end()?;
    }
    o_prot.write_map_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("query_globals", TType::Struct, 2))?;
    self.query_globals.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.vec_exec {
      o_prot.write_field_begin(&TFieldIdentifier::new("vec_exec", TType::Bool, 3))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.query_options {
      o_prot.write_field_begin(&TFieldIdentifier::new("query_options", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.query_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("query_id", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_nereids {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_nereids", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TTabletWithPartition
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTabletWithPartition {
  pub partition_id: i64,
  pub tablet_id: i64,
}

impl TTabletWithPartition {
  pub fn new(partition_id: i64, tablet_id: i64) -> TTabletWithPartition {
    TTabletWithPartition {
      partition_id,
      tablet_id,
    }
  }
}

impl TSerializable for TTabletWithPartition {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTabletWithPartition> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TTabletWithPartition.partition_id", &f_1)?;
    verify_required_field_exists("TTabletWithPartition.tablet_id", &f_2)?;
    let ret = TTabletWithPartition {
      partition_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tablet_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TTabletWithPartition");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("partition_id", TType::I64, 1))?;
    o_prot.write_i64(self.partition_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tablet_id", TType::I64, 2))?;
    o_prot.write_i64(self.tablet_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TFetchDataResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TFetchDataResult {
  pub result_batch: data::TResultBatch,
  pub eos: bool,
  pub packet_num: i32,
  pub status: Option<status::TStatus>,
}

impl TFetchDataResult {
  pub fn new<F4>(result_batch: data::TResultBatch, eos: bool, packet_num: i32, status: F4) -> TFetchDataResult where F4: Into<Option<status::TStatus>> {
    TFetchDataResult {
      result_batch,
      eos,
      packet_num,
      status: status.into(),
    }
  }
}

impl TSerializable for TFetchDataResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TFetchDataResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<data::TResultBatch> = None;
    let mut f_2: Option<bool> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<status::TStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = data::TResultBatch::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = status::TStatus::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TFetchDataResult.result_batch", &f_1)?;
    verify_required_field_exists("TFetchDataResult.eos", &f_2)?;
    verify_required_field_exists("TFetchDataResult.packet_num", &f_3)?;
    let ret = TFetchDataResult {
      result_batch: f_1.expect("auto-generated code should have checked for presence of required fields"),
      eos: f_2.expect("auto-generated code should have checked for presence of required fields"),
      packet_num: f_3.expect("auto-generated code should have checked for presence of required fields"),
      status: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TFetchDataResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("result_batch", TType::Struct, 1))?;
    self.result_batch.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("eos", TType::Bool, 2))?;
    o_prot.write_bool(self.eos)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("packet_num", TType::I32, 3))?;
    o_prot.write_i32(self.packet_num)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.status {
      o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TAIResource
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TAIResource {
  pub endpoint: String,
  pub provider_type: String,
  pub model_name: String,
  pub api_key: Option<String>,
  pub temperature: Option<OrderedFloat<f64>>,
  pub max_tokens: Option<i64>,
  pub max_retries: Option<i32>,
  pub retry_delay_second: Option<i32>,
  pub anthropic_version: Option<String>,
  pub dimensions: Option<i32>,
}

impl TAIResource {
  pub fn new<F4, F5, F6, F7, F8, F9, F10>(endpoint: String, provider_type: String, model_name: String, api_key: F4, temperature: F5, max_tokens: F6, max_retries: F7, retry_delay_second: F8, anthropic_version: F9, dimensions: F10) -> TAIResource where F4: Into<Option<String>>, F5: Into<Option<OrderedFloat<f64>>>, F6: Into<Option<i64>>, F7: Into<Option<i32>>, F8: Into<Option<i32>>, F9: Into<Option<String>>, F10: Into<Option<i32>> {
    TAIResource {
      endpoint,
      provider_type,
      model_name,
      api_key: api_key.into(),
      temperature: temperature.into(),
      max_tokens: max_tokens.into(),
      max_retries: max_retries.into(),
      retry_delay_second: retry_delay_second.into(),
      anthropic_version: anthropic_version.into(),
      dimensions: dimensions.into(),
    }
  }
}

impl TSerializable for TAIResource {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TAIResource> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<OrderedFloat<f64>> = None;
    let mut f_6: Option<i64> = None;
    let mut f_7: Option<i32> = None;
    let mut f_8: Option<i32> = None;
    let mut f_9: Option<String> = None;
    let mut f_10: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i64()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i32()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i32()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_string()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_i32()?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TAIResource.endpoint", &f_1)?;
    verify_required_field_exists("TAIResource.provider_type", &f_2)?;
    verify_required_field_exists("TAIResource.model_name", &f_3)?;
    let ret = TAIResource {
      endpoint: f_1.expect("auto-generated code should have checked for presence of required fields"),
      provider_type: f_2.expect("auto-generated code should have checked for presence of required fields"),
      model_name: f_3.expect("auto-generated code should have checked for presence of required fields"),
      api_key: f_4,
      temperature: f_5,
      max_tokens: f_6,
      max_retries: f_7,
      retry_delay_second: f_8,
      anthropic_version: f_9,
      dimensions: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TAIResource");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("endpoint", TType::String, 1))?;
    o_prot.write_string(&self.endpoint)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("provider_type", TType::String, 2))?;
    o_prot.write_string(&self.provider_type)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("model_name", TType::String, 3))?;
    o_prot.write_string(&self.model_name)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.api_key {
      o_prot.write_field_begin(&TFieldIdentifier::new("api_key", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.temperature {
      o_prot.write_field_begin(&TFieldIdentifier::new("temperature", TType::Double, 5))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.max_tokens {
      o_prot.write_field_begin(&TFieldIdentifier::new("max_tokens", TType::I64, 6))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.max_retries {
      o_prot.write_field_begin(&TFieldIdentifier::new("max_retries", TType::I32, 7))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.retry_delay_second {
      o_prot.write_field_begin(&TFieldIdentifier::new("retry_delay_second", TType::I32, 8))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.anthropic_version {
      o_prot.write_field_begin(&TFieldIdentifier::new("anthropic_version", TType::String, 9))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.dimensions {
      o_prot.write_field_begin(&TFieldIdentifier::new("dimensions", TType::I32, 10))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TCondition
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TCondition {
  pub column_name: String,
  pub condition_op: String,
  pub condition_values: Vec<String>,
  pub column_unique_id: Option<i32>,
  pub marked_by_runtime_filter: Option<bool>,
  pub compound_type: Option<TCompoundType>,
}

impl TCondition {
  pub fn new<F4, F5, F1000>(column_name: String, condition_op: String, condition_values: Vec<String>, column_unique_id: F4, marked_by_runtime_filter: F5, compound_type: F1000) -> TCondition where F4: Into<Option<i32>>, F5: Into<Option<bool>>, F1000: Into<Option<TCompoundType>> {
    TCondition {
      column_name,
      condition_op,
      condition_values,
      column_unique_id: column_unique_id.into(),
      marked_by_runtime_filter: marked_by_runtime_filter.into(),
      compound_type: compound_type.into(),
    }
  }
}

impl TSerializable for TCondition {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCondition> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<String>> = None;
    let mut f_4: Option<i32> = None;
    let mut f_5: Option<bool> = None;
    let mut f_1000: Option<TCompoundType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_26 = i_prot.read_string()?;
            val.push(list_elem_26);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        1000 => {
          let val = TCompoundType::read_from_in_protocol(i_prot)?;
          f_1000 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TCondition.column_name", &f_1)?;
    verify_required_field_exists("TCondition.condition_op", &f_2)?;
    verify_required_field_exists("TCondition.condition_values", &f_3)?;
    let ret = TCondition {
      column_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      condition_op: f_2.expect("auto-generated code should have checked for presence of required fields"),
      condition_values: f_3.expect("auto-generated code should have checked for presence of required fields"),
      column_unique_id: f_4,
      marked_by_runtime_filter: f_5,
      compound_type: f_1000,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TCondition");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("column_name", TType::String, 1))?;
    o_prot.write_string(&self.column_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("condition_op", TType::String, 2))?;
    o_prot.write_string(&self.condition_op)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("condition_values", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.condition_values.len() as i32))?;
    for e in &self.condition_values {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.column_unique_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("column_unique_id", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.marked_by_runtime_filter {
      o_prot.write_field_begin(&TFieldIdentifier::new("marked_by_runtime_filter", TType::Bool, 5))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.compound_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("compound_type", TType::I32, 1000))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TPipelineInstanceParams
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TPipelineInstanceParams {
  pub fragment_instance_id: types::TUniqueId,
  pub build_hash_table_for_broadcast_join: Option<bool>,
  pub per_node_scan_ranges: BTreeMap<types::TPlanNodeId, Vec<TScanRangeParams>>,
  pub sender_id: Option<i32>,
  pub runtime_filter_params: Option<TRuntimeFilterParams>,
  pub backend_num: Option<i32>,
  pub per_node_shared_scans: Option<BTreeMap<types::TPlanNodeId, bool>>,
  pub topn_filter_source_node_ids: Option<Vec<i32>>,
  pub topn_filter_descs: Option<Vec<plan_nodes::TTopnFilterDesc>>,
}

impl TPipelineInstanceParams {
  pub fn new<F2, F4, F5, F6, F7, F8, F9>(fragment_instance_id: types::TUniqueId, build_hash_table_for_broadcast_join: F2, per_node_scan_ranges: BTreeMap<types::TPlanNodeId, Vec<TScanRangeParams>>, sender_id: F4, runtime_filter_params: F5, backend_num: F6, per_node_shared_scans: F7, topn_filter_source_node_ids: F8, topn_filter_descs: F9) -> TPipelineInstanceParams where F2: Into<Option<bool>>, F4: Into<Option<i32>>, F5: Into<Option<TRuntimeFilterParams>>, F6: Into<Option<i32>>, F7: Into<Option<BTreeMap<types::TPlanNodeId, bool>>>, F8: Into<Option<Vec<i32>>>, F9: Into<Option<Vec<plan_nodes::TTopnFilterDesc>>> {
    TPipelineInstanceParams {
      fragment_instance_id,
      build_hash_table_for_broadcast_join: build_hash_table_for_broadcast_join.into(),
      per_node_scan_ranges,
      sender_id: sender_id.into(),
      runtime_filter_params: runtime_filter_params.into(),
      backend_num: backend_num.into(),
      per_node_shared_scans: per_node_shared_scans.into(),
      topn_filter_source_node_ids: topn_filter_source_node_ids.into(),
      topn_filter_descs: topn_filter_descs.into(),
    }
  }
}

impl TSerializable for TPipelineInstanceParams {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TPipelineInstanceParams> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<types::TUniqueId> = None;
    let mut f_2: Option<bool> = None;
    let mut f_3: Option<BTreeMap<types::TPlanNodeId, Vec<TScanRangeParams>>> = None;
    let mut f_4: Option<i32> = None;
    let mut f_5: Option<TRuntimeFilterParams> = None;
    let mut f_6: Option<i32> = None;
    let mut f_7: Option<BTreeMap<types::TPlanNodeId, bool>> = None;
    let mut f_8: Option<Vec<i32>> = None;
    let mut f_9: Option<Vec<plan_nodes::TTopnFilterDesc>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = types::TUniqueId::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<types::TPlanNodeId, Vec<TScanRangeParams>> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_27 = i_prot.read_i32()?;
            let list_ident = i_prot.read_list_begin()?;
            let mut map_val_28: Vec<TScanRangeParams> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_29 = TScanRangeParams::read_from_in_protocol(i_prot)?;
              map_val_28.push(list_elem_29);
            }
            i_prot.read_list_end()?;
            val.insert(map_key_27, map_val_28);
          }
          i_prot.read_map_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = TRuntimeFilterParams::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        7 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<types::TPlanNodeId, bool> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_30 = i_prot.read_i32()?;
            let map_val_31 = i_prot.read_bool()?;
            val.insert(map_key_30, map_val_31);
          }
          i_prot.read_map_end()?;
          f_7 = Some(val);
        },
        8 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_32 = i_prot.read_i32()?;
            val.push(list_elem_32);
          }
          i_prot.read_list_end()?;
          f_8 = Some(val);
        },
        9 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<plan_nodes::TTopnFilterDesc> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_33 = plan_nodes::TTopnFilterDesc::read_from_in_protocol(i_prot)?;
            val.push(list_elem_33);
          }
          i_prot.read_list_end()?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TPipelineInstanceParams.fragment_instance_id", &f_1)?;
    verify_required_field_exists("TPipelineInstanceParams.per_node_scan_ranges", &f_3)?;
    let ret = TPipelineInstanceParams {
      fragment_instance_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      build_hash_table_for_broadcast_join: f_2,
      per_node_scan_ranges: f_3.expect("auto-generated code should have checked for presence of required fields"),
      sender_id: f_4,
      runtime_filter_params: f_5,
      backend_num: f_6,
      per_node_shared_scans: f_7,
      topn_filter_source_node_ids: f_8,
      topn_filter_descs: f_9,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TPipelineInstanceParams");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("fragment_instance_id", TType::Struct, 1))?;
    self.fragment_instance_id.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.build_hash_table_for_broadcast_join {
      o_prot.write_field_begin(&TFieldIdentifier::new("build_hash_table_for_broadcast_join", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_begin(&TFieldIdentifier::new("per_node_scan_ranges", TType::Map, 3))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::I32, TType::List, self.per_node_scan_ranges.len() as i32))?;
    for (k, v) in &self.per_node_scan_ranges {
      o_prot.write_i32(*k)?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, v.len() as i32))?;
      for e in v {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
    }
    o_prot.write_map_end()?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.sender_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("sender_id", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.runtime_filter_params {
      o_prot.write_field_begin(&TFieldIdentifier::new("runtime_filter_params", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.backend_num {
      o_prot.write_field_begin(&TFieldIdentifier::new("backend_num", TType::I32, 6))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.per_node_shared_scans {
      o_prot.write_field_begin(&TFieldIdentifier::new("per_node_shared_scans", TType::Map, 7))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::I32, TType::Bool, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_i32(*k)?;
        o_prot.write_bool(*v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.topn_filter_source_node_ids {
      o_prot.write_field_begin(&TFieldIdentifier::new("topn_filter_source_node_ids", TType::List, 8))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I32, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i32(*e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.topn_filter_descs {
      o_prot.write_field_begin(&TFieldIdentifier::new("topn_filter_descs", TType::List, 9))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TPipelineFragmentParams
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TPipelineFragmentParams {
  pub protocol_version: PaloInternalServiceVersion,
  pub query_id: types::TUniqueId,
  pub fragment_id: Option<i32>,
  pub per_exch_num_senders: BTreeMap<types::TPlanNodeId, i32>,
  pub desc_tbl: Option<descriptors::TDescriptorTable>,
  pub resource_info: Option<types::TResourceInfo>,
  pub destinations: Option<Vec<data_sinks::TPlanFragmentDestination>>,
  pub num_senders: Option<i32>,
  pub send_query_statistics_with_every_batch: Option<bool>,
  pub coord: Option<types::TNetworkAddress>,
  pub query_globals: Option<TQueryGlobals>,
  pub query_options: Option<TQueryOptions>,
  pub import_label: Option<String>,
  pub db_name: Option<String>,
  pub load_job_id: Option<i64>,
  pub load_error_hub_info: Option<TLoadErrorHubInfo>,
  pub fragment_num_on_host: Option<i32>,
  pub backend_id: Option<i64>,
  pub need_wait_execution_trigger: Option<bool>,
  pub instances_sharing_hash_table: Option<Vec<types::TUniqueId>>,
  pub is_simplified_param: Option<bool>,
  pub global_dict: Option<TGlobalDict>,
  pub fragment: Option<planner::TPlanFragment>,
  pub local_params: Option<Vec<TPipelineInstanceParams>>,
  pub workload_groups: Option<Vec<TPipelineWorkloadGroup>>,
  pub txn_conf: Option<TTxnParams>,
  pub table_name: Option<String>,
  pub file_scan_params: Option<BTreeMap<types::TPlanNodeId, plan_nodes::TFileScanRangeParams>>,
  pub group_commit: Option<bool>,
  pub load_stream_per_node: Option<i32>,
  pub total_load_streams: Option<i32>,
  pub num_local_sink: Option<i32>,
  pub num_buckets: Option<i32>,
  pub bucket_seq_to_instance_idx: Option<BTreeMap<i32, i32>>,
  pub per_node_shared_scans: Option<BTreeMap<types::TPlanNodeId, bool>>,
  pub parallel_instances: Option<i32>,
  pub total_instances: Option<i32>,
  pub shuffle_idx_to_instance_idx: Option<BTreeMap<i32, i32>>,
  pub is_nereids: Option<bool>,
  pub wal_id: Option<i64>,
  pub content_length: Option<i64>,
  pub current_connect_fe: Option<types::TNetworkAddress>,
  pub topn_filter_source_node_ids: Option<Vec<i32>>,
  pub ai_resources: Option<BTreeMap<String, TAIResource>>,
  pub is_mow_table: Option<bool>,
}

impl TPipelineFragmentParams {
  pub fn new<F3, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15, F16, F17, F18, F19, F20, F21, F22, F23, F24, F26, F27, F28, F29, F30, F31, F32, F33, F34, F35, F36, F37, F38, F39, F40, F41, F42, F43, F44, F45, F1000>(protocol_version: PaloInternalServiceVersion, query_id: types::TUniqueId, fragment_id: F3, per_exch_num_senders: BTreeMap<types::TPlanNodeId, i32>, desc_tbl: F5, resource_info: F6, destinations: F7, num_senders: F8, send_query_statistics_with_every_batch: F9, coord: F10, query_globals: F11, query_options: F12, import_label: F13, db_name: F14, load_job_id: F15, load_error_hub_info: F16, fragment_num_on_host: F17, backend_id: F18, need_wait_execution_trigger: F19, instances_sharing_hash_table: F20, is_simplified_param: F21, global_dict: F22, fragment: F23, local_params: F24, workload_groups: F26, txn_conf: F27, table_name: F28, file_scan_params: F29, group_commit: F30, load_stream_per_node: F31, total_load_streams: F32, num_local_sink: F33, num_buckets: F34, bucket_seq_to_instance_idx: F35, per_node_shared_scans: F36, parallel_instances: F37, total_instances: F38, shuffle_idx_to_instance_idx: F39, is_nereids: F40, wal_id: F41, content_length: F42, current_connect_fe: F43, topn_filter_source_node_ids: F44, ai_resources: F45, is_mow_table: F1000) -> TPipelineFragmentParams where F3: Into<Option<i32>>, F5: Into<Option<descriptors::TDescriptorTable>>, F6: Into<Option<types::TResourceInfo>>, F7: Into<Option<Vec<data_sinks::TPlanFragmentDestination>>>, F8: Into<Option<i32>>, F9: Into<Option<bool>>, F10: Into<Option<types::TNetworkAddress>>, F11: Into<Option<TQueryGlobals>>, F12: Into<Option<TQueryOptions>>, F13: Into<Option<String>>, F14: Into<Option<String>>, F15: Into<Option<i64>>, F16: Into<Option<TLoadErrorHubInfo>>, F17: Into<Option<i32>>, F18: Into<Option<i64>>, F19: Into<Option<bool>>, F20: Into<Option<Vec<types::TUniqueId>>>, F21: Into<Option<bool>>, F22: Into<Option<TGlobalDict>>, F23: Into<Option<planner::TPlanFragment>>, F24: Into<Option<Vec<TPipelineInstanceParams>>>, F26: Into<Option<Vec<TPipelineWorkloadGroup>>>, F27: Into<Option<TTxnParams>>, F28: Into<Option<String>>, F29: Into<Option<BTreeMap<types::TPlanNodeId, plan_nodes::TFileScanRangeParams>>>, F30: Into<Option<bool>>, F31: Into<Option<i32>>, F32: Into<Option<i32>>, F33: Into<Option<i32>>, F34: Into<Option<i32>>, F35: Into<Option<BTreeMap<i32, i32>>>, F36: Into<Option<BTreeMap<types::TPlanNodeId, bool>>>, F37: Into<Option<i32>>, F38: Into<Option<i32>>, F39: Into<Option<BTreeMap<i32, i32>>>, F40: Into<Option<bool>>, F41: Into<Option<i64>>, F42: Into<Option<i64>>, F43: Into<Option<types::TNetworkAddress>>, F44: Into<Option<Vec<i32>>>, F45: Into<Option<BTreeMap<String, TAIResource>>>, F1000: Into<Option<bool>> {
    TPipelineFragmentParams {
      protocol_version,
      query_id,
      fragment_id: fragment_id.into(),
      per_exch_num_senders,
      desc_tbl: desc_tbl.into(),
      resource_info: resource_info.into(),
      destinations: destinations.into(),
      num_senders: num_senders.into(),
      send_query_statistics_with_every_batch: send_query_statistics_with_every_batch.into(),
      coord: coord.into(),
      query_globals: query_globals.into(),
      query_options: query_options.into(),
      import_label: import_label.into(),
      db_name: db_name.into(),
      load_job_id: load_job_id.into(),
      load_error_hub_info: load_error_hub_info.into(),
      fragment_num_on_host: fragment_num_on_host.into(),
      backend_id: backend_id.into(),
      need_wait_execution_trigger: need_wait_execution_trigger.into(),
      instances_sharing_hash_table: instances_sharing_hash_table.into(),
      is_simplified_param: is_simplified_param.into(),
      global_dict: global_dict.into(),
      fragment: fragment.into(),
      local_params: local_params.into(),
      workload_groups: workload_groups.into(),
      txn_conf: txn_conf.into(),
      table_name: table_name.into(),
      file_scan_params: file_scan_params.into(),
      group_commit: group_commit.into(),
      load_stream_per_node: load_stream_per_node.into(),
      total_load_streams: total_load_streams.into(),
      num_local_sink: num_local_sink.into(),
      num_buckets: num_buckets.into(),
      bucket_seq_to_instance_idx: bucket_seq_to_instance_idx.into(),
      per_node_shared_scans: per_node_shared_scans.into(),
      parallel_instances: parallel_instances.into(),
      total_instances: total_instances.into(),
      shuffle_idx_to_instance_idx: shuffle_idx_to_instance_idx.into(),
      is_nereids: is_nereids.into(),
      wal_id: wal_id.into(),
      content_length: content_length.into(),
      current_connect_fe: current_connect_fe.into(),
      topn_filter_source_node_ids: topn_filter_source_node_ids.into(),
      ai_resources: ai_resources.into(),
      is_mow_table: is_mow_table.into(),
    }
  }
}

impl TSerializable for TPipelineFragmentParams {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TPipelineFragmentParams> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<PaloInternalServiceVersion> = None;
    let mut f_2: Option<types::TUniqueId> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<BTreeMap<types::TPlanNodeId, i32>> = None;
    let mut f_5: Option<descriptors::TDescriptorTable> = None;
    let mut f_6: Option<types::TResourceInfo> = None;
    let mut f_7: Option<Vec<data_sinks::TPlanFragmentDestination>> = Some(Vec::new());
    let mut f_8: Option<i32> = None;
    let mut f_9: Option<bool> = None;
    let mut f_10: Option<types::TNetworkAddress> = None;
    let mut f_11: Option<TQueryGlobals> = None;
    let mut f_12: Option<TQueryOptions> = None;
    let mut f_13: Option<String> = None;
    let mut f_14: Option<String> = None;
    let mut f_15: Option<i64> = None;
    let mut f_16: Option<TLoadErrorHubInfo> = None;
    let mut f_17: Option<i32> = None;
    let mut f_18: Option<i64> = None;
    let mut f_19: Option<bool> = None;
    let mut f_20: Option<Vec<types::TUniqueId>> = None;
    let mut f_21: Option<bool> = None;
    let mut f_22: Option<TGlobalDict> = None;
    let mut f_23: Option<planner::TPlanFragment> = None;
    let mut f_24: Option<Vec<TPipelineInstanceParams>> = Some(Vec::new());
    let mut f_26: Option<Vec<TPipelineWorkloadGroup>> = None;
    let mut f_27: Option<TTxnParams> = None;
    let mut f_28: Option<String> = None;
    let mut f_29: Option<BTreeMap<types::TPlanNodeId, plan_nodes::TFileScanRangeParams>> = None;
    let mut f_30: Option<bool> = None;
    let mut f_31: Option<i32> = None;
    let mut f_32: Option<i32> = None;
    let mut f_33: Option<i32> = None;
    let mut f_34: Option<i32> = None;
    let mut f_35: Option<BTreeMap<i32, i32>> = None;
    let mut f_36: Option<BTreeMap<types::TPlanNodeId, bool>> = None;
    let mut f_37: Option<i32> = None;
    let mut f_38: Option<i32> = None;
    let mut f_39: Option<BTreeMap<i32, i32>> = None;
    let mut f_40: Option<bool> = None;
    let mut f_41: Option<i64> = None;
    let mut f_42: Option<i64> = None;
    let mut f_43: Option<types::TNetworkAddress> = None;
    let mut f_44: Option<Vec<i32>> = None;
    let mut f_45: Option<BTreeMap<String, TAIResource>> = None;
    let mut f_1000: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = PaloInternalServiceVersion::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = types::TUniqueId::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<types::TPlanNodeId, i32> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_34 = i_prot.read_i32()?;
            let map_val_35 = i_prot.read_i32()?;
            val.insert(map_key_34, map_val_35);
          }
          i_prot.read_map_end()?;
          f_4 = Some(val);
        },
        5 => {
          let val = descriptors::TDescriptorTable::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = types::TResourceInfo::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<data_sinks::TPlanFragmentDestination> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_36 = data_sinks::TPlanFragmentDestination::read_from_in_protocol(i_prot)?;
            val.push(list_elem_36);
          }
          i_prot.read_list_end()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i32()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_bool()?;
          f_9 = Some(val);
        },
        10 => {
          let val = types::TNetworkAddress::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        11 => {
          let val = TQueryGlobals::read_from_in_protocol(i_prot)?;
          f_11 = Some(val);
        },
        12 => {
          let val = TQueryOptions::read_from_in_protocol(i_prot)?;
          f_12 = Some(val);
        },
        13 => {
          let val = i_prot.read_string()?;
          f_13 = Some(val);
        },
        14 => {
          let val = i_prot.read_string()?;
          f_14 = Some(val);
        },
        15 => {
          let val = i_prot.read_i64()?;
          f_15 = Some(val);
        },
        16 => {
          let val = TLoadErrorHubInfo::read_from_in_protocol(i_prot)?;
          f_16 = Some(val);
        },
        17 => {
          let val = i_prot.read_i32()?;
          f_17 = Some(val);
        },
        18 => {
          let val = i_prot.read_i64()?;
          f_18 = Some(val);
        },
        19 => {
          let val = i_prot.read_bool()?;
          f_19 = Some(val);
        },
        20 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::TUniqueId> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_37 = types::TUniqueId::read_from_in_protocol(i_prot)?;
            val.push(list_elem_37);
          }
          i_prot.read_list_end()?;
          f_20 = Some(val);
        },
        21 => {
          let val = i_prot.read_bool()?;
          f_21 = Some(val);
        },
        22 => {
          let val = TGlobalDict::read_from_in_protocol(i_prot)?;
          f_22 = Some(val);
        },
        23 => {
          let val = planner::TPlanFragment::read_from_in_protocol(i_prot)?;
          f_23 = Some(val);
        },
        24 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TPipelineInstanceParams> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_38 = TPipelineInstanceParams::read_from_in_protocol(i_prot)?;
            val.push(list_elem_38);
          }
          i_prot.read_list_end()?;
          f_24 = Some(val);
        },
        26 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TPipelineWorkloadGroup> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_39 = TPipelineWorkloadGroup::read_from_in_protocol(i_prot)?;
            val.push(list_elem_39);
          }
          i_prot.read_list_end()?;
          f_26 = Some(val);
        },
        27 => {
          let val = TTxnParams::read_from_in_protocol(i_prot)?;
          f_27 = Some(val);
        },
        28 => {
          let val = i_prot.read_string()?;
          f_28 = Some(val);
        },
        29 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<types::TPlanNodeId, plan_nodes::TFileScanRangeParams> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_40 = i_prot.read_i32()?;
            let map_val_41 = plan_nodes::TFileScanRangeParams::read_from_in_protocol(i_prot)?;
            val.insert(map_key_40, map_val_41);
          }
          i_prot.read_map_end()?;
          f_29 = Some(val);
        },
        30 => {
          let val = i_prot.read_bool()?;
          f_30 = Some(val);
        },
        31 => {
          let val = i_prot.read_i32()?;
          f_31 = Some(val);
        },
        32 => {
          let val = i_prot.read_i32()?;
          f_32 = Some(val);
        },
        33 => {
          let val = i_prot.read_i32()?;
          f_33 = Some(val);
        },
        34 => {
          let val = i_prot.read_i32()?;
          f_34 = Some(val);
        },
        35 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<i32, i32> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_42 = i_prot.read_i32()?;
            let map_val_43 = i_prot.read_i32()?;
            val.insert(map_key_42, map_val_43);
          }
          i_prot.read_map_end()?;
          f_35 = Some(val);
        },
        36 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<types::TPlanNodeId, bool> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_44 = i_prot.read_i32()?;
            let map_val_45 = i_prot.read_bool()?;
            val.insert(map_key_44, map_val_45);
          }
          i_prot.read_map_end()?;
          f_36 = Some(val);
        },
        37 => {
          let val = i_prot.read_i32()?;
          f_37 = Some(val);
        },
        38 => {
          let val = i_prot.read_i32()?;
          f_38 = Some(val);
        },
        39 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<i32, i32> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_46 = i_prot.read_i32()?;
            let map_val_47 = i_prot.read_i32()?;
            val.insert(map_key_46, map_val_47);
          }
          i_prot.read_map_end()?;
          f_39 = Some(val);
        },
        40 => {
          let val = i_prot.read_bool()?;
          f_40 = Some(val);
        },
        41 => {
          let val = i_prot.read_i64()?;
          f_41 = Some(val);
        },
        42 => {
          let val = i_prot.read_i64()?;
          f_42 = Some(val);
        },
        43 => {
          let val = types::TNetworkAddress::read_from_in_protocol(i_prot)?;
          f_43 = Some(val);
        },
        44 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_48 = i_prot.read_i32()?;
            val.push(list_elem_48);
          }
          i_prot.read_list_end()?;
          f_44 = Some(val);
        },
        45 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, TAIResource> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_49 = i_prot.read_string()?;
            let map_val_50 = TAIResource::read_from_in_protocol(i_prot)?;
            val.insert(map_key_49, map_val_50);
          }
          i_prot.read_map_end()?;
          f_45 = Some(val);
        },
        1000 => {
          let val = i_prot.read_bool()?;
          f_1000 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TPipelineFragmentParams.protocol_version", &f_1)?;
    verify_required_field_exists("TPipelineFragmentParams.query_id", &f_2)?;
    verify_required_field_exists("TPipelineFragmentParams.per_exch_num_senders", &f_4)?;
    let ret = TPipelineFragmentParams {
      protocol_version: f_1.expect("auto-generated code should have checked for presence of required fields"),
      query_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      fragment_id: f_3,
      per_exch_num_senders: f_4.expect("auto-generated code should have checked for presence of required fields"),
      desc_tbl: f_5,
      resource_info: f_6,
      destinations: f_7,
      num_senders: f_8,
      send_query_statistics_with_every_batch: f_9,
      coord: f_10,
      query_globals: f_11,
      query_options: f_12,
      import_label: f_13,
      db_name: f_14,
      load_job_id: f_15,
      load_error_hub_info: f_16,
      fragment_num_on_host: f_17,
      backend_id: f_18,
      need_wait_execution_trigger: f_19,
      instances_sharing_hash_table: f_20,
      is_simplified_param: f_21,
      global_dict: f_22,
      fragment: f_23,
      local_params: f_24,
      workload_groups: f_26,
      txn_conf: f_27,
      table_name: f_28,
      file_scan_params: f_29,
      group_commit: f_30,
      load_stream_per_node: f_31,
      total_load_streams: f_32,
      num_local_sink: f_33,
      num_buckets: f_34,
      bucket_seq_to_instance_idx: f_35,
      per_node_shared_scans: f_36,
      parallel_instances: f_37,
      total_instances: f_38,
      shuffle_idx_to_instance_idx: f_39,
      is_nereids: f_40,
      wal_id: f_41,
      content_length: f_42,
      current_connect_fe: f_43,
      topn_filter_source_node_ids: f_44,
      ai_resources: f_45,
      is_mow_table: f_1000,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TPipelineFragmentParams");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("protocol_version", TType::I32, 1))?;
    self.protocol_version.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("query_id", TType::Struct, 2))?;
    self.query_id.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.fragment_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("fragment_id", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_begin(&TFieldIdentifier::new("per_exch_num_senders", TType::Map, 4))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::I32, TType::I32, self.per_exch_num_senders.len() as i32))?;
    for (k, v) in &self.per_exch_num_senders {
      o_prot.write_i32(*k)?;
      o_prot.write_i32(*v)?;
    }
    o_prot.write_map_end()?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.desc_tbl {
      o_prot.write_field_begin(&TFieldIdentifier::new("desc_tbl", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.resource_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("resource_info", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.destinations {
      o_prot.write_field_begin(&TFieldIdentifier::new("destinations", TType::List, 7))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.num_senders {
      o_prot.write_field_begin(&TFieldIdentifier::new("num_senders", TType::I32, 8))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.send_query_statistics_with_every_batch {
      o_prot.write_field_begin(&TFieldIdentifier::new("send_query_statistics_with_every_batch", TType::Bool, 9))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.coord {
      o_prot.write_field_begin(&TFieldIdentifier::new("coord", TType::Struct, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.query_globals {
      o_prot.write_field_begin(&TFieldIdentifier::new("query_globals", TType::Struct, 11))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.query_options {
      o_prot.write_field_begin(&TFieldIdentifier::new("query_options", TType::Struct, 12))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.import_label {
      o_prot.write_field_begin(&TFieldIdentifier::new("import_label", TType::String, 13))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.db_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("db_name", TType::String, 14))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.load_job_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("load_job_id", TType::I64, 15))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.load_error_hub_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("load_error_hub_info", TType::Struct, 16))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.fragment_num_on_host {
      o_prot.write_field_begin(&TFieldIdentifier::new("fragment_num_on_host", TType::I32, 17))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.backend_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("backend_id", TType::I64, 18))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.need_wait_execution_trigger {
      o_prot.write_field_begin(&TFieldIdentifier::new("need_wait_execution_trigger", TType::Bool, 19))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.instances_sharing_hash_table {
      o_prot.write_field_begin(&TFieldIdentifier::new("instances_sharing_hash_table", TType::List, 20))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_simplified_param {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_simplified_param", TType::Bool, 21))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.global_dict {
      o_prot.write_field_begin(&TFieldIdentifier::new("global_dict", TType::Struct, 22))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.fragment {
      o_prot.write_field_begin(&TFieldIdentifier::new("fragment", TType::Struct, 23))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.local_params {
      o_prot.write_field_begin(&TFieldIdentifier::new("local_params", TType::List, 24))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workload_groups {
      o_prot.write_field_begin(&TFieldIdentifier::new("workload_groups", TType::List, 26))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.txn_conf {
      o_prot.write_field_begin(&TFieldIdentifier::new("txn_conf", TType::Struct, 27))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.table_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_name", TType::String, 28))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.file_scan_params {
      o_prot.write_field_begin(&TFieldIdentifier::new("file_scan_params", TType::Map, 29))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::I32, TType::Struct, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_i32(*k)?;
        v.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.group_commit {
      o_prot.write_field_begin(&TFieldIdentifier::new("group_commit", TType::Bool, 30))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.load_stream_per_node {
      o_prot.write_field_begin(&TFieldIdentifier::new("load_stream_per_node", TType::I32, 31))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.total_load_streams {
      o_prot.write_field_begin(&TFieldIdentifier::new("total_load_streams", TType::I32, 32))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.num_local_sink {
      o_prot.write_field_begin(&TFieldIdentifier::new("num_local_sink", TType::I32, 33))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.num_buckets {
      o_prot.write_field_begin(&TFieldIdentifier::new("num_buckets", TType::I32, 34))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.bucket_seq_to_instance_idx {
      o_prot.write_field_begin(&TFieldIdentifier::new("bucket_seq_to_instance_idx", TType::Map, 35))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::I32, TType::I32, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_i32(*k)?;
        o_prot.write_i32(*v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.per_node_shared_scans {
      o_prot.write_field_begin(&TFieldIdentifier::new("per_node_shared_scans", TType::Map, 36))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::I32, TType::Bool, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_i32(*k)?;
        o_prot.write_bool(*v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.parallel_instances {
      o_prot.write_field_begin(&TFieldIdentifier::new("parallel_instances", TType::I32, 37))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.total_instances {
      o_prot.write_field_begin(&TFieldIdentifier::new("total_instances", TType::I32, 38))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.shuffle_idx_to_instance_idx {
      o_prot.write_field_begin(&TFieldIdentifier::new("shuffle_idx_to_instance_idx", TType::Map, 39))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::I32, TType::I32, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_i32(*k)?;
        o_prot.write_i32(*v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_nereids {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_nereids", TType::Bool, 40))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.wal_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("wal_id", TType::I64, 41))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.content_length {
      o_prot.write_field_begin(&TFieldIdentifier::new("content_length", TType::I64, 42))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.current_connect_fe {
      o_prot.write_field_begin(&TFieldIdentifier::new("current_connect_fe", TType::Struct, 43))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.topn_filter_source_node_ids {
      o_prot.write_field_begin(&TFieldIdentifier::new("topn_filter_source_node_ids", TType::List, 44))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I32, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i32(*e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.ai_resources {
      o_prot.write_field_begin(&TFieldIdentifier::new("ai_resources", TType::Map, 45))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Struct, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        v.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_mow_table {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_mow_table", TType::Bool, 1000))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TRuntimeFilterInfo
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TRuntimeFilterInfo {
  pub runtime_filter_params: Option<TRuntimeFilterParams>,
  pub topn_filter_descs: Option<Vec<plan_nodes::TTopnFilterDesc>>,
}

impl TRuntimeFilterInfo {
  pub fn new<F1, F2>(runtime_filter_params: F1, topn_filter_descs: F2) -> TRuntimeFilterInfo where F1: Into<Option<TRuntimeFilterParams>>, F2: Into<Option<Vec<plan_nodes::TTopnFilterDesc>>> {
    TRuntimeFilterInfo {
      runtime_filter_params: runtime_filter_params.into(),
      topn_filter_descs: topn_filter_descs.into(),
    }
  }
}

impl TSerializable for TRuntimeFilterInfo {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TRuntimeFilterInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TRuntimeFilterParams> = None;
    let mut f_2: Option<Vec<plan_nodes::TTopnFilterDesc>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TRuntimeFilterParams::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<plan_nodes::TTopnFilterDesc> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_51 = plan_nodes::TTopnFilterDesc::read_from_in_protocol(i_prot)?;
            val.push(list_elem_51);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TRuntimeFilterInfo {
      runtime_filter_params: f_1,
      topn_filter_descs: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TRuntimeFilterInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.runtime_filter_params {
      o_prot.write_field_begin(&TFieldIdentifier::new("runtime_filter_params", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.topn_filter_descs {
      o_prot.write_field_begin(&TFieldIdentifier::new("topn_filter_descs", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TPipelineFragmentParamsList
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TPipelineFragmentParamsList {
  pub params_list: Option<Vec<TPipelineFragmentParams>>,
  pub desc_tbl: Option<descriptors::TDescriptorTable>,
  pub file_scan_params: Option<BTreeMap<types::TPlanNodeId, plan_nodes::TFileScanRangeParams>>,
  pub coord: Option<types::TNetworkAddress>,
  pub query_globals: Option<TQueryGlobals>,
  pub resource_info: Option<types::TResourceInfo>,
  pub fragment_num_on_host: Option<i32>,
  pub query_options: Option<TQueryOptions>,
  pub is_nereids: Option<bool>,
  pub workload_groups: Option<Vec<TPipelineWorkloadGroup>>,
  pub query_id: Option<types::TUniqueId>,
  pub topn_filter_source_node_ids: Option<Vec<i32>>,
  pub runtime_filter_merge_addr: Option<types::TNetworkAddress>,
  pub runtime_filter_info: Option<TRuntimeFilterInfo>,
}

impl TPipelineFragmentParamsList {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14>(params_list: F1, desc_tbl: F2, file_scan_params: F3, coord: F4, query_globals: F5, resource_info: F6, fragment_num_on_host: F7, query_options: F8, is_nereids: F9, workload_groups: F10, query_id: F11, topn_filter_source_node_ids: F12, runtime_filter_merge_addr: F13, runtime_filter_info: F14) -> TPipelineFragmentParamsList where F1: Into<Option<Vec<TPipelineFragmentParams>>>, F2: Into<Option<descriptors::TDescriptorTable>>, F3: Into<Option<BTreeMap<types::TPlanNodeId, plan_nodes::TFileScanRangeParams>>>, F4: Into<Option<types::TNetworkAddress>>, F5: Into<Option<TQueryGlobals>>, F6: Into<Option<types::TResourceInfo>>, F7: Into<Option<i32>>, F8: Into<Option<TQueryOptions>>, F9: Into<Option<bool>>, F10: Into<Option<Vec<TPipelineWorkloadGroup>>>, F11: Into<Option<types::TUniqueId>>, F12: Into<Option<Vec<i32>>>, F13: Into<Option<types::TNetworkAddress>>, F14: Into<Option<TRuntimeFilterInfo>> {
    TPipelineFragmentParamsList {
      params_list: params_list.into(),
      desc_tbl: desc_tbl.into(),
      file_scan_params: file_scan_params.into(),
      coord: coord.into(),
      query_globals: query_globals.into(),
      resource_info: resource_info.into(),
      fragment_num_on_host: fragment_num_on_host.into(),
      query_options: query_options.into(),
      is_nereids: is_nereids.into(),
      workload_groups: workload_groups.into(),
      query_id: query_id.into(),
      topn_filter_source_node_ids: topn_filter_source_node_ids.into(),
      runtime_filter_merge_addr: runtime_filter_merge_addr.into(),
      runtime_filter_info: runtime_filter_info.into(),
    }
  }
}

impl TSerializable for TPipelineFragmentParamsList {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TPipelineFragmentParamsList> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<TPipelineFragmentParams>> = None;
    let mut f_2: Option<descriptors::TDescriptorTable> = None;
    let mut f_3: Option<BTreeMap<types::TPlanNodeId, plan_nodes::TFileScanRangeParams>> = None;
    let mut f_4: Option<types::TNetworkAddress> = None;
    let mut f_5: Option<TQueryGlobals> = None;
    let mut f_6: Option<types::TResourceInfo> = None;
    let mut f_7: Option<i32> = None;
    let mut f_8: Option<TQueryOptions> = None;
    let mut f_9: Option<bool> = None;
    let mut f_10: Option<Vec<TPipelineWorkloadGroup>> = None;
    let mut f_11: Option<types::TUniqueId> = None;
    let mut f_12: Option<Vec<i32>> = None;
    let mut f_13: Option<types::TNetworkAddress> = None;
    let mut f_14: Option<TRuntimeFilterInfo> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TPipelineFragmentParams> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_52 = TPipelineFragmentParams::read_from_in_protocol(i_prot)?;
            val.push(list_elem_52);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = descriptors::TDescriptorTable::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<types::TPlanNodeId, plan_nodes::TFileScanRangeParams> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_53 = i_prot.read_i32()?;
            let map_val_54 = plan_nodes::TFileScanRangeParams::read_from_in_protocol(i_prot)?;
            val.insert(map_key_53, map_val_54);
          }
          i_prot.read_map_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = types::TNetworkAddress::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = TQueryGlobals::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = types::TResourceInfo::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i32()?;
          f_7 = Some(val);
        },
        8 => {
          let val = TQueryOptions::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_bool()?;
          f_9 = Some(val);
        },
        10 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TPipelineWorkloadGroup> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_55 = TPipelineWorkloadGroup::read_from_in_protocol(i_prot)?;
            val.push(list_elem_55);
          }
          i_prot.read_list_end()?;
          f_10 = Some(val);
        },
        11 => {
          let val = types::TUniqueId::read_from_in_protocol(i_prot)?;
          f_11 = Some(val);
        },
        12 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_56 = i_prot.read_i32()?;
            val.push(list_elem_56);
          }
          i_prot.read_list_end()?;
          f_12 = Some(val);
        },
        13 => {
          let val = types::TNetworkAddress::read_from_in_protocol(i_prot)?;
          f_13 = Some(val);
        },
        14 => {
          let val = TRuntimeFilterInfo::read_from_in_protocol(i_prot)?;
          f_14 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TPipelineFragmentParamsList {
      params_list: f_1,
      desc_tbl: f_2,
      file_scan_params: f_3,
      coord: f_4,
      query_globals: f_5,
      resource_info: f_6,
      fragment_num_on_host: f_7,
      query_options: f_8,
      is_nereids: f_9,
      workload_groups: f_10,
      query_id: f_11,
      topn_filter_source_node_ids: f_12,
      runtime_filter_merge_addr: f_13,
      runtime_filter_info: f_14,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TPipelineFragmentParamsList");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.params_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("params_list", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.desc_tbl {
      o_prot.write_field_begin(&TFieldIdentifier::new("desc_tbl", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.file_scan_params {
      o_prot.write_field_begin(&TFieldIdentifier::new("file_scan_params", TType::Map, 3))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::I32, TType::Struct, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_i32(*k)?;
        v.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.coord {
      o_prot.write_field_begin(&TFieldIdentifier::new("coord", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.query_globals {
      o_prot.write_field_begin(&TFieldIdentifier::new("query_globals", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.resource_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("resource_info", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.fragment_num_on_host {
      o_prot.write_field_begin(&TFieldIdentifier::new("fragment_num_on_host", TType::I32, 7))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.query_options {
      o_prot.write_field_begin(&TFieldIdentifier::new("query_options", TType::Struct, 8))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_nereids {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_nereids", TType::Bool, 9))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workload_groups {
      o_prot.write_field_begin(&TFieldIdentifier::new("workload_groups", TType::List, 10))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.query_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("query_id", TType::Struct, 11))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.topn_filter_source_node_ids {
      o_prot.write_field_begin(&TFieldIdentifier::new("topn_filter_source_node_ids", TType::List, 12))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I32, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i32(*e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.runtime_filter_merge_addr {
      o_prot.write_field_begin(&TFieldIdentifier::new("runtime_filter_merge_addr", TType::Struct, 13))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.runtime_filter_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("runtime_filter_info", TType::Struct, 14))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

pub const NUM_NODES_ALL: i32 = 0;

pub const NUM_NODES_ALL_RACKS: i32 = -1;

pub const INVALID_PLAN_NODE_ID: i32 = -1;

pub const DEFAULT_PARTITION_ID: i64 = -1;

