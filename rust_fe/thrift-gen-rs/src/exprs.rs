// Autogenerated by Thrift Compiler (0.19.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(dead_code)]
#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![allow(clippy::too_many_arguments, clippy::type_complexity, clippy::vec_box, clippy::wrong_self_convention)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;

use thrift::OrderedFloat;
use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSerializable, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

use crate::opcodes;
use crate::types;

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TExprNodeType(pub i32);

impl TExprNodeType {
  pub const AGG_EXPR: TExprNodeType = TExprNodeType(0);
  pub const ARITHMETIC_EXPR: TExprNodeType = TExprNodeType(1);
  pub const BINARY_PRED: TExprNodeType = TExprNodeType(2);
  pub const BOOL_LITERAL: TExprNodeType = TExprNodeType(3);
  pub const CASE_EXPR: TExprNodeType = TExprNodeType(4);
  pub const CAST_EXPR: TExprNodeType = TExprNodeType(5);
  pub const COMPOUND_PRED: TExprNodeType = TExprNodeType(6);
  pub const DATE_LITERAL: TExprNodeType = TExprNodeType(7);
  pub const FLOAT_LITERAL: TExprNodeType = TExprNodeType(8);
  pub const INT_LITERAL: TExprNodeType = TExprNodeType(9);
  pub const DECIMAL_LITERAL: TExprNodeType = TExprNodeType(10);
  pub const IN_PRED: TExprNodeType = TExprNodeType(11);
  pub const IS_NULL_PRED: TExprNodeType = TExprNodeType(12);
  pub const LIKE_PRED: TExprNodeType = TExprNodeType(13);
  pub const LITERAL_PRED: TExprNodeType = TExprNodeType(14);
  pub const NULL_LITERAL: TExprNodeType = TExprNodeType(15);
  pub const SLOT_REF: TExprNodeType = TExprNodeType(16);
  pub const STRING_LITERAL: TExprNodeType = TExprNodeType(17);
  pub const TUPLE_IS_NULL_PRED: TExprNodeType = TExprNodeType(18);
  pub const INFO_FUNC: TExprNodeType = TExprNodeType(19);
  pub const FUNCTION_CALL: TExprNodeType = TExprNodeType(20);
  pub const ARRAY_LITERAL: TExprNodeType = TExprNodeType(21);
  pub const COMPUTE_FUNCTION_CALL: TExprNodeType = TExprNodeType(22);
  pub const LARGE_INT_LITERAL: TExprNodeType = TExprNodeType(23);
  pub const BLOOM_PRED: TExprNodeType = TExprNodeType(24);
  pub const JSON_LITERAL: TExprNodeType = TExprNodeType(25);
  pub const BITMAP_PRED: TExprNodeType = TExprNodeType(26);
  pub const MATCH_PRED: TExprNodeType = TExprNodeType(27);
  pub const MAP_LITERAL: TExprNodeType = TExprNodeType(28);
  pub const STRUCT_LITERAL: TExprNodeType = TExprNodeType(29);
  pub const SCHEMA_CHANGE_EXPR: TExprNodeType = TExprNodeType(30);
  pub const LAMBDA_FUNCTION_EXPR: TExprNodeType = TExprNodeType(31);
  pub const LAMBDA_FUNCTION_CALL_EXPR: TExprNodeType = TExprNodeType(32);
  pub const COLUMN_REF: TExprNodeType = TExprNodeType(33);
  pub const IPV4_LITERAL: TExprNodeType = TExprNodeType(34);
  pub const IPV6_LITERAL: TExprNodeType = TExprNodeType(35);
  pub const NULL_AWARE_IN_PRED: TExprNodeType = TExprNodeType(36);
  pub const NULL_AWARE_BINARY_PRED: TExprNodeType = TExprNodeType(37);
  pub const TIMEV2_LITERAL: TExprNodeType = TExprNodeType(38);
  pub const VIRTUAL_SLOT_REF: TExprNodeType = TExprNodeType(39);
  pub const VARBINARY_LITERAL: TExprNodeType = TExprNodeType(40);
  pub const TRY_CAST_EXPR: TExprNodeType = TExprNodeType(41);
  pub const SEARCH_EXPR: TExprNodeType = TExprNodeType(42);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::AGG_EXPR,
    Self::ARITHMETIC_EXPR,
    Self::BINARY_PRED,
    Self::BOOL_LITERAL,
    Self::CASE_EXPR,
    Self::CAST_EXPR,
    Self::COMPOUND_PRED,
    Self::DATE_LITERAL,
    Self::FLOAT_LITERAL,
    Self::INT_LITERAL,
    Self::DECIMAL_LITERAL,
    Self::IN_PRED,
    Self::IS_NULL_PRED,
    Self::LIKE_PRED,
    Self::LITERAL_PRED,
    Self::NULL_LITERAL,
    Self::SLOT_REF,
    Self::STRING_LITERAL,
    Self::TUPLE_IS_NULL_PRED,
    Self::INFO_FUNC,
    Self::FUNCTION_CALL,
    Self::ARRAY_LITERAL,
    Self::COMPUTE_FUNCTION_CALL,
    Self::LARGE_INT_LITERAL,
    Self::BLOOM_PRED,
    Self::JSON_LITERAL,
    Self::BITMAP_PRED,
    Self::MATCH_PRED,
    Self::MAP_LITERAL,
    Self::STRUCT_LITERAL,
    Self::SCHEMA_CHANGE_EXPR,
    Self::LAMBDA_FUNCTION_EXPR,
    Self::LAMBDA_FUNCTION_CALL_EXPR,
    Self::COLUMN_REF,
    Self::IPV4_LITERAL,
    Self::IPV6_LITERAL,
    Self::NULL_AWARE_IN_PRED,
    Self::NULL_AWARE_BINARY_PRED,
    Self::TIMEV2_LITERAL,
    Self::VIRTUAL_SLOT_REF,
    Self::VARBINARY_LITERAL,
    Self::TRY_CAST_EXPR,
    Self::SEARCH_EXPR,
  ];
}

impl TSerializable for TExprNodeType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TExprNodeType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TExprNodeType::from(enum_value))
  }
}

impl From<i32> for TExprNodeType {
  fn from(i: i32) -> Self {
    match i {
      0 => TExprNodeType::AGG_EXPR,
      1 => TExprNodeType::ARITHMETIC_EXPR,
      2 => TExprNodeType::BINARY_PRED,
      3 => TExprNodeType::BOOL_LITERAL,
      4 => TExprNodeType::CASE_EXPR,
      5 => TExprNodeType::CAST_EXPR,
      6 => TExprNodeType::COMPOUND_PRED,
      7 => TExprNodeType::DATE_LITERAL,
      8 => TExprNodeType::FLOAT_LITERAL,
      9 => TExprNodeType::INT_LITERAL,
      10 => TExprNodeType::DECIMAL_LITERAL,
      11 => TExprNodeType::IN_PRED,
      12 => TExprNodeType::IS_NULL_PRED,
      13 => TExprNodeType::LIKE_PRED,
      14 => TExprNodeType::LITERAL_PRED,
      15 => TExprNodeType::NULL_LITERAL,
      16 => TExprNodeType::SLOT_REF,
      17 => TExprNodeType::STRING_LITERAL,
      18 => TExprNodeType::TUPLE_IS_NULL_PRED,
      19 => TExprNodeType::INFO_FUNC,
      20 => TExprNodeType::FUNCTION_CALL,
      21 => TExprNodeType::ARRAY_LITERAL,
      22 => TExprNodeType::COMPUTE_FUNCTION_CALL,
      23 => TExprNodeType::LARGE_INT_LITERAL,
      24 => TExprNodeType::BLOOM_PRED,
      25 => TExprNodeType::JSON_LITERAL,
      26 => TExprNodeType::BITMAP_PRED,
      27 => TExprNodeType::MATCH_PRED,
      28 => TExprNodeType::MAP_LITERAL,
      29 => TExprNodeType::STRUCT_LITERAL,
      30 => TExprNodeType::SCHEMA_CHANGE_EXPR,
      31 => TExprNodeType::LAMBDA_FUNCTION_EXPR,
      32 => TExprNodeType::LAMBDA_FUNCTION_CALL_EXPR,
      33 => TExprNodeType::COLUMN_REF,
      34 => TExprNodeType::IPV4_LITERAL,
      35 => TExprNodeType::IPV6_LITERAL,
      36 => TExprNodeType::NULL_AWARE_IN_PRED,
      37 => TExprNodeType::NULL_AWARE_BINARY_PRED,
      38 => TExprNodeType::TIMEV2_LITERAL,
      39 => TExprNodeType::VIRTUAL_SLOT_REF,
      40 => TExprNodeType::VARBINARY_LITERAL,
      41 => TExprNodeType::TRY_CAST_EXPR,
      42 => TExprNodeType::SEARCH_EXPR,
      _ => TExprNodeType(i)
    }
  }
}

impl From<&i32> for TExprNodeType {
  fn from(i: &i32) -> Self {
    TExprNodeType::from(*i)
  }
}

impl From<TExprNodeType> for i32 {
  fn from(e: TExprNodeType) -> i32 {
    e.0
  }
}

impl From<&TExprNodeType> for i32 {
  fn from(e: &TExprNodeType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TNullSide(pub i32);

impl TNullSide {
  pub const LEFT: TNullSide = TNullSide(0);
  pub const RIGHT: TNullSide = TNullSide(1);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::LEFT,
    Self::RIGHT,
  ];
}

impl TSerializable for TNullSide {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TNullSide> {
    let enum_value = i_prot.read_i32()?;
    Ok(TNullSide::from(enum_value))
  }
}

impl From<i32> for TNullSide {
  fn from(i: i32) -> Self {
    match i {
      0 => TNullSide::LEFT,
      1 => TNullSide::RIGHT,
      _ => TNullSide(i)
    }
  }
}

impl From<&i32> for TNullSide {
  fn from(i: &i32) -> Self {
    TNullSide::from(*i)
  }
}

impl From<TNullSide> for i32 {
  fn from(e: TNullSide) -> i32 {
    e.0
  }
}

impl From<&TNullSide> for i32 {
  fn from(e: &TNullSide) -> i32 {
    e.0
  }
}

//
// TAggregateExpr
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TAggregateExpr {
  pub is_merge_agg: bool,
  pub param_types: Option<Vec<types::TTypeDesc>>,
}

impl TAggregateExpr {
  pub fn new<F2>(is_merge_agg: bool, param_types: F2) -> TAggregateExpr where F2: Into<Option<Vec<types::TTypeDesc>>> {
    TAggregateExpr {
      is_merge_agg,
      param_types: param_types.into(),
    }
  }
}

impl TSerializable for TAggregateExpr {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TAggregateExpr> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<Vec<types::TTypeDesc>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::TTypeDesc> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_0 = types::TTypeDesc::read_from_in_protocol(i_prot)?;
            val.push(list_elem_0);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TAggregateExpr.is_merge_agg", &f_1)?;
    let ret = TAggregateExpr {
      is_merge_agg: f_1.expect("auto-generated code should have checked for presence of required fields"),
      param_types: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TAggregateExpr");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("is_merge_agg", TType::Bool, 1))?;
    o_prot.write_bool(self.is_merge_agg)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.param_types {
      o_prot.write_field_begin(&TFieldIdentifier::new("param_types", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TBoolLiteral
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TBoolLiteral {
  pub value: bool,
}

impl TBoolLiteral {
  pub fn new(value: bool) -> TBoolLiteral {
    TBoolLiteral {
      value,
    }
  }
}

impl TSerializable for TBoolLiteral {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TBoolLiteral> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TBoolLiteral.value", &f_1)?;
    let ret = TBoolLiteral {
      value: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TBoolLiteral");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::Bool, 1))?;
    o_prot.write_bool(self.value)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TCaseExpr
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TCaseExpr {
  pub has_case_expr: bool,
  pub has_else_expr: bool,
}

impl TCaseExpr {
  pub fn new(has_case_expr: bool, has_else_expr: bool) -> TCaseExpr {
    TCaseExpr {
      has_case_expr,
      has_else_expr,
    }
  }
}

impl TSerializable for TCaseExpr {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TCaseExpr> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TCaseExpr.has_case_expr", &f_1)?;
    verify_required_field_exists("TCaseExpr.has_else_expr", &f_2)?;
    let ret = TCaseExpr {
      has_case_expr: f_1.expect("auto-generated code should have checked for presence of required fields"),
      has_else_expr: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TCaseExpr");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("has_case_expr", TType::Bool, 1))?;
    o_prot.write_bool(self.has_case_expr)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("has_else_expr", TType::Bool, 2))?;
    o_prot.write_bool(self.has_else_expr)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TDateLiteral
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDateLiteral {
  pub value: String,
}

impl TDateLiteral {
  pub fn new(value: String) -> TDateLiteral {
    TDateLiteral {
      value,
    }
  }
}

impl TSerializable for TDateLiteral {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDateLiteral> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TDateLiteral.value", &f_1)?;
    let ret = TDateLiteral {
      value: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDateLiteral");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 1))?;
    o_prot.write_string(&self.value)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TTimeV2Literal
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTimeV2Literal {
  pub value: OrderedFloat<f64>,
}

impl TTimeV2Literal {
  pub fn new(value: OrderedFloat<f64>) -> TTimeV2Literal {
    TTimeV2Literal {
      value,
    }
  }
}

impl TSerializable for TTimeV2Literal {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTimeV2Literal> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<OrderedFloat<f64>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TTimeV2Literal.value", &f_1)?;
    let ret = TTimeV2Literal {
      value: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TTimeV2Literal");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::Double, 1))?;
    o_prot.write_double(self.value.into())?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TFloatLiteral
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TFloatLiteral {
  pub value: OrderedFloat<f64>,
}

impl TFloatLiteral {
  pub fn new(value: OrderedFloat<f64>) -> TFloatLiteral {
    TFloatLiteral {
      value,
    }
  }
}

impl TSerializable for TFloatLiteral {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TFloatLiteral> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<OrderedFloat<f64>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TFloatLiteral.value", &f_1)?;
    let ret = TFloatLiteral {
      value: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TFloatLiteral");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::Double, 1))?;
    o_prot.write_double(self.value.into())?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TDecimalLiteral
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDecimalLiteral {
  pub value: String,
}

impl TDecimalLiteral {
  pub fn new(value: String) -> TDecimalLiteral {
    TDecimalLiteral {
      value,
    }
  }
}

impl TSerializable for TDecimalLiteral {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDecimalLiteral> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TDecimalLiteral.value", &f_1)?;
    let ret = TDecimalLiteral {
      value: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDecimalLiteral");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 1))?;
    o_prot.write_string(&self.value)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TIntLiteral
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TIntLiteral {
  pub value: i64,
}

impl TIntLiteral {
  pub fn new(value: i64) -> TIntLiteral {
    TIntLiteral {
      value,
    }
  }
}

impl TSerializable for TIntLiteral {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TIntLiteral> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TIntLiteral.value", &f_1)?;
    let ret = TIntLiteral {
      value: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TIntLiteral");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::I64, 1))?;
    o_prot.write_i64(self.value)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TLargeIntLiteral
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TLargeIntLiteral {
  pub value: String,
}

impl TLargeIntLiteral {
  pub fn new(value: String) -> TLargeIntLiteral {
    TLargeIntLiteral {
      value,
    }
  }
}

impl TSerializable for TLargeIntLiteral {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TLargeIntLiteral> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TLargeIntLiteral.value", &f_1)?;
    let ret = TLargeIntLiteral {
      value: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TLargeIntLiteral");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 1))?;
    o_prot.write_string(&self.value)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TIPv4Literal
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TIPv4Literal {
  pub value: i64,
}

impl TIPv4Literal {
  pub fn new(value: i64) -> TIPv4Literal {
    TIPv4Literal {
      value,
    }
  }
}

impl TSerializable for TIPv4Literal {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TIPv4Literal> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TIPv4Literal.value", &f_1)?;
    let ret = TIPv4Literal {
      value: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TIPv4Literal");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::I64, 1))?;
    o_prot.write_i64(self.value)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TIPv6Literal
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TIPv6Literal {
  pub value: String,
}

impl TIPv6Literal {
  pub fn new(value: String) -> TIPv6Literal {
    TIPv6Literal {
      value,
    }
  }
}

impl TSerializable for TIPv6Literal {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TIPv6Literal> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TIPv6Literal.value", &f_1)?;
    let ret = TIPv6Literal {
      value: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TIPv6Literal");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 1))?;
    o_prot.write_string(&self.value)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TInPredicate
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TInPredicate {
  pub is_not_in: bool,
}

impl TInPredicate {
  pub fn new(is_not_in: bool) -> TInPredicate {
    TInPredicate {
      is_not_in,
    }
  }
}

impl TSerializable for TInPredicate {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TInPredicate> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TInPredicate.is_not_in", &f_1)?;
    let ret = TInPredicate {
      is_not_in: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TInPredicate");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("is_not_in", TType::Bool, 1))?;
    o_prot.write_bool(self.is_not_in)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TIsNullPredicate
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TIsNullPredicate {
  pub is_not_null: bool,
}

impl TIsNullPredicate {
  pub fn new(is_not_null: bool) -> TIsNullPredicate {
    TIsNullPredicate {
      is_not_null,
    }
  }
}

impl TSerializable for TIsNullPredicate {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TIsNullPredicate> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TIsNullPredicate.is_not_null", &f_1)?;
    let ret = TIsNullPredicate {
      is_not_null: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TIsNullPredicate");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("is_not_null", TType::Bool, 1))?;
    o_prot.write_bool(self.is_not_null)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TLikePredicate
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TLikePredicate {
  pub escape_char: String,
}

impl TLikePredicate {
  pub fn new(escape_char: String) -> TLikePredicate {
    TLikePredicate {
      escape_char,
    }
  }
}

impl TSerializable for TLikePredicate {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TLikePredicate> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TLikePredicate.escape_char", &f_1)?;
    let ret = TLikePredicate {
      escape_char: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TLikePredicate");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("escape_char", TType::String, 1))?;
    o_prot.write_string(&self.escape_char)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TMatchPredicate
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TMatchPredicate {
  pub parser_type: String,
  pub parser_mode: String,
  pub char_filter_map: Option<BTreeMap<String, String>>,
  pub parser_lowercase: Option<bool>,
  pub parser_stopwords: Option<String>,
  pub custom_analyzer: Option<String>,
}

impl TMatchPredicate {
  pub fn new<F3, F4, F5, F6>(parser_type: String, parser_mode: String, char_filter_map: F3, parser_lowercase: F4, parser_stopwords: F5, custom_analyzer: F6) -> TMatchPredicate where F3: Into<Option<BTreeMap<String, String>>>, F4: Into<Option<bool>>, F5: Into<Option<String>>, F6: Into<Option<String>> {
    TMatchPredicate {
      parser_type,
      parser_mode,
      char_filter_map: char_filter_map.into(),
      parser_lowercase: parser_lowercase.into(),
      parser_stopwords: parser_stopwords.into(),
      custom_analyzer: custom_analyzer.into(),
    }
  }
}

impl TSerializable for TMatchPredicate {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TMatchPredicate> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<BTreeMap<String, String>> = None;
    let mut f_4: Option<bool> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_1 = i_prot.read_string()?;
            let map_val_2 = i_prot.read_string()?;
            val.insert(map_key_1, map_val_2);
          }
          i_prot.read_map_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TMatchPredicate.parser_type", &f_1)?;
    verify_required_field_exists("TMatchPredicate.parser_mode", &f_2)?;
    let ret = TMatchPredicate {
      parser_type: f_1.expect("auto-generated code should have checked for presence of required fields"),
      parser_mode: f_2.expect("auto-generated code should have checked for presence of required fields"),
      char_filter_map: f_3,
      parser_lowercase: f_4,
      parser_stopwords: f_5,
      custom_analyzer: f_6,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TMatchPredicate");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("parser_type", TType::String, 1))?;
    o_prot.write_string(&self.parser_type)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("parser_mode", TType::String, 2))?;
    o_prot.write_string(&self.parser_mode)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.char_filter_map {
      o_prot.write_field_begin(&TFieldIdentifier::new("char_filter_map", TType::Map, 3))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.parser_lowercase {
      o_prot.write_field_begin(&TFieldIdentifier::new("parser_lowercase", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.parser_stopwords {
      o_prot.write_field_begin(&TFieldIdentifier::new("parser_stopwords", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.custom_analyzer {
      o_prot.write_field_begin(&TFieldIdentifier::new("custom_analyzer", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TLiteralPredicate
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TLiteralPredicate {
  pub value: bool,
  pub is_null: bool,
}

impl TLiteralPredicate {
  pub fn new(value: bool, is_null: bool) -> TLiteralPredicate {
    TLiteralPredicate {
      value,
      is_null,
    }
  }
}

impl TSerializable for TLiteralPredicate {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TLiteralPredicate> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TLiteralPredicate.value", &f_1)?;
    verify_required_field_exists("TLiteralPredicate.is_null", &f_2)?;
    let ret = TLiteralPredicate {
      value: f_1.expect("auto-generated code should have checked for presence of required fields"),
      is_null: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TLiteralPredicate");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::Bool, 1))?;
    o_prot.write_bool(self.value)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("is_null", TType::Bool, 2))?;
    o_prot.write_bool(self.is_null)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TTupleIsNullPredicate
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTupleIsNullPredicate {
  pub tuple_ids: Vec<types::TTupleId>,
  pub null_side: Option<TNullSide>,
}

impl TTupleIsNullPredicate {
  pub fn new<F2>(tuple_ids: Vec<types::TTupleId>, null_side: F2) -> TTupleIsNullPredicate where F2: Into<Option<TNullSide>> {
    TTupleIsNullPredicate {
      tuple_ids,
      null_side: null_side.into(),
    }
  }
}

impl TSerializable for TTupleIsNullPredicate {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTupleIsNullPredicate> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<types::TTupleId>> = None;
    let mut f_2: Option<TNullSide> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<types::TTupleId> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_3 = i_prot.read_i32()?;
            val.push(list_elem_3);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = TNullSide::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TTupleIsNullPredicate.tuple_ids", &f_1)?;
    let ret = TTupleIsNullPredicate {
      tuple_ids: f_1.expect("auto-generated code should have checked for presence of required fields"),
      null_side: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TTupleIsNullPredicate");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tuple_ids", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I32, self.tuple_ids.len() as i32))?;
    for e in &self.tuple_ids {
      o_prot.write_i32(*e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.null_side {
      o_prot.write_field_begin(&TFieldIdentifier::new("null_side", TType::I32, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSlotRef
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSlotRef {
  pub slot_id: types::TSlotId,
  pub tuple_id: types::TTupleId,
  pub col_unique_id: Option<i32>,
  pub is_virtual_slot: Option<bool>,
}

impl TSlotRef {
  pub fn new<F3, F4>(slot_id: types::TSlotId, tuple_id: types::TTupleId, col_unique_id: F3, is_virtual_slot: F4) -> TSlotRef where F3: Into<Option<i32>>, F4: Into<Option<bool>> {
    TSlotRef {
      slot_id,
      tuple_id,
      col_unique_id: col_unique_id.into(),
      is_virtual_slot: is_virtual_slot.into(),
    }
  }
}

impl TSerializable for TSlotRef {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSlotRef> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<types::TSlotId> = None;
    let mut f_2: Option<types::TTupleId> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSlotRef.slot_id", &f_1)?;
    verify_required_field_exists("TSlotRef.tuple_id", &f_2)?;
    let ret = TSlotRef {
      slot_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tuple_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      col_unique_id: f_3,
      is_virtual_slot: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSlotRef");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("slot_id", TType::I32, 1))?;
    o_prot.write_i32(self.slot_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tuple_id", TType::I32, 2))?;
    o_prot.write_i32(self.tuple_id)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.col_unique_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("col_unique_id", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_virtual_slot {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_virtual_slot", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TColumnRef
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TColumnRef {
  pub column_id: Option<types::TSlotId>,
  pub column_name: Option<String>,
}

impl TColumnRef {
  pub fn new<F1, F2>(column_id: F1, column_name: F2) -> TColumnRef where F1: Into<Option<types::TSlotId>>, F2: Into<Option<String>> {
    TColumnRef {
      column_id: column_id.into(),
      column_name: column_name.into(),
    }
  }
}

impl TSerializable for TColumnRef {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TColumnRef> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<types::TSlotId> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TColumnRef {
      column_id: f_1,
      column_name: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TColumnRef");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.column_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("column_id", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.column_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("column_name", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TStringLiteral
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TStringLiteral {
  pub value: String,
}

impl TStringLiteral {
  pub fn new(value: String) -> TStringLiteral {
    TStringLiteral {
      value,
    }
  }
}

impl TSerializable for TStringLiteral {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TStringLiteral> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TStringLiteral.value", &f_1)?;
    let ret = TStringLiteral {
      value: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TStringLiteral");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 1))?;
    o_prot.write_string(&self.value)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TVarBinaryLiteral
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TVarBinaryLiteral {
  pub value: Vec<u8>,
}

impl TVarBinaryLiteral {
  pub fn new(value: Vec<u8>) -> TVarBinaryLiteral {
    TVarBinaryLiteral {
      value,
    }
  }
}

impl TSerializable for TVarBinaryLiteral {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TVarBinaryLiteral> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TVarBinaryLiteral.value", &f_1)?;
    let ret = TVarBinaryLiteral {
      value: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TVarBinaryLiteral");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 1))?;
    o_prot.write_bytes(&self.value)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TNullableStringLiteral
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TNullableStringLiteral {
  pub value: Option<String>,
  pub is_null: Option<bool>,
}

impl TNullableStringLiteral {
  pub fn new<F1, F2>(value: F1, is_null: F2) -> TNullableStringLiteral where F1: Into<Option<String>>, F2: Into<Option<bool>> {
    TNullableStringLiteral {
      value: value.into(),
      is_null: is_null.into(),
    }
  }
}

impl TSerializable for TNullableStringLiteral {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TNullableStringLiteral> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TNullableStringLiteral {
      value: f_1,
      is_null: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TNullableStringLiteral");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.value {
      o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_null {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_null", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TJsonLiteral
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TJsonLiteral {
  pub value: String,
}

impl TJsonLiteral {
  pub fn new(value: String) -> TJsonLiteral {
    TJsonLiteral {
      value,
    }
  }
}

impl TSerializable for TJsonLiteral {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TJsonLiteral> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TJsonLiteral.value", &f_1)?;
    let ret = TJsonLiteral {
      value: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TJsonLiteral");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 1))?;
    o_prot.write_string(&self.value)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TInfoFunc
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TInfoFunc {
  pub int_value: i64,
  pub str_value: String,
}

impl TInfoFunc {
  pub fn new(int_value: i64, str_value: String) -> TInfoFunc {
    TInfoFunc {
      int_value,
      str_value,
    }
  }
}

impl TSerializable for TInfoFunc {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TInfoFunc> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TInfoFunc.int_value", &f_1)?;
    verify_required_field_exists("TInfoFunc.str_value", &f_2)?;
    let ret = TInfoFunc {
      int_value: f_1.expect("auto-generated code should have checked for presence of required fields"),
      str_value: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TInfoFunc");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("int_value", TType::I64, 1))?;
    o_prot.write_i64(self.int_value)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("str_value", TType::String, 2))?;
    o_prot.write_string(&self.str_value)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TFunctionCallExpr
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TFunctionCallExpr {
  pub fn_: types::TFunction,
  pub vararg_start_idx: Option<i32>,
}

impl TFunctionCallExpr {
  pub fn new<F2>(fn_: types::TFunction, vararg_start_idx: F2) -> TFunctionCallExpr where F2: Into<Option<i32>> {
    TFunctionCallExpr {
      fn_,
      vararg_start_idx: vararg_start_idx.into(),
    }
  }
}

impl TSerializable for TFunctionCallExpr {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TFunctionCallExpr> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<types::TFunction> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = types::TFunction::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TFunctionCallExpr.fn_", &f_1)?;
    let ret = TFunctionCallExpr {
      fn_: f_1.expect("auto-generated code should have checked for presence of required fields"),
      vararg_start_idx: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TFunctionCallExpr");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("fn", TType::Struct, 1))?;
    self.fn_.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.vararg_start_idx {
      o_prot.write_field_begin(&TFieldIdentifier::new("vararg_start_idx", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSchemaChangeExpr
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSchemaChangeExpr {
  pub table_id: Option<i64>,
}

impl TSchemaChangeExpr {
  pub fn new<F1>(table_id: F1) -> TSchemaChangeExpr where F1: Into<Option<i64>> {
    TSchemaChangeExpr {
      table_id: table_id.into(),
    }
  }
}

impl TSerializable for TSchemaChangeExpr {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSchemaChangeExpr> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TSchemaChangeExpr {
      table_id: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSchemaChangeExpr");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.table_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("table_id", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSearchClause
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSearchClause {
  pub clause_type: String,
  pub field_name: Option<String>,
  pub value: Option<String>,
  pub children: Option<Vec<Box<TSearchClause>>>,
}

impl TSearchClause {
  pub fn new<F2, F3, F4>(clause_type: String, field_name: F2, value: F3, children: F4) -> TSearchClause where F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<Vec<Box<TSearchClause>>>> {
    TSearchClause {
      clause_type,
      field_name: field_name.into(),
      value: value.into(),
      children: children.into(),
    }
  }
}

impl TSerializable for TSearchClause {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSearchClause> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<Vec<Box<TSearchClause>>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Box<TSearchClause>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_4 = Box::new(TSearchClause::read_from_in_protocol(i_prot)?);
            val.push(list_elem_4);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSearchClause.clause_type", &f_1)?;
    let ret = TSearchClause {
      clause_type: f_1.expect("auto-generated code should have checked for presence of required fields"),
      field_name: f_2,
      value: f_3,
      children: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSearchClause");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clause_type", TType::String, 1))?;
    o_prot.write_string(&self.clause_type)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.field_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("field_name", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.value {
      o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.children {
      o_prot.write_field_begin(&TFieldIdentifier::new("children", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSearchFieldBinding
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSearchFieldBinding {
  pub field_name: String,
  pub slot_index: i32,
  pub parent_field_name: Option<String>,
  pub subcolumn_path: Option<String>,
  pub is_variant_subcolumn: Option<bool>,
}

impl TSearchFieldBinding {
  pub fn new<F3, F4, F5>(field_name: String, slot_index: i32, parent_field_name: F3, subcolumn_path: F4, is_variant_subcolumn: F5) -> TSearchFieldBinding where F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<bool>> {
    TSearchFieldBinding {
      field_name,
      slot_index,
      parent_field_name: parent_field_name.into(),
      subcolumn_path: subcolumn_path.into(),
      is_variant_subcolumn: is_variant_subcolumn.into(),
    }
  }
}

impl TSerializable for TSearchFieldBinding {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSearchFieldBinding> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSearchFieldBinding.field_name", &f_1)?;
    verify_required_field_exists("TSearchFieldBinding.slot_index", &f_2)?;
    let ret = TSearchFieldBinding {
      field_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      slot_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
      parent_field_name: f_3,
      subcolumn_path: f_4,
      is_variant_subcolumn: f_5,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSearchFieldBinding");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("field_name", TType::String, 1))?;
    o_prot.write_string(&self.field_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("slot_index", TType::I32, 2))?;
    o_prot.write_i32(self.slot_index)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.parent_field_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("parent_field_name", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.subcolumn_path {
      o_prot.write_field_begin(&TFieldIdentifier::new("subcolumn_path", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_variant_subcolumn {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_variant_subcolumn", TType::Bool, 5))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSearchParam
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSearchParam {
  pub original_dsl: String,
  pub root: TSearchClause,
  pub field_bindings: Vec<TSearchFieldBinding>,
}

impl TSearchParam {
  pub fn new(original_dsl: String, root: TSearchClause, field_bindings: Vec<TSearchFieldBinding>) -> TSearchParam {
    TSearchParam {
      original_dsl,
      root,
      field_bindings,
    }
  }
}

impl TSerializable for TSearchParam {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSearchParam> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<TSearchClause> = None;
    let mut f_3: Option<Vec<TSearchFieldBinding>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = TSearchClause::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TSearchFieldBinding> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_5 = TSearchFieldBinding::read_from_in_protocol(i_prot)?;
            val.push(list_elem_5);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSearchParam.original_dsl", &f_1)?;
    verify_required_field_exists("TSearchParam.root", &f_2)?;
    verify_required_field_exists("TSearchParam.field_bindings", &f_3)?;
    let ret = TSearchParam {
      original_dsl: f_1.expect("auto-generated code should have checked for presence of required fields"),
      root: f_2.expect("auto-generated code should have checked for presence of required fields"),
      field_bindings: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSearchParam");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("original_dsl", TType::String, 1))?;
    o_prot.write_string(&self.original_dsl)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("root", TType::Struct, 2))?;
    self.root.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("field_bindings", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.field_bindings.len() as i32))?;
    for e in &self.field_bindings {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TExprNode
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TExprNode {
  pub node_type: TExprNodeType,
  pub type_: types::TTypeDesc,
  pub opcode: Option<opcodes::TExprOpcode>,
  pub num_children: i32,
  pub agg_expr: Option<TAggregateExpr>,
  pub bool_literal: Option<TBoolLiteral>,
  pub case_expr: Option<TCaseExpr>,
  pub date_literal: Option<TDateLiteral>,
  pub float_literal: Option<TFloatLiteral>,
  pub int_literal: Option<TIntLiteral>,
  pub in_predicate: Option<TInPredicate>,
  pub is_null_pred: Option<TIsNullPredicate>,
  pub like_pred: Option<TLikePredicate>,
  pub literal_pred: Option<TLiteralPredicate>,
  pub slot_ref: Option<TSlotRef>,
  pub string_literal: Option<TStringLiteral>,
  pub tuple_is_null_pred: Option<TTupleIsNullPredicate>,
  pub info_func: Option<TInfoFunc>,
  pub decimal_literal: Option<TDecimalLiteral>,
  pub output_scale: i32,
  pub fn_call_expr: Option<TFunctionCallExpr>,
  pub large_int_literal: Option<TLargeIntLiteral>,
  pub output_column: Option<i32>,
  pub output_type: Option<types::TColumnType>,
  pub vector_opcode: Option<opcodes::TExprOpcode>,
  pub fn_: Option<types::TFunction>,
  pub vararg_start_idx: Option<i32>,
  pub child_type: Option<types::TPrimitiveType>,
  pub is_nullable: Option<bool>,
  pub json_literal: Option<TJsonLiteral>,
  pub schema_change_expr: Option<TSchemaChangeExpr>,
  pub column_ref: Option<TColumnRef>,
  pub match_predicate: Option<TMatchPredicate>,
  pub ipv4_literal: Option<TIPv4Literal>,
  pub ipv6_literal: Option<TIPv6Literal>,
  pub label: Option<String>,
  pub timev2_literal: Option<TTimeV2Literal>,
  pub varbinary_literal: Option<TVarBinaryLiteral>,
  pub is_cast_nullable: Option<bool>,
  pub search_param: Option<TSearchParam>,
}

impl TExprNode {
  pub fn new<F3, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15, F16, F17, F18, F19, F21, F22, F23, F24, F25, F26, F27, F28, F29, F30, F31, F32, F33, F34, F35, F36, F37, F38, F39, F40>(node_type: TExprNodeType, type_: types::TTypeDesc, opcode: F3, num_children: i32, agg_expr: F5, bool_literal: F6, case_expr: F7, date_literal: F8, float_literal: F9, int_literal: F10, in_predicate: F11, is_null_pred: F12, like_pred: F13, literal_pred: F14, slot_ref: F15, string_literal: F16, tuple_is_null_pred: F17, info_func: F18, decimal_literal: F19, output_scale: i32, fn_call_expr: F21, large_int_literal: F22, output_column: F23, output_type: F24, vector_opcode: F25, fn_: F26, vararg_start_idx: F27, child_type: F28, is_nullable: F29, json_literal: F30, schema_change_expr: F31, column_ref: F32, match_predicate: F33, ipv4_literal: F34, ipv6_literal: F35, label: F36, timev2_literal: F37, varbinary_literal: F38, is_cast_nullable: F39, search_param: F40) -> TExprNode where F3: Into<Option<opcodes::TExprOpcode>>, F5: Into<Option<TAggregateExpr>>, F6: Into<Option<TBoolLiteral>>, F7: Into<Option<TCaseExpr>>, F8: Into<Option<TDateLiteral>>, F9: Into<Option<TFloatLiteral>>, F10: Into<Option<TIntLiteral>>, F11: Into<Option<TInPredicate>>, F12: Into<Option<TIsNullPredicate>>, F13: Into<Option<TLikePredicate>>, F14: Into<Option<TLiteralPredicate>>, F15: Into<Option<TSlotRef>>, F16: Into<Option<TStringLiteral>>, F17: Into<Option<TTupleIsNullPredicate>>, F18: Into<Option<TInfoFunc>>, F19: Into<Option<TDecimalLiteral>>, F21: Into<Option<TFunctionCallExpr>>, F22: Into<Option<TLargeIntLiteral>>, F23: Into<Option<i32>>, F24: Into<Option<types::TColumnType>>, F25: Into<Option<opcodes::TExprOpcode>>, F26: Into<Option<types::TFunction>>, F27: Into<Option<i32>>, F28: Into<Option<types::TPrimitiveType>>, F29: Into<Option<bool>>, F30: Into<Option<TJsonLiteral>>, F31: Into<Option<TSchemaChangeExpr>>, F32: Into<Option<TColumnRef>>, F33: Into<Option<TMatchPredicate>>, F34: Into<Option<TIPv4Literal>>, F35: Into<Option<TIPv6Literal>>, F36: Into<Option<String>>, F37: Into<Option<TTimeV2Literal>>, F38: Into<Option<TVarBinaryLiteral>>, F39: Into<Option<bool>>, F40: Into<Option<TSearchParam>> {
    TExprNode {
      node_type,
      type_,
      opcode: opcode.into(),
      num_children,
      agg_expr: agg_expr.into(),
      bool_literal: bool_literal.into(),
      case_expr: case_expr.into(),
      date_literal: date_literal.into(),
      float_literal: float_literal.into(),
      int_literal: int_literal.into(),
      in_predicate: in_predicate.into(),
      is_null_pred: is_null_pred.into(),
      like_pred: like_pred.into(),
      literal_pred: literal_pred.into(),
      slot_ref: slot_ref.into(),
      string_literal: string_literal.into(),
      tuple_is_null_pred: tuple_is_null_pred.into(),
      info_func: info_func.into(),
      decimal_literal: decimal_literal.into(),
      output_scale,
      fn_call_expr: fn_call_expr.into(),
      large_int_literal: large_int_literal.into(),
      output_column: output_column.into(),
      output_type: output_type.into(),
      vector_opcode: vector_opcode.into(),
      fn_: fn_.into(),
      vararg_start_idx: vararg_start_idx.into(),
      child_type: child_type.into(),
      is_nullable: is_nullable.into(),
      json_literal: json_literal.into(),
      schema_change_expr: schema_change_expr.into(),
      column_ref: column_ref.into(),
      match_predicate: match_predicate.into(),
      ipv4_literal: ipv4_literal.into(),
      ipv6_literal: ipv6_literal.into(),
      label: label.into(),
      timev2_literal: timev2_literal.into(),
      varbinary_literal: varbinary_literal.into(),
      is_cast_nullable: is_cast_nullable.into(),
      search_param: search_param.into(),
    }
  }
}

impl TSerializable for TExprNode {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TExprNode> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TExprNodeType> = None;
    let mut f_2: Option<types::TTypeDesc> = None;
    let mut f_3: Option<opcodes::TExprOpcode> = None;
    let mut f_4: Option<i32> = None;
    let mut f_5: Option<TAggregateExpr> = None;
    let mut f_6: Option<TBoolLiteral> = None;
    let mut f_7: Option<TCaseExpr> = None;
    let mut f_8: Option<TDateLiteral> = None;
    let mut f_9: Option<TFloatLiteral> = None;
    let mut f_10: Option<TIntLiteral> = None;
    let mut f_11: Option<TInPredicate> = None;
    let mut f_12: Option<TIsNullPredicate> = None;
    let mut f_13: Option<TLikePredicate> = None;
    let mut f_14: Option<TLiteralPredicate> = None;
    let mut f_15: Option<TSlotRef> = None;
    let mut f_16: Option<TStringLiteral> = None;
    let mut f_17: Option<TTupleIsNullPredicate> = None;
    let mut f_18: Option<TInfoFunc> = None;
    let mut f_19: Option<TDecimalLiteral> = None;
    let mut f_20: Option<i32> = None;
    let mut f_21: Option<TFunctionCallExpr> = None;
    let mut f_22: Option<TLargeIntLiteral> = None;
    let mut f_23: Option<i32> = None;
    let mut f_24: Option<types::TColumnType> = None;
    let mut f_25: Option<opcodes::TExprOpcode> = None;
    let mut f_26: Option<types::TFunction> = None;
    let mut f_27: Option<i32> = None;
    let mut f_28: Option<types::TPrimitiveType> = None;
    let mut f_29: Option<bool> = None;
    let mut f_30: Option<TJsonLiteral> = None;
    let mut f_31: Option<TSchemaChangeExpr> = None;
    let mut f_32: Option<TColumnRef> = None;
    let mut f_33: Option<TMatchPredicate> = None;
    let mut f_34: Option<TIPv4Literal> = None;
    let mut f_35: Option<TIPv6Literal> = None;
    let mut f_36: Option<String> = None;
    let mut f_37: Option<TTimeV2Literal> = None;
    let mut f_38: Option<TVarBinaryLiteral> = None;
    let mut f_39: Option<bool> = None;
    let mut f_40: Option<TSearchParam> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TExprNodeType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = types::TTypeDesc::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = opcodes::TExprOpcode::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = TAggregateExpr::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = TBoolLiteral::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = TCaseExpr::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        8 => {
          let val = TDateLiteral::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        9 => {
          let val = TFloatLiteral::read_from_in_protocol(i_prot)?;
          f_9 = Some(val);
        },
        10 => {
          let val = TIntLiteral::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        11 => {
          let val = TInPredicate::read_from_in_protocol(i_prot)?;
          f_11 = Some(val);
        },
        12 => {
          let val = TIsNullPredicate::read_from_in_protocol(i_prot)?;
          f_12 = Some(val);
        },
        13 => {
          let val = TLikePredicate::read_from_in_protocol(i_prot)?;
          f_13 = Some(val);
        },
        14 => {
          let val = TLiteralPredicate::read_from_in_protocol(i_prot)?;
          f_14 = Some(val);
        },
        15 => {
          let val = TSlotRef::read_from_in_protocol(i_prot)?;
          f_15 = Some(val);
        },
        16 => {
          let val = TStringLiteral::read_from_in_protocol(i_prot)?;
          f_16 = Some(val);
        },
        17 => {
          let val = TTupleIsNullPredicate::read_from_in_protocol(i_prot)?;
          f_17 = Some(val);
        },
        18 => {
          let val = TInfoFunc::read_from_in_protocol(i_prot)?;
          f_18 = Some(val);
        },
        19 => {
          let val = TDecimalLiteral::read_from_in_protocol(i_prot)?;
          f_19 = Some(val);
        },
        20 => {
          let val = i_prot.read_i32()?;
          f_20 = Some(val);
        },
        21 => {
          let val = TFunctionCallExpr::read_from_in_protocol(i_prot)?;
          f_21 = Some(val);
        },
        22 => {
          let val = TLargeIntLiteral::read_from_in_protocol(i_prot)?;
          f_22 = Some(val);
        },
        23 => {
          let val = i_prot.read_i32()?;
          f_23 = Some(val);
        },
        24 => {
          let val = types::TColumnType::read_from_in_protocol(i_prot)?;
          f_24 = Some(val);
        },
        25 => {
          let val = opcodes::TExprOpcode::read_from_in_protocol(i_prot)?;
          f_25 = Some(val);
        },
        26 => {
          let val = types::TFunction::read_from_in_protocol(i_prot)?;
          f_26 = Some(val);
        },
        27 => {
          let val = i_prot.read_i32()?;
          f_27 = Some(val);
        },
        28 => {
          let val = types::TPrimitiveType::read_from_in_protocol(i_prot)?;
          f_28 = Some(val);
        },
        29 => {
          let val = i_prot.read_bool()?;
          f_29 = Some(val);
        },
        30 => {
          let val = TJsonLiteral::read_from_in_protocol(i_prot)?;
          f_30 = Some(val);
        },
        31 => {
          let val = TSchemaChangeExpr::read_from_in_protocol(i_prot)?;
          f_31 = Some(val);
        },
        32 => {
          let val = TColumnRef::read_from_in_protocol(i_prot)?;
          f_32 = Some(val);
        },
        33 => {
          let val = TMatchPredicate::read_from_in_protocol(i_prot)?;
          f_33 = Some(val);
        },
        34 => {
          let val = TIPv4Literal::read_from_in_protocol(i_prot)?;
          f_34 = Some(val);
        },
        35 => {
          let val = TIPv6Literal::read_from_in_protocol(i_prot)?;
          f_35 = Some(val);
        },
        36 => {
          let val = i_prot.read_string()?;
          f_36 = Some(val);
        },
        37 => {
          let val = TTimeV2Literal::read_from_in_protocol(i_prot)?;
          f_37 = Some(val);
        },
        38 => {
          let val = TVarBinaryLiteral::read_from_in_protocol(i_prot)?;
          f_38 = Some(val);
        },
        39 => {
          let val = i_prot.read_bool()?;
          f_39 = Some(val);
        },
        40 => {
          let val = TSearchParam::read_from_in_protocol(i_prot)?;
          f_40 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TExprNode.node_type", &f_1)?;
    verify_required_field_exists("TExprNode.type_", &f_2)?;
    verify_required_field_exists("TExprNode.num_children", &f_4)?;
    verify_required_field_exists("TExprNode.output_scale", &f_20)?;
    let ret = TExprNode {
      node_type: f_1.expect("auto-generated code should have checked for presence of required fields"),
      type_: f_2.expect("auto-generated code should have checked for presence of required fields"),
      opcode: f_3,
      num_children: f_4.expect("auto-generated code should have checked for presence of required fields"),
      agg_expr: f_5,
      bool_literal: f_6,
      case_expr: f_7,
      date_literal: f_8,
      float_literal: f_9,
      int_literal: f_10,
      in_predicate: f_11,
      is_null_pred: f_12,
      like_pred: f_13,
      literal_pred: f_14,
      slot_ref: f_15,
      string_literal: f_16,
      tuple_is_null_pred: f_17,
      info_func: f_18,
      decimal_literal: f_19,
      output_scale: f_20.expect("auto-generated code should have checked for presence of required fields"),
      fn_call_expr: f_21,
      large_int_literal: f_22,
      output_column: f_23,
      output_type: f_24,
      vector_opcode: f_25,
      fn_: f_26,
      vararg_start_idx: f_27,
      child_type: f_28,
      is_nullable: f_29,
      json_literal: f_30,
      schema_change_expr: f_31,
      column_ref: f_32,
      match_predicate: f_33,
      ipv4_literal: f_34,
      ipv6_literal: f_35,
      label: f_36,
      timev2_literal: f_37,
      varbinary_literal: f_38,
      is_cast_nullable: f_39,
      search_param: f_40,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TExprNode");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("node_type", TType::I32, 1))?;
    self.node_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::Struct, 2))?;
    self.type_.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.opcode {
      o_prot.write_field_begin(&TFieldIdentifier::new("opcode", TType::I32, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_begin(&TFieldIdentifier::new("num_children", TType::I32, 4))?;
    o_prot.write_i32(self.num_children)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.agg_expr {
      o_prot.write_field_begin(&TFieldIdentifier::new("agg_expr", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.bool_literal {
      o_prot.write_field_begin(&TFieldIdentifier::new("bool_literal", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.case_expr {
      o_prot.write_field_begin(&TFieldIdentifier::new("case_expr", TType::Struct, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.date_literal {
      o_prot.write_field_begin(&TFieldIdentifier::new("date_literal", TType::Struct, 8))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.float_literal {
      o_prot.write_field_begin(&TFieldIdentifier::new("float_literal", TType::Struct, 9))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.int_literal {
      o_prot.write_field_begin(&TFieldIdentifier::new("int_literal", TType::Struct, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.in_predicate {
      o_prot.write_field_begin(&TFieldIdentifier::new("in_predicate", TType::Struct, 11))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.is_null_pred {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_null_pred", TType::Struct, 12))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.like_pred {
      o_prot.write_field_begin(&TFieldIdentifier::new("like_pred", TType::Struct, 13))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.literal_pred {
      o_prot.write_field_begin(&TFieldIdentifier::new("literal_pred", TType::Struct, 14))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.slot_ref {
      o_prot.write_field_begin(&TFieldIdentifier::new("slot_ref", TType::Struct, 15))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.string_literal {
      o_prot.write_field_begin(&TFieldIdentifier::new("string_literal", TType::Struct, 16))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.tuple_is_null_pred {
      o_prot.write_field_begin(&TFieldIdentifier::new("tuple_is_null_pred", TType::Struct, 17))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.info_func {
      o_prot.write_field_begin(&TFieldIdentifier::new("info_func", TType::Struct, 18))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.decimal_literal {
      o_prot.write_field_begin(&TFieldIdentifier::new("decimal_literal", TType::Struct, 19))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_begin(&TFieldIdentifier::new("output_scale", TType::I32, 20))?;
    o_prot.write_i32(self.output_scale)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.fn_call_expr {
      o_prot.write_field_begin(&TFieldIdentifier::new("fn_call_expr", TType::Struct, 21))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.large_int_literal {
      o_prot.write_field_begin(&TFieldIdentifier::new("large_int_literal", TType::Struct, 22))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.output_column {
      o_prot.write_field_begin(&TFieldIdentifier::new("output_column", TType::I32, 23))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.output_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("output_type", TType::Struct, 24))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.vector_opcode {
      o_prot.write_field_begin(&TFieldIdentifier::new("vector_opcode", TType::I32, 25))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.fn_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("fn", TType::Struct, 26))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.vararg_start_idx {
      o_prot.write_field_begin(&TFieldIdentifier::new("vararg_start_idx", TType::I32, 27))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.child_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("child_type", TType::I32, 28))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_nullable {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_nullable", TType::Bool, 29))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.json_literal {
      o_prot.write_field_begin(&TFieldIdentifier::new("json_literal", TType::Struct, 30))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.schema_change_expr {
      o_prot.write_field_begin(&TFieldIdentifier::new("schema_change_expr", TType::Struct, 31))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.column_ref {
      o_prot.write_field_begin(&TFieldIdentifier::new("column_ref", TType::Struct, 32))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.match_predicate {
      o_prot.write_field_begin(&TFieldIdentifier::new("match_predicate", TType::Struct, 33))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.ipv4_literal {
      o_prot.write_field_begin(&TFieldIdentifier::new("ipv4_literal", TType::Struct, 34))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.ipv6_literal {
      o_prot.write_field_begin(&TFieldIdentifier::new("ipv6_literal", TType::Struct, 35))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.label {
      o_prot.write_field_begin(&TFieldIdentifier::new("label", TType::String, 36))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.timev2_literal {
      o_prot.write_field_begin(&TFieldIdentifier::new("timev2_literal", TType::Struct, 37))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.varbinary_literal {
      o_prot.write_field_begin(&TFieldIdentifier::new("varbinary_literal", TType::Struct, 38))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_cast_nullable {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_cast_nullable", TType::Bool, 39))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.search_param {
      o_prot.write_field_begin(&TFieldIdentifier::new("search_param", TType::Struct, 40))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TExpr
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TExpr {
  pub nodes: Vec<TExprNode>,
}

impl TExpr {
  pub fn new(nodes: Vec<TExprNode>) -> TExpr {
    TExpr {
      nodes,
    }
  }
}

impl TSerializable for TExpr {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TExpr> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<TExprNode>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TExprNode> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_6 = TExprNode::read_from_in_protocol(i_prot)?;
            val.push(list_elem_6);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TExpr.nodes", &f_1)?;
    let ret = TExpr {
      nodes: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TExpr");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("nodes", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.nodes.len() as i32))?;
    for e in &self.nodes {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TExprList
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TExprList {
  pub exprs: Vec<TExpr>,
}

impl TExprList {
  pub fn new(exprs: Vec<TExpr>) -> TExprList {
    TExprList {
      exprs,
    }
  }
}

impl TSerializable for TExprList {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TExprList> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<TExpr>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TExpr> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_7 = TExpr::read_from_in_protocol(i_prot)?;
            val.push(list_elem_7);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TExprList.exprs", &f_1)?;
    let ret = TExprList {
      exprs: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TExprList");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("exprs", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.exprs.len() as i32))?;
    for e in &self.exprs {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

