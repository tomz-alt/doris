// Autogenerated by Thrift Compiler (0.19.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(dead_code)]
#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![allow(clippy::too_many_arguments, clippy::type_complexity, clippy::vec_box, clippy::wrong_self_convention)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;

use thrift::OrderedFloat;
use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSerializable, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

use crate::types;

//
// TFieldPtr
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TFieldPtr {
  pub field_ptr: Option<Box<TField>>,
}

impl TFieldPtr {
  pub fn new<F1>(field_ptr: F1) -> TFieldPtr where F1: Into<Option<Box<TField>>> {
    TFieldPtr {
      field_ptr: field_ptr.into(),
    }
  }
}

impl TSerializable for TFieldPtr {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TFieldPtr> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Box<TField>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Box::new(TField::read_from_in_protocol(i_prot)?);
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TFieldPtr {
      field_ptr: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TFieldPtr");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.field_ptr {
      o_prot.write_field_begin(&TFieldIdentifier::new("field_ptr", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TArrayField
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TArrayField {
  pub item_field: Option<TFieldPtr>,
}

impl TArrayField {
  pub fn new<F1>(item_field: F1) -> TArrayField where F1: Into<Option<TFieldPtr>> {
    TArrayField {
      item_field: item_field.into(),
    }
  }
}

impl TSerializable for TArrayField {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TArrayField> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TFieldPtr> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TFieldPtr::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TArrayField {
      item_field: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TArrayField");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.item_field {
      o_prot.write_field_begin(&TFieldIdentifier::new("item_field", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TMapField
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TMapField {
  pub key_field: Option<TFieldPtr>,
  pub value_field: Option<TFieldPtr>,
}

impl TMapField {
  pub fn new<F1, F2>(key_field: F1, value_field: F2) -> TMapField where F1: Into<Option<TFieldPtr>>, F2: Into<Option<TFieldPtr>> {
    TMapField {
      key_field: key_field.into(),
      value_field: value_field.into(),
    }
  }
}

impl TSerializable for TMapField {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TMapField> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TFieldPtr> = None;
    let mut f_2: Option<TFieldPtr> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TFieldPtr::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = TFieldPtr::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TMapField {
      key_field: f_1,
      value_field: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TMapField");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.key_field {
      o_prot.write_field_begin(&TFieldIdentifier::new("key_field", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.value_field {
      o_prot.write_field_begin(&TFieldIdentifier::new("value_field", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TStructField
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TStructField {
  pub fields: Option<Vec<TFieldPtr>>,
}

impl TStructField {
  pub fn new<F1>(fields: F1) -> TStructField where F1: Into<Option<Vec<TFieldPtr>>> {
    TStructField {
      fields: fields.into(),
    }
  }
}

impl TSerializable for TStructField {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TStructField> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<TFieldPtr>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TFieldPtr> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_0 = TFieldPtr::read_from_in_protocol(i_prot)?;
            val.push(list_elem_0);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TStructField {
      fields: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TStructField");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.fields {
      o_prot.write_field_begin(&TFieldIdentifier::new("fields", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TNestedField
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TNestedField {
  ArrayField(TArrayField),
  StructField(TStructField),
  MapField(TMapField),
}

impl TSerializable for TNestedField {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TNestedField> {
    let mut ret: Option<TNestedField> = None;
    let mut received_field_count = 0;
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TArrayField::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(TNestedField::ArrayField(val));
          }
          received_field_count += 1;
        },
        2 => {
          let val = TStructField::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(TNestedField::StructField(val));
          }
          received_field_count += 1;
        },
        3 => {
          let val = TMapField::read_from_in_protocol(i_prot)?;
          if ret.is_none() {
            ret = Some(TNestedField::MapField(val));
          }
          received_field_count += 1;
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
          received_field_count += 1;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    if received_field_count == 0 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received empty union from remote TNestedField"
          )
        )
      )
    } else if received_field_count > 1 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received multiple fields for union from remote TNestedField"
          )
        )
      )
    } else {
      Ok(ret.expect("return value should have been constructed"))
    }
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TNestedField");
    o_prot.write_struct_begin(&struct_ident)?;
    match *self {
      TNestedField::ArrayField(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("array_field", TType::Struct, 1))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      TNestedField::StructField(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("struct_field", TType::Struct, 2))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
      TNestedField::MapField(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("map_field", TType::Struct, 3))?;
        f.write_to_out_protocol(o_prot)?;
        o_prot.write_field_end()?;
      },
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TField
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TField {
  pub is_optional: Option<bool>,
  pub id: Option<i32>,
  pub name: Option<String>,
  pub type_: Option<types::TColumnType>,
  pub nested_field: Option<TNestedField>,
}

impl TField {
  pub fn new<F1, F2, F3, F4, F5>(is_optional: F1, id: F2, name: F3, type_: F4, nested_field: F5) -> TField where F1: Into<Option<bool>>, F2: Into<Option<i32>>, F3: Into<Option<String>>, F4: Into<Option<types::TColumnType>>, F5: Into<Option<TNestedField>> {
    TField {
      is_optional: is_optional.into(),
      id: id.into(),
      name: name.into(),
      type_: type_.into(),
      nested_field: nested_field.into(),
    }
  }
}

impl TSerializable for TField {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TField> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<types::TColumnType> = None;
    let mut f_5: Option<TNestedField> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = types::TColumnType::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = TNestedField::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TField {
      is_optional: f_1,
      id: f_2,
      name: f_3,
      type_: f_4,
      nested_field: f_5,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TField");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.is_optional {
      o_prot.write_field_begin(&TFieldIdentifier::new("is_optional", TType::Bool, 1))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.id {
      o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.type_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.nested_field {
      o_prot.write_field_begin(&TFieldIdentifier::new("nestedField", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSchema
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSchema {
  pub schema_id: Option<i64>,
  pub root_field: Option<TStructField>,
}

impl TSchema {
  pub fn new<F1, F2>(schema_id: F1, root_field: F2) -> TSchema where F1: Into<Option<i64>>, F2: Into<Option<TStructField>> {
    TSchema {
      schema_id: schema_id.into(),
      root_field: root_field.into(),
    }
  }
}

impl TSerializable for TSchema {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSchema> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<TStructField> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = TStructField::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TSchema {
      schema_id: f_1,
      root_field: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSchema");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.schema_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("schema_id", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.root_field {
      o_prot.write_field_begin(&TFieldIdentifier::new("root_field", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

