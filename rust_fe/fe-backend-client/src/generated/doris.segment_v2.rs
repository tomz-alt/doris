// This file is @generated by prost-build.
/// page position info
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PagePointerPb {
    /// offset in segment file
    #[prost(uint64, required, tag = "1")]
    pub offset: u64,
    /// size of page in byte
    #[prost(uint32, required, tag = "2")]
    pub size: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataPairPb {
    #[prost(string, optional, tag = "1")]
    pub key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub value: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataPageFooterPb {
    /// required: ordinal of the first value
    #[prost(uint64, optional, tag = "1")]
    pub first_ordinal: ::core::option::Option<u64>,
    /// required: number of values, including NULLs
    #[prost(uint64, optional, tag = "2")]
    pub num_values: ::core::option::Option<u64>,
    /// required: size of nullmap, 0 if the page doesn't contain NULL
    #[prost(uint32, optional, tag = "3")]
    pub nullmap_size: ::core::option::Option<u32>,
    /// only for array column
    /// Save the offset of next page
    #[prost(uint64, optional, tag = "4")]
    pub next_array_item_ordinal: ::core::option::Option<u64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexPageFooterPb {
    /// required: number of index entries in this page
    #[prost(uint32, optional, tag = "1")]
    pub num_entries: ::core::option::Option<u32>,
    /// required: type of the index page
    #[prost(enumeration = "index_page_footer_pb::Type", optional, tag = "2")]
    pub r#type: ::core::option::Option<i32>,
}
/// Nested message and enum types in `IndexPageFooterPB`.
pub mod index_page_footer_pb {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        UnknownIndexPageType = 0,
        Leaf = 1,
        Internal = 2,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::UnknownIndexPageType => "UNKNOWN_INDEX_PAGE_TYPE",
                Type::Leaf => "LEAF",
                Type::Internal => "INTERNAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN_INDEX_PAGE_TYPE" => Some(Self::UnknownIndexPageType),
                "LEAF" => Some(Self::Leaf),
                "INTERNAL" => Some(Self::Internal),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DictPageFooterPb {
    /// required: encoding for dictionary
    #[prost(enumeration = "EncodingTypePb", optional, tag = "1")]
    pub encoding: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShortKeyFooterPb {
    /// How many index item in this index.
    #[prost(uint32, optional, tag = "1")]
    pub num_items: ::core::option::Option<u32>,
    /// The total bytes occupied by the index key
    #[prost(uint32, optional, tag = "2")]
    pub key_bytes: ::core::option::Option<u32>,
    /// The total bytes occupied by the key offsets
    #[prost(uint32, optional, tag = "3")]
    pub offset_bytes: ::core::option::Option<u32>,
    /// Segment id which this index is belong to
    #[prost(uint32, optional, tag = "4")]
    pub segment_id: ::core::option::Option<u32>,
    /// number rows in each block
    #[prost(uint32, optional, tag = "5")]
    pub num_rows_per_block: ::core::option::Option<u32>,
    /// How many rows in this segment
    #[prost(uint32, optional, tag = "6")]
    pub num_segment_rows: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PageFooterPb {
    /// required: indicates which of the *_footer fields is set
    #[prost(enumeration = "PageTypePb", optional, tag = "1")]
    pub r#type: ::core::option::Option<i32>,
    /// required: page body size before compression (exclude footer and crc).
    /// page body is uncompressed when it's equal to page body size
    #[prost(uint32, optional, tag = "2")]
    pub uncompressed_size: ::core::option::Option<u32>,
    /// present only when type == DATA_PAGE
    #[prost(message, optional, tag = "7")]
    pub data_page_footer: ::core::option::Option<DataPageFooterPb>,
    /// present only when type == INDEX_PAGE
    #[prost(message, optional, tag = "8")]
    pub index_page_footer: ::core::option::Option<IndexPageFooterPb>,
    /// present only when type == DICTIONARY_PAGE
    #[prost(message, optional, tag = "9")]
    pub dict_page_footer: ::core::option::Option<DictPageFooterPb>,
    /// present only when type == SHORT_KEY_PAGE
    #[prost(message, optional, tag = "10")]
    pub short_key_page_footer: ::core::option::Option<ShortKeyFooterPb>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZoneMapPb {
    /// minimum not-null value, invalid when all values are null(has_not_null==false)
    #[prost(bytes = "vec", optional, tag = "1")]
    pub min: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// maximum not-null value, invalid when all values are null (has_not_null==false)
    #[prost(bytes = "vec", optional, tag = "2")]
    pub max: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// whether the zone has null value
    #[prost(bool, optional, tag = "3")]
    pub has_null: ::core::option::Option<bool>,
    /// whether the zone has not-null value
    #[prost(bool, optional, tag = "4")]
    pub has_not_null: ::core::option::Option<bool>,
    /// whether this zone is including all values;
    #[prost(bool, optional, tag = "5", default = "false")]
    pub pass_all: ::core::option::Option<bool>,
    /// whether the zone has +Infinity value
    #[prost(bool, optional, tag = "6")]
    pub has_positive_inf: ::core::option::Option<bool>,
    /// whether the zone has -Infinity value
    #[prost(bool, optional, tag = "7")]
    pub has_negative_inf: ::core::option::Option<bool>,
    /// whether the zone has NaN value
    #[prost(bool, optional, tag = "8")]
    pub has_nan: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ColumnPathPartInfo {
    /// key represent a part of key in full parts info
    #[prost(string, optional, tag = "1")]
    pub key: ::core::option::Option<::prost::alloc::string::String>,
    /// is_nested indicates that the part if a nested array
    #[prost(bool, optional, tag = "2")]
    pub is_nested: ::core::option::Option<bool>,
    /// anonymous_array_level indicates the nested level of array
    #[prost(uint32, optional, tag = "3")]
    pub anonymous_array_level: ::core::option::Option<u32>,
}
/// Persist info for PathInData that represents path in document, e.g. JSON.
/// Each variant's subcolumn must persist it's path info to storage, since it only
/// uses path info to identify a column in storage instead of column unique id
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ColumnPathInfo {
    /// The full path string representation
    #[prost(string, optional, tag = "1")]
    pub path: ::core::option::Option<::prost::alloc::string::String>,
    /// A list of parts, each part indicate a sub path of the whole path
    #[prost(message, repeated, tag = "2")]
    pub path_part_infos: ::prost::alloc::vec::Vec<ColumnPathPartInfo>,
    #[prost(bool, optional, tag = "3")]
    pub has_nested: ::core::option::Option<bool>,
    /// The original parent variant's unique id, used to distinguish from different variants
    #[prost(uint32, optional, tag = "4")]
    pub parrent_column_unique_id: ::core::option::Option<u32>,
    /// is_typed flags if the subcolumn is assigned specific types
    #[prost(bool, optional, tag = "5")]
    pub is_typed: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VariantStatisticsPb {
    /// in the order of subcolumns in variant
    #[prost(map = "string, uint32", tag = "2")]
    pub sparse_column_non_null_size: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        u32,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ColumnMetaPb {
    /// column id in table schema
    #[prost(uint32, optional, tag = "1")]
    pub column_id: ::core::option::Option<u32>,
    /// unique column id
    #[prost(uint32, optional, tag = "2")]
    pub unique_id: ::core::option::Option<u32>,
    /// this field is FieldType's value
    #[prost(int32, optional, tag = "3")]
    pub r#type: ::core::option::Option<i32>,
    /// var length for string type
    #[prost(int32, optional, tag = "4")]
    pub length: ::core::option::Option<i32>,
    #[prost(enumeration = "EncodingTypePb", optional, tag = "5")]
    pub encoding: ::core::option::Option<i32>,
    /// compress type for column
    #[prost(enumeration = "CompressionTypePb", optional, tag = "6")]
    pub compression: ::core::option::Option<i32>,
    /// if this column can be nullable
    #[prost(bool, optional, tag = "7")]
    pub is_nullable: ::core::option::Option<bool>,
    /// metadata about all the column indexes
    #[prost(message, repeated, tag = "8")]
    pub indexes: ::prost::alloc::vec::Vec<ColumnIndexMetaPb>,
    /// pointer to dictionary page when using DICT_ENCODING
    #[prost(message, optional, tag = "9")]
    pub dict_page: ::core::option::Option<PagePointerPb>,
    #[prost(message, repeated, tag = "10")]
    pub children_columns: ::prost::alloc::vec::Vec<ColumnMetaPb>,
    /// required by array/struct/map reader to create child reader.
    #[prost(uint64, optional, tag = "11")]
    pub num_rows: ::core::option::Option<u64>,
    #[prost(string, repeated, tag = "12")]
    pub children_column_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// persist info for PathInData that represents path in document, e.g. JSON.
    #[prost(message, optional, tag = "13")]
    pub column_path_info: ::core::option::Option<ColumnPathInfo>,
    /// Extra type info to be compatible with tabet schema
    ///
    /// ColumnMessage.default_value ?
    #[prost(bytes = "vec", optional, tag = "14")]
    pub default_value: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// ColumnMessage.precision
    #[prost(int32, optional, tag = "15")]
    pub precision: ::core::option::Option<i32>,
    /// ColumnMessag
    #[prost(int32, optional, tag = "16")]
    pub frac: ::core::option::Option<i32>,
    /// deprecated
    #[prost(message, repeated, tag = "17")]
    pub sparse_columns: ::prost::alloc::vec::Vec<ColumnMetaPb>,
    /// used on agg_state type
    #[prost(bool, optional, tag = "18")]
    pub result_is_nullable: ::core::option::Option<bool>,
    /// used on agg_state type
    #[prost(string, optional, tag = "19")]
    pub function_name: ::core::option::Option<::prost::alloc::string::String>,
    /// used on agg_state type
    #[prost(int32, optional, tag = "20")]
    pub be_exec_version: ::core::option::Option<i32>,
    /// only used in variant type
    #[prost(message, optional, tag = "21")]
    pub variant_statistics: ::core::option::Option<VariantStatisticsPb>,
    #[prost(int32, optional, tag = "22", default = "0")]
    pub variant_max_subcolumns_count: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "23", default = "0")]
    pub none_null_size: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "24")]
    pub compressed_data_bytes: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "25")]
    pub uncompressed_data_bytes: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "26")]
    pub raw_data_bytes: ::core::option::Option<u64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrimaryKeyIndexMetaPb {
    /// primary key index
    #[prost(message, optional, tag = "1")]
    pub primary_key_index: ::core::option::Option<IndexedColumnMetaPb>,
    /// bloom filter index
    #[prost(message, optional, tag = "2")]
    pub bloom_filter_index: ::core::option::Option<ColumnIndexMetaPb>,
    #[prost(bytes = "vec", optional, tag = "3")]
    pub min_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "4")]
    pub max_key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SegmentFooterPb {
    /// file version
    #[prost(uint32, optional, tag = "1", default = "1")]
    pub version: ::core::option::Option<u32>,
    /// tablet schema
    #[prost(message, repeated, tag = "2")]
    pub columns: ::prost::alloc::vec::Vec<ColumnMetaPb>,
    /// number of values
    #[prost(uint32, optional, tag = "3")]
    pub num_rows: ::core::option::Option<u32>,
    /// total index footprint of all columns
    #[prost(uint64, optional, tag = "4")]
    pub index_footprint: ::core::option::Option<u64>,
    /// total data footprint of all columns
    #[prost(uint64, optional, tag = "5")]
    pub data_footprint: ::core::option::Option<u64>,
    /// raw data footprint
    #[prost(uint64, optional, tag = "6")]
    pub raw_data_footprint: ::core::option::Option<u64>,
    /// default compression type for file columns
    #[prost(enumeration = "CompressionTypePb", optional, tag = "7", default = "Lz4f")]
    pub compress_type: ::core::option::Option<i32>,
    /// meta data of file
    #[prost(message, repeated, tag = "8")]
    pub file_meta_datas: ::prost::alloc::vec::Vec<MetadataPairPb>,
    /// Short key index's page
    #[prost(message, optional, tag = "9")]
    pub short_key_index_page: ::core::option::Option<PagePointerPb>,
    /// Primary key index meta
    #[prost(message, optional, tag = "10")]
    pub primary_key_index_meta: ::core::option::Option<PrimaryKeyIndexMetaPb>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BTreeMetaPb {
    /// required: pointer to either root index page or sole data page based on is_root_data_page
    #[prost(message, optional, tag = "1")]
    pub root_page: ::core::option::Option<PagePointerPb>,
    /// required: true if we only have one data page, in which case root points to that page directly
    #[prost(bool, optional, tag = "2")]
    pub is_root_data_page: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexedColumnMetaPb {
    /// required: FieldType value
    #[prost(int32, optional, tag = "1")]
    pub data_type: ::core::option::Option<i32>,
    /// required: encoding for this column
    #[prost(enumeration = "EncodingTypePb", optional, tag = "2")]
    pub encoding: ::core::option::Option<i32>,
    /// required: total number of values in this column
    #[prost(int64, optional, tag = "3")]
    pub num_values: ::core::option::Option<i64>,
    /// present iff this column has ordinal index
    #[prost(message, optional, tag = "4")]
    pub ordinal_index_meta: ::core::option::Option<BTreeMetaPb>,
    /// present iff this column contains sorted values and has value index
    #[prost(message, optional, tag = "5")]
    pub value_index_meta: ::core::option::Option<BTreeMetaPb>,
    /// compression type for data and index page
    #[prost(
        enumeration = "CompressionTypePb",
        optional,
        tag = "6",
        default = "NoCompression"
    )]
    pub compression: ::core::option::Option<i32>,
    /// index size
    #[prost(uint64, optional, tag = "7")]
    pub size: ::core::option::Option<u64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ColumnIndexMetaPb {
    #[prost(enumeration = "ColumnIndexTypePb", optional, tag = "1")]
    pub r#type: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "7")]
    pub ordinal_index: ::core::option::Option<OrdinalIndexPb>,
    #[prost(message, optional, tag = "8")]
    pub zone_map_index: ::core::option::Option<ZoneMapIndexPb>,
    #[prost(message, optional, tag = "9")]
    pub bitmap_index: ::core::option::Option<BitmapIndexPb>,
    #[prost(message, optional, tag = "10")]
    pub bloom_filter_index: ::core::option::Option<BloomFilterIndexPb>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OrdinalIndexPb {
    /// required: the root page can be data page if there is only one data page,
    /// or the only index page if there is more than one data pages.
    #[prost(message, optional, tag = "1")]
    pub root_page: ::core::option::Option<BTreeMetaPb>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZoneMapIndexPb {
    /// required: segment-level zone map
    #[prost(message, optional, tag = "1")]
    pub segment_zone_map: ::core::option::Option<ZoneMapPb>,
    /// required: zone map for each data page is stored in an IndexedColumn with ordinal index
    #[prost(message, optional, tag = "2")]
    pub page_zone_maps: ::core::option::Option<IndexedColumnMetaPb>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BitmapIndexPb {
    #[prost(
        enumeration = "bitmap_index_pb::BitmapType",
        optional,
        tag = "1",
        default = "RoaringBitmap"
    )]
    pub bitmap_type: ::core::option::Option<i32>,
    /// required: whether the index contains null key.
    /// if true, the last bitmap (ordinal:dict_column.num_values) in bitmap_column is
    /// the bitmap for null key. we don't store null key in dict_column.
    #[prost(bool, optional, tag = "2")]
    pub has_null: ::core::option::Option<bool>,
    /// required: meta for ordered dictionary part
    #[prost(message, optional, tag = "3")]
    pub dict_column: ::core::option::Option<IndexedColumnMetaPb>,
    /// required: meta for bitmaps part
    #[prost(message, optional, tag = "4")]
    pub bitmap_column: ::core::option::Option<IndexedColumnMetaPb>,
}
/// Nested message and enum types in `BitmapIndexPB`.
pub mod bitmap_index_pb {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BitmapType {
        UnknownBitmapType = 0,
        RoaringBitmap = 1,
    }
    impl BitmapType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                BitmapType::UnknownBitmapType => "UNKNOWN_BITMAP_TYPE",
                BitmapType::RoaringBitmap => "ROARING_BITMAP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN_BITMAP_TYPE" => Some(Self::UnknownBitmapType),
                "ROARING_BITMAP" => Some(Self::RoaringBitmap),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BloomFilterIndexPb {
    /// required
    #[prost(enumeration = "HashStrategyPb", optional, tag = "1")]
    pub hash_strategy: ::core::option::Option<i32>,
    #[prost(enumeration = "BloomFilterAlgorithmPb", optional, tag = "2")]
    pub algorithm: ::core::option::Option<i32>,
    /// required: meta for bloom filters
    #[prost(message, optional, tag = "3")]
    pub bloom_filter: ::core::option::Option<IndexedColumnMetaPb>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EncodingTypePb {
    UnknownEncoding = 0,
    DefaultEncoding = 1,
    PlainEncoding = 2,
    PrefixEncoding = 3,
    Rle = 4,
    DictEncoding = 5,
    BitShuffle = 6,
    /// Frame-Of-Reference
    ForEncoding = 7,
    /// Binary plain with varuint length prefix
    PlainEncodingV2 = 8,
}
impl EncodingTypePb {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            EncodingTypePb::UnknownEncoding => "UNKNOWN_ENCODING",
            EncodingTypePb::DefaultEncoding => "DEFAULT_ENCODING",
            EncodingTypePb::PlainEncoding => "PLAIN_ENCODING",
            EncodingTypePb::PrefixEncoding => "PREFIX_ENCODING",
            EncodingTypePb::Rle => "RLE",
            EncodingTypePb::DictEncoding => "DICT_ENCODING",
            EncodingTypePb::BitShuffle => "BIT_SHUFFLE",
            EncodingTypePb::ForEncoding => "FOR_ENCODING",
            EncodingTypePb::PlainEncodingV2 => "PLAIN_ENCODING_V2",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNKNOWN_ENCODING" => Some(Self::UnknownEncoding),
            "DEFAULT_ENCODING" => Some(Self::DefaultEncoding),
            "PLAIN_ENCODING" => Some(Self::PlainEncoding),
            "PREFIX_ENCODING" => Some(Self::PrefixEncoding),
            "RLE" => Some(Self::Rle),
            "DICT_ENCODING" => Some(Self::DictEncoding),
            "BIT_SHUFFLE" => Some(Self::BitShuffle),
            "FOR_ENCODING" => Some(Self::ForEncoding),
            "PLAIN_ENCODING_V2" => Some(Self::PlainEncodingV2),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CompressionTypePb {
    UnknownCompression = 0,
    DefaultCompression = 1,
    NoCompression = 2,
    Snappy = 3,
    Lz4 = 4,
    Lz4f = 5,
    Zlib = 6,
    Zstd = 7,
    Lz4hc = 8,
}
impl CompressionTypePb {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            CompressionTypePb::UnknownCompression => "UNKNOWN_COMPRESSION",
            CompressionTypePb::DefaultCompression => "DEFAULT_COMPRESSION",
            CompressionTypePb::NoCompression => "NO_COMPRESSION",
            CompressionTypePb::Snappy => "SNAPPY",
            CompressionTypePb::Lz4 => "LZ4",
            CompressionTypePb::Lz4f => "LZ4F",
            CompressionTypePb::Zlib => "ZLIB",
            CompressionTypePb::Zstd => "ZSTD",
            CompressionTypePb::Lz4hc => "LZ4HC",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNKNOWN_COMPRESSION" => Some(Self::UnknownCompression),
            "DEFAULT_COMPRESSION" => Some(Self::DefaultCompression),
            "NO_COMPRESSION" => Some(Self::NoCompression),
            "SNAPPY" => Some(Self::Snappy),
            "LZ4" => Some(Self::Lz4),
            "LZ4F" => Some(Self::Lz4f),
            "ZLIB" => Some(Self::Zlib),
            "ZSTD" => Some(Self::Zstd),
            "LZ4HC" => Some(Self::Lz4hc),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PageTypePb {
    UnknownPageType = 0,
    DataPage = 1,
    IndexPage = 2,
    DictionaryPage = 3,
    ShortKeyPage = 4,
    PrimaryKeyIndexPage = 5,
}
impl PageTypePb {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            PageTypePb::UnknownPageType => "UNKNOWN_PAGE_TYPE",
            PageTypePb::DataPage => "DATA_PAGE",
            PageTypePb::IndexPage => "INDEX_PAGE",
            PageTypePb::DictionaryPage => "DICTIONARY_PAGE",
            PageTypePb::ShortKeyPage => "SHORT_KEY_PAGE",
            PageTypePb::PrimaryKeyIndexPage => "PRIMARY_KEY_INDEX_PAGE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNKNOWN_PAGE_TYPE" => Some(Self::UnknownPageType),
            "DATA_PAGE" => Some(Self::DataPage),
            "INDEX_PAGE" => Some(Self::IndexPage),
            "DICTIONARY_PAGE" => Some(Self::DictionaryPage),
            "SHORT_KEY_PAGE" => Some(Self::ShortKeyPage),
            "PRIMARY_KEY_INDEX_PAGE" => Some(Self::PrimaryKeyIndexPage),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ColumnIndexTypePb {
    UnknownIndexType = 0,
    OrdinalIndex = 1,
    ZoneMapIndex = 2,
    BitmapIndex = 3,
    BloomFilterIndex = 4,
}
impl ColumnIndexTypePb {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ColumnIndexTypePb::UnknownIndexType => "UNKNOWN_INDEX_TYPE",
            ColumnIndexTypePb::OrdinalIndex => "ORDINAL_INDEX",
            ColumnIndexTypePb::ZoneMapIndex => "ZONE_MAP_INDEX",
            ColumnIndexTypePb::BitmapIndex => "BITMAP_INDEX",
            ColumnIndexTypePb::BloomFilterIndex => "BLOOM_FILTER_INDEX",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNKNOWN_INDEX_TYPE" => Some(Self::UnknownIndexType),
            "ORDINAL_INDEX" => Some(Self::OrdinalIndex),
            "ZONE_MAP_INDEX" => Some(Self::ZoneMapIndex),
            "BITMAP_INDEX" => Some(Self::BitmapIndex),
            "BLOOM_FILTER_INDEX" => Some(Self::BloomFilterIndex),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HashStrategyPb {
    HashMurmur3X6464 = 0,
    CityHash64 = 1,
}
impl HashStrategyPb {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            HashStrategyPb::HashMurmur3X6464 => "HASH_MURMUR3_X64_64",
            HashStrategyPb::CityHash64 => "CITY_HASH_64",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "HASH_MURMUR3_X64_64" => Some(Self::HashMurmur3X6464),
            "CITY_HASH_64" => Some(Self::CityHash64),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BloomFilterAlgorithmPb {
    BlockBloomFilter = 0,
    ClassicBloomFilter = 1,
    NgramBloomFilter = 2,
}
impl BloomFilterAlgorithmPb {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            BloomFilterAlgorithmPb::BlockBloomFilter => "BLOCK_BLOOM_FILTER",
            BloomFilterAlgorithmPb::ClassicBloomFilter => "CLASSIC_BLOOM_FILTER",
            BloomFilterAlgorithmPb::NgramBloomFilter => "NGRAM_BLOOM_FILTER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BLOCK_BLOOM_FILTER" => Some(Self::BlockBloomFilter),
            "CLASSIC_BLOOM_FILTER" => Some(Self::ClassicBloomFilter),
            "NGRAM_BLOOM_FILTER" => Some(Self::NgramBloomFilter),
            _ => None,
        }
    }
}
