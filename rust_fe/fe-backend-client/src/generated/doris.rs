// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PStatus {
    #[prost(int32, required, tag = "1")]
    pub status_code: i32,
    #[prost(string, repeated, tag = "2")]
    pub error_msgs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PScalarType {
    /// TPrimitiveType, use int32 to avoid redefine Enum
    #[prost(int32, required, tag = "1")]
    pub r#type: i32,
    /// Only set if type == CHAR or type == VARCHAR
    #[prost(int32, optional, tag = "2")]
    pub len: ::core::option::Option<i32>,
    /// Only set for DECIMAL
    #[prost(int32, optional, tag = "3")]
    pub precision: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub scale: ::core::option::Option<i32>,
}
/// Represents a field in a STRUCT type.
/// TODO: Model column stats for struct fields.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PStructField {
    #[prost(string, required, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "2")]
    pub comment: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "3")]
    pub contains_null: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PTypeNode {
    /// TTypeNodeType(SCALAR, ARRAY, MAP, STRUCT)
    #[prost(int32, required, tag = "1")]
    pub r#type: i32,
    /// only set for scalar types
    #[prost(message, optional, tag = "2")]
    pub scalar_type: ::core::option::Option<PScalarType>,
    /// only used for structs; has struct_fields.size() corresponding child types
    #[prost(message, repeated, tag = "3")]
    pub struct_fields: ::prost::alloc::vec::Vec<PStructField>,
    /// only used for complex types, such as array, map and etc.
    #[prost(bool, optional, tag = "4")]
    pub contains_null: ::core::option::Option<bool>,
    /// update for map/struct type
    #[prost(bool, repeated, packed = "false", tag = "5")]
    pub contains_nulls: ::prost::alloc::vec::Vec<bool>,
    /// only used for VARIANT
    #[prost(int32, optional, tag = "6", default = "0")]
    pub variant_max_subcolumns_count: ::core::option::Option<i32>,
}
/// A flattened representation of a tree of column types obtained by depth-first
/// traversal. Complex types such as map, array and struct have child types corresponding
/// to the map key/value, array item type, and struct fields, respectively.
/// For scalar types the list contains only a single node.
/// Note: We cannot rename this to TType because it conflicts with Thrift's internal TType
/// and the generated Python thrift files will not work.
/// Note: TTypeDesc in impala is TColumnType, but we already use TColumnType, so we name this
/// to TTypeDesc. In future, we merge these two to one
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PTypeDesc {
    #[prost(message, repeated, tag = "1")]
    pub types: ::prost::alloc::vec::Vec<PTypeNode>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PUniqueId {
    #[prost(int64, required, tag = "1")]
    pub hi: i64,
    #[prost(int64, required, tag = "2")]
    pub lo: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PGenericType {
    #[prost(enumeration = "p_generic_type::TypeId", required, tag = "2")]
    pub id: i32,
    #[prost(message, optional, boxed, tag = "11")]
    pub list_type: ::core::option::Option<::prost::alloc::boxed::Box<PList>>,
    #[prost(message, optional, boxed, tag = "12")]
    pub map_type: ::core::option::Option<::prost::alloc::boxed::Box<PMap>>,
    #[prost(message, optional, tag = "13")]
    pub struct_type: ::core::option::Option<PStruct>,
    #[prost(message, optional, tag = "14")]
    pub decimal_type: ::core::option::Option<PDecimal>,
}
/// Nested message and enum types in `PGenericType`.
pub mod p_generic_type {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TypeId {
        Uint8 = 0,
        Uint16 = 1,
        Uint32 = 2,
        Uint64 = 3,
        Uint128 = 4,
        Uint256 = 5,
        Int8 = 6,
        Int16 = 7,
        Int32 = 8,
        Int64 = 9,
        Int128 = 10,
        Int256 = 11,
        /// map to Float32
        Float = 12,
        /// map to Float64
        Double = 13,
        Boolean = 14,
        Date = 15,
        Datetime = 16,
        Hll = 17,
        Bitmap = 18,
        List = 19,
        Map = 20,
        Struct = 21,
        String = 22,
        Decimal32 = 23,
        Decimal64 = 24,
        Decimal128 = 25,
        Bytes = 26,
        Nothing = 27,
        Datev2 = 28,
        Datetimev2 = 29,
        Fixedlengthobject = 30,
        Jsonb = 31,
        Decimal128i = 32,
        Variant = 33,
        QuantileState = 34,
        Time = 35,
        AggState = 36,
        Timev2 = 37,
        Decimal256 = 38,
        Ipv4 = 39,
        Ipv6 = 40,
        Varbinary = 41,
        Unknown = 999,
    }
    impl TypeId {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                TypeId::Uint8 => "UINT8",
                TypeId::Uint16 => "UINT16",
                TypeId::Uint32 => "UINT32",
                TypeId::Uint64 => "UINT64",
                TypeId::Uint128 => "UINT128",
                TypeId::Uint256 => "UINT256",
                TypeId::Int8 => "INT8",
                TypeId::Int16 => "INT16",
                TypeId::Int32 => "INT32",
                TypeId::Int64 => "INT64",
                TypeId::Int128 => "INT128",
                TypeId::Int256 => "INT256",
                TypeId::Float => "FLOAT",
                TypeId::Double => "DOUBLE",
                TypeId::Boolean => "BOOLEAN",
                TypeId::Date => "DATE",
                TypeId::Datetime => "DATETIME",
                TypeId::Hll => "HLL",
                TypeId::Bitmap => "BITMAP",
                TypeId::List => "LIST",
                TypeId::Map => "MAP",
                TypeId::Struct => "STRUCT",
                TypeId::String => "STRING",
                TypeId::Decimal32 => "DECIMAL32",
                TypeId::Decimal64 => "DECIMAL64",
                TypeId::Decimal128 => "DECIMAL128",
                TypeId::Bytes => "BYTES",
                TypeId::Nothing => "NOTHING",
                TypeId::Datev2 => "DATEV2",
                TypeId::Datetimev2 => "DATETIMEV2",
                TypeId::Fixedlengthobject => "FIXEDLENGTHOBJECT",
                TypeId::Jsonb => "JSONB",
                TypeId::Decimal128i => "DECIMAL128I",
                TypeId::Variant => "VARIANT",
                TypeId::QuantileState => "QUANTILE_STATE",
                TypeId::Time => "TIME",
                TypeId::AggState => "AGG_STATE",
                TypeId::Timev2 => "TIMEV2",
                TypeId::Decimal256 => "DECIMAL256",
                TypeId::Ipv4 => "IPV4",
                TypeId::Ipv6 => "IPV6",
                TypeId::Varbinary => "VARBINARY",
                TypeId::Unknown => "UNKNOWN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UINT8" => Some(Self::Uint8),
                "UINT16" => Some(Self::Uint16),
                "UINT32" => Some(Self::Uint32),
                "UINT64" => Some(Self::Uint64),
                "UINT128" => Some(Self::Uint128),
                "UINT256" => Some(Self::Uint256),
                "INT8" => Some(Self::Int8),
                "INT16" => Some(Self::Int16),
                "INT32" => Some(Self::Int32),
                "INT64" => Some(Self::Int64),
                "INT128" => Some(Self::Int128),
                "INT256" => Some(Self::Int256),
                "FLOAT" => Some(Self::Float),
                "DOUBLE" => Some(Self::Double),
                "BOOLEAN" => Some(Self::Boolean),
                "DATE" => Some(Self::Date),
                "DATETIME" => Some(Self::Datetime),
                "HLL" => Some(Self::Hll),
                "BITMAP" => Some(Self::Bitmap),
                "LIST" => Some(Self::List),
                "MAP" => Some(Self::Map),
                "STRUCT" => Some(Self::Struct),
                "STRING" => Some(Self::String),
                "DECIMAL32" => Some(Self::Decimal32),
                "DECIMAL64" => Some(Self::Decimal64),
                "DECIMAL128" => Some(Self::Decimal128),
                "BYTES" => Some(Self::Bytes),
                "NOTHING" => Some(Self::Nothing),
                "DATEV2" => Some(Self::Datev2),
                "DATETIMEV2" => Some(Self::Datetimev2),
                "FIXEDLENGTHOBJECT" => Some(Self::Fixedlengthobject),
                "JSONB" => Some(Self::Jsonb),
                "DECIMAL128I" => Some(Self::Decimal128i),
                "VARIANT" => Some(Self::Variant),
                "QUANTILE_STATE" => Some(Self::QuantileState),
                "TIME" => Some(Self::Time),
                "AGG_STATE" => Some(Self::AggState),
                "TIMEV2" => Some(Self::Timev2),
                "DECIMAL256" => Some(Self::Decimal256),
                "IPV4" => Some(Self::Ipv4),
                "IPV6" => Some(Self::Ipv6),
                "VARBINARY" => Some(Self::Varbinary),
                "UNKNOWN" => Some(Self::Unknown),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PList {
    #[prost(message, required, boxed, tag = "1")]
    pub element_type: ::prost::alloc::boxed::Box<PGenericType>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PMap {
    #[prost(message, required, boxed, tag = "1")]
    pub key_type: ::prost::alloc::boxed::Box<PGenericType>,
    #[prost(message, required, boxed, tag = "2")]
    pub value_type: ::prost::alloc::boxed::Box<PGenericType>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PField {
    #[prost(message, required, tag = "1")]
    pub r#type: PGenericType,
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub comment: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PStruct {
    #[prost(message, repeated, tag = "1")]
    pub fields: ::prost::alloc::vec::Vec<PField>,
    #[prost(string, required, tag = "2")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PDecimal {
    #[prost(uint32, required, tag = "1")]
    pub precision: u32,
    #[prost(uint32, required, tag = "2")]
    pub scale: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PDateTime {
    #[prost(int32, optional, tag = "1")]
    pub year: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub month: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub day: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub hour: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub minute: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub second: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "7")]
    pub microsecond: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PValue {
    #[prost(message, required, tag = "1")]
    pub r#type: PGenericType,
    #[prost(bool, optional, tag = "2", default = "false")]
    pub is_null: ::core::option::Option<bool>,
    #[prost(double, optional, tag = "3")]
    pub double_value: ::core::option::Option<f64>,
    #[prost(float, optional, tag = "4")]
    pub float_value: ::core::option::Option<f32>,
    #[prost(int32, optional, tag = "5")]
    pub int32_value: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "6")]
    pub int64_value: ::core::option::Option<i64>,
    #[prost(uint32, optional, tag = "7")]
    pub uint32_value: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "8")]
    pub uint64_value: ::core::option::Option<u64>,
    #[prost(bool, optional, tag = "9")]
    pub bool_value: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "10")]
    pub string_value: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes = "vec", optional, tag = "11")]
    pub bytes_value: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(message, optional, tag = "12")]
    pub datetime_value: ::core::option::Option<PDateTime>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PValues {
    #[prost(message, required, tag = "1")]
    pub r#type: PGenericType,
    #[prost(bool, optional, tag = "2", default = "false")]
    pub has_null: ::core::option::Option<bool>,
    #[prost(bool, repeated, packed = "false", tag = "3")]
    pub null_map: ::prost::alloc::vec::Vec<bool>,
    #[prost(double, repeated, packed = "false", tag = "4")]
    pub double_value: ::prost::alloc::vec::Vec<f64>,
    #[prost(float, repeated, packed = "false", tag = "5")]
    pub float_value: ::prost::alloc::vec::Vec<f32>,
    #[prost(int32, repeated, packed = "false", tag = "6")]
    pub int32_value: ::prost::alloc::vec::Vec<i32>,
    #[prost(int64, repeated, packed = "false", tag = "7")]
    pub int64_value: ::prost::alloc::vec::Vec<i64>,
    #[prost(uint32, repeated, packed = "false", tag = "8")]
    pub uint32_value: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint64, repeated, packed = "false", tag = "9")]
    pub uint64_value: ::prost::alloc::vec::Vec<u64>,
    #[prost(bool, repeated, packed = "false", tag = "10")]
    pub bool_value: ::prost::alloc::vec::Vec<bool>,
    #[prost(string, repeated, tag = "11")]
    pub string_value: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bytes = "vec", repeated, tag = "12")]
    pub bytes_value: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(message, repeated, tag = "13")]
    pub datetime_value: ::prost::alloc::vec::Vec<PDateTime>,
    #[prost(message, repeated, tag = "14")]
    pub child_element: ::prost::alloc::vec::Vec<PValues>,
    #[prost(int64, repeated, packed = "false", tag = "15")]
    pub child_offset: ::prost::alloc::vec::Vec<i64>,
}
/// this mesage may not used for now
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PFunction {
    #[prost(string, required, tag = "1")]
    pub function_name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub inputs: ::prost::alloc::vec::Vec<PGenericType>,
    #[prost(message, optional, tag = "3")]
    pub output: ::core::option::Option<PGenericType>,
    #[prost(
        enumeration = "p_function::FunctionType",
        optional,
        tag = "4",
        default = "Udf"
    )]
    pub r#type: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "5")]
    pub variadic: ::core::option::Option<bool>,
    #[prost(message, repeated, tag = "6")]
    pub properties: ::prost::alloc::vec::Vec<p_function::Property>,
}
/// Nested message and enum types in `PFunction`.
pub mod p_function {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Property {
        #[prost(string, required, tag = "1")]
        pub key: ::prost::alloc::string::String,
        #[prost(string, required, tag = "2")]
        pub val: ::prost::alloc::string::String,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FunctionType {
        Udf = 0,
        /// not supported now
        Udaf = 1,
        Udtf = 2,
    }
    impl FunctionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FunctionType::Udf => "UDF",
                FunctionType::Udaf => "UDAF",
                FunctionType::Udtf => "UDTF",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UDF" => Some(Self::Udf),
                "UDAF" => Some(Self::Udaf),
                "UDTF" => Some(Self::Udtf),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PFunctionContext {
    #[prost(bytes = "vec", optional, tag = "1")]
    pub data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// use to impl vectorization udaf
    #[prost(message, repeated, tag = "2")]
    pub args_data: ::prost::alloc::vec::Vec<PValues>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PHandShakeRequest {
    #[prost(string, optional, tag = "1")]
    pub hello: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PHandShakeResponse {
    #[prost(message, optional, tag = "1")]
    pub status: ::core::option::Option<PStatus>,
    #[prost(string, optional, tag = "2")]
    pub hello: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PNetworkAddress {
    #[prost(string, required, tag = "1")]
    pub hostname: ::prost::alloc::string::String,
    #[prost(int32, required, tag = "2")]
    pub port: i32,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PPlanFragmentCancelReason {
    /// 0 is reserved
    LimitReach = 1,
    UserCancel = 2,
    InternalError = 3,
    Timeout = 4,
    CallRpcError = 5,
    MemoryLimitExceed = 6,
}
impl PPlanFragmentCancelReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            PPlanFragmentCancelReason::LimitReach => "LIMIT_REACH",
            PPlanFragmentCancelReason::UserCancel => "USER_CANCEL",
            PPlanFragmentCancelReason::InternalError => "INTERNAL_ERROR",
            PPlanFragmentCancelReason::Timeout => "TIMEOUT",
            PPlanFragmentCancelReason::CallRpcError => "CALL_RPC_ERROR",
            PPlanFragmentCancelReason::MemoryLimitExceed => "MEMORY_LIMIT_EXCEED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LIMIT_REACH" => Some(Self::LimitReach),
            "USER_CANCEL" => Some(Self::UserCancel),
            "INTERNAL_ERROR" => Some(Self::InternalError),
            "TIMEOUT" => Some(Self::Timeout),
            "CALL_RPC_ERROR" => Some(Self::CallRpcError),
            "MEMORY_LIMIT_EXCEED" => Some(Self::MemoryLimitExceed),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PNodeStatistics {
    #[prost(int64, required, tag = "1")]
    pub node_id: i64,
    #[prost(int64, optional, tag = "2")]
    pub peak_memory_bytes: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PQueryStatistics {
    #[prost(int64, optional, tag = "1")]
    pub scan_rows: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "2")]
    pub scan_bytes: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "3")]
    pub returned_rows: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "4")]
    pub cpu_ms: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "5")]
    pub max_peak_memory_bytes: ::core::option::Option<i64>,
    #[prost(message, repeated, tag = "6")]
    pub nodes_statistics: ::prost::alloc::vec::Vec<PNodeStatistics>,
    #[prost(int64, optional, tag = "7")]
    pub scan_bytes_from_local_storage: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "8")]
    pub scan_bytes_from_remote_storage: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "9")]
    pub spill_write_bytes_to_local_storage: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "10")]
    pub spill_read_bytes_from_local_storage: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "11")]
    pub bytes_write_into_cache: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PRowBatch {
    #[prost(int32, required, tag = "1")]
    pub num_rows: i32,
    #[prost(int32, repeated, packed = "false", tag = "2")]
    pub row_tuples: ::prost::alloc::vec::Vec<i32>,
    /// Should be deprecated after v1.2.0
    #[prost(int32, repeated, packed = "false", tag = "3")]
    pub tuple_offsets: ::prost::alloc::vec::Vec<i32>,
    #[prost(bytes = "vec", required, tag = "4")]
    pub tuple_data: ::prost::alloc::vec::Vec<u8>,
    #[prost(bool, required, tag = "5")]
    pub is_compressed: bool,
    /// This is used to replace "tuple_offsets"
    #[prost(int64, repeated, packed = "false", tag = "6")]
    pub new_tuple_offsets: ::prost::alloc::vec::Vec<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PColumnMeta {
    #[prost(string, optional, tag = "1", default = "")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(
        enumeration = "p_generic_type::TypeId",
        optional,
        tag = "2",
        default = "Unknown"
    )]
    pub r#type: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "3", default = "false")]
    pub is_nullable: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "4")]
    pub decimal_param: ::core::option::Option<p_column_meta::Decimal>,
    #[prost(message, repeated, tag = "5")]
    pub children: ::prost::alloc::vec::Vec<PColumnMeta>,
    #[prost(bool, optional, tag = "6")]
    pub result_is_nullable: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "7")]
    pub function_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "8")]
    pub be_exec_version: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "9")]
    pub column_path: ::core::option::Option<segment_v2::ColumnPathInfo>,
    #[prost(int32, optional, tag = "10", default = "0")]
    pub variant_max_subcolumns_count: ::core::option::Option<i32>,
}
/// Nested message and enum types in `PColumnMeta`.
pub mod p_column_meta {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Decimal {
        #[prost(uint32, optional, tag = "1")]
        pub precision: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag = "2")]
        pub scale: ::core::option::Option<u32>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PBlock {
    #[prost(message, repeated, tag = "1")]
    pub column_metas: ::prost::alloc::vec::Vec<PColumnMeta>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub column_values: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bool, optional, tag = "3", default = "false")]
    pub compressed: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "4")]
    pub uncompressed_size: ::core::option::Option<i64>,
    #[prost(
        enumeration = "segment_v2::CompressionTypePb",
        optional,
        tag = "5",
        default = "Snappy"
    )]
    pub compression_type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6", default = "0")]
    pub be_exec_version: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ColumnMessage {
    /// ColumnPB.name
    #[prost(string, required, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// ColumnPB.type
    #[prost(string, required, tag = "2")]
    pub r#type: ::prost::alloc::string::String,
    /// ColumnPB.aggregation
    #[prost(string, required, tag = "3")]
    pub aggregation: ::prost::alloc::string::String,
    /// ColumnPB.length
    #[prost(uint32, required, tag = "4")]
    pub length: u32,
    /// ColumnPB.is_key
    #[prost(bool, required, tag = "5")]
    pub is_key: bool,
    /// ColumnPB.default_value
    #[prost(string, optional, tag = "6")]
    pub default_value: ::core::option::Option<::prost::alloc::string::String>,
    /// deprecated
    #[prost(string, optional, tag = "7")]
    pub referenced_column: ::core::option::Option<::prost::alloc::string::String>,
    /// ColumnPB.index_length
    #[prost(uint32, optional, tag = "8")]
    pub index_length: ::core::option::Option<u32>,
    /// ColumnPB.precision
    #[prost(uint32, optional, tag = "9", default = "27")]
    pub precision: ::core::option::Option<u32>,
    /// ColumnPB.frac
    #[prost(uint32, optional, tag = "10", default = "9")]
    pub frac: ::core::option::Option<u32>,
    /// ColumnPB.is_nullable
    #[prost(bool, optional, tag = "11", default = "false")]
    pub is_allow_null: ::core::option::Option<bool>,
    /// ColumnPB.unique_id
    #[prost(uint32, optional, tag = "12")]
    pub unique_id: ::core::option::Option<u32>,
    /// not used
    #[prost(uint32, repeated, packed = "false", tag = "13")]
    pub sub_column: ::prost::alloc::vec::Vec<u32>,
    /// not used
    #[prost(bool, optional, tag = "14", default = "false")]
    pub is_root_column: ::core::option::Option<bool>,
    /// is bloom filter column
    ///
    /// ColumnPB.is_bf_column
    #[prost(bool, optional, tag = "15", default = "false")]
    pub is_bf_column: ::core::option::Option<bool>,
    /// is bitmap index column
    ///
    /// ColumnPB.has_bitmap_index
    #[prost(bool, optional, tag = "16", default = "false")]
    pub has_bitmap_index: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PCounter {
    #[prost(string, required, tag = "1")]
    pub item: ::prost::alloc::string::String,
    #[prost(uint64, required, tag = "2")]
    pub count: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PTopNCounter {
    #[prost(uint32, required, tag = "1")]
    pub top_num: u32,
    #[prost(uint32, required, tag = "2")]
    pub space_expand_rate: u32,
    #[prost(message, repeated, tag = "3")]
    pub counter: ::prost::alloc::vec::Vec<PCounter>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InvertedIndexFileInfo {
    /// for inverted index v1
    #[prost(message, repeated, tag = "1")]
    pub index_info: ::prost::alloc::vec::Vec<inverted_index_file_info::IndexInfo>,
    /// for inverted index v2
    #[prost(int64, optional, tag = "2")]
    pub index_size: ::core::option::Option<i64>,
}
/// Nested message and enum types in `InvertedIndexFileInfo`.
pub mod inverted_index_file_info {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct IndexInfo {
        #[prost(int64, required, tag = "1")]
        pub index_id: i64,
        #[prost(int64, required, tag = "2", default = "-1")]
        pub index_file_size: i64,
        #[prost(string, optional, tag = "3")]
        pub index_suffix: ::core::option::Option<::prost::alloc::string::String>,
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CompressKind {
    CompressNone = 0,
    CompressLzo = 1,
    CompressLz4 = 2,
}
impl CompressKind {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            CompressKind::CompressNone => "COMPRESS_NONE",
            CompressKind::CompressLzo => "COMPRESS_LZO",
            CompressKind::CompressLz4 => "COMPRESS_LZ4",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "COMPRESS_NONE" => Some(Self::CompressNone),
            "COMPRESS_LZO" => Some(Self::CompressLzo),
            "COMPRESS_LZ4" => Some(Self::CompressLz4),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FileType {
    SegmentFile = 1,
    InvertedIndexFile = 2,
}
impl FileType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            FileType::SegmentFile => "SEGMENT_FILE",
            FileType::InvertedIndexFile => "INVERTED_INDEX_FILE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SEGMENT_FILE" => Some(Self::SegmentFile),
            "INVERTED_INDEX_FILE" => Some(Self::InvertedIndexFile),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZoneMap {
    #[prost(bytes = "vec", required, tag = "1")]
    pub min: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", required, tag = "2")]
    pub max: ::prost::alloc::vec::Vec<u8>,
    #[prost(bool, optional, tag = "3")]
    pub null_flag: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeyBoundsPb {
    #[prost(bytes = "vec", required, tag = "1")]
    pub min_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", required, tag = "2")]
    pub max_key: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SplitSchemaPb {
    /// The split fields ids
    #[prost(int64, repeated, packed = "false", tag = "1")]
    pub split_field_ids: ::prost::alloc::vec::Vec<i64>,
    /// The num of split keys, used to limit the scan range.
    #[prost(uint64, optional, tag = "2")]
    pub num_split_keys: ::core::option::Option<u64>,
}
/// ATTN: When adding or deleting fields, please update `message RowsetMetaCloudPB`
/// simultaneously and modify the conversion function in the be/src/cloud/pb_convert.{h,cpp}.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RowsetMetaPb {
    /// Deprecated. Use rowset_id_v2 instead.
    #[prost(int64, required, tag = "1")]
    pub rowset_id: i64,
    #[prost(int64, optional, tag = "2")]
    pub partition_id: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "3")]
    pub tablet_id: ::core::option::Option<i64>,
    /// only for pending rowset
    #[prost(int64, optional, tag = "4")]
    pub txn_id: ::core::option::Option<i64>,
    /// tablet id and schema hash could find tablet
    #[prost(int32, optional, tag = "5")]
    pub tablet_schema_hash: ::core::option::Option<i32>,
    #[prost(enumeration = "RowsetTypePb", optional, tag = "6")]
    pub rowset_type: ::core::option::Option<i32>,
    #[prost(enumeration = "RowsetStatePb", optional, tag = "7")]
    pub rowset_state: ::core::option::Option<i32>,
    /// only for visible rowset. For alpha rowset, it's the same as PDelta.start_version
    #[prost(int64, optional, tag = "8")]
    pub start_version: ::core::option::Option<i64>,
    /// only for visible rowset. For alpha rowset, it's the same as PDelta.end_version
    #[prost(int64, optional, tag = "9")]
    pub end_version: ::core::option::Option<i64>,
    /// only for visible rowset. For alpha rowset, it's the same as PDelta.version_hash
    #[prost(int64, optional, tag = "10")]
    pub version_hash: ::core::option::Option<i64>,
    /// total number of rows. For alpha rowset, it's calculated from segment group
    #[prost(int64, optional, tag = "11")]
    pub num_rows: ::core::option::Option<i64>,
    /// calculated by index + data
    #[prost(int64, optional, tag = "12")]
    pub total_disk_size: ::core::option::Option<i64>,
    /// calculated sum(segmentgroup.data_size)
    #[prost(int64, optional, tag = "13")]
    pub data_disk_size: ::core::option::Option<i64>,
    /// calculated sum(segmentgroup.index_size)
    #[prost(int64, optional, tag = "14")]
    pub index_disk_size: ::core::option::Option<i64>,
    /// rowset level column min/max/null statistics, not not used currently
    #[prost(message, repeated, tag = "15")]
    pub zone_maps: ::prost::alloc::vec::Vec<ZoneMap>,
    #[prost(message, optional, tag = "16")]
    pub delete_predicate: ::core::option::Option<DeletePredicatePb>,
    /// calculated from segment group
    #[prost(bool, optional, tag = "17")]
    pub empty: ::core::option::Option<bool>,
    /// only for pending rowset
    #[prost(message, optional, tag = "18")]
    pub load_id: ::core::option::Option<PUniqueId>,
    /// not set, get from olap index header msg?
    #[prost(bool, optional, tag = "19")]
    pub delete_flag: ::core::option::Option<bool>,
    /// For alpha rowset, it's the same as PDelta.creation_time
    #[prost(int64, optional, tag = "20")]
    pub creation_time: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "21")]
    pub tablet_uid: ::core::option::Option<PUniqueId>,
    /// total number of segments
    #[prost(int64, optional, tag = "22")]
    pub num_segments: ::core::option::Option<i64>,
    /// rowset id definition, it will replace required rowset id
    #[prost(string, optional, tag = "23")]
    pub rowset_id_v2: ::core::option::Option<::prost::alloc::string::String>,
    /// resource id
    #[prost(string, optional, tag = "24")]
    pub resource_id: ::core::option::Option<::prost::alloc::string::String>,
    /// latest write time
    #[prost(int64, optional, tag = "26", default = "-1")]
    pub newest_write_timestamp: ::core::option::Option<i64>,
    /// the encoded segment min/max key of segments in this rowset,
    /// ATTN: segments_key_bounds may be truncated! please refer to field `segments_key_bounds_truncated`
    /// to check if these are truncated segments key bounds
    #[prost(message, repeated, tag = "27")]
    pub segments_key_bounds: ::prost::alloc::vec::Vec<KeyBoundsPb>,
    /// tablet meta pb, for compaction
    #[prost(message, optional, tag = "28")]
    pub tablet_schema: ::core::option::Option<TabletSchemaPb>,
    /// to indicate whether the data between the segments overlap
    #[prost(
        enumeration = "SegmentsOverlapPb",
        optional,
        tag = "51",
        default = "OverlapUnknown"
    )]
    pub segments_overlap_pb: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "52", default = "0")]
    pub compaction_level: ::core::option::Option<i64>,
    /// For backup/restore, record the tablet id and rowset id of the source cluster.
    #[prost(int64, optional, tag = "53")]
    pub source_tablet_id: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "54")]
    pub source_rowset_id: ::core::option::Option<::prost::alloc::string::String>,
    /// indicate that whether the segments key bounds is truncated
    #[prost(bool, optional, tag = "55")]
    pub segments_key_bounds_truncated: ::core::option::Option<bool>,
    /// For cloud
    /// for data recycling
    #[prost(int64, optional, tag = "1000")]
    pub txn_expiration: ::core::option::Option<i64>,
    /// the field is a vector, rename it
    #[prost(int64, repeated, packed = "false", tag = "1001")]
    pub segments_file_size: ::prost::alloc::vec::Vec<i64>,
    /// index_id, schema_version -> schema
    #[prost(int64, optional, tag = "1002")]
    pub index_id: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "1003")]
    pub schema_version: ::core::option::Option<i32>,
    /// If enable_segments_file_size is false,
    /// the segments_file_size maybe is empty or error
    #[prost(bool, optional, tag = "1004")]
    pub enable_segments_file_size: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "1005")]
    pub has_variant_type_in_schema: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "1006")]
    pub enable_inverted_index_file_info: ::core::option::Option<bool>,
    #[prost(message, repeated, tag = "1007")]
    pub inverted_index_file_info: ::prost::alloc::vec::Vec<InvertedIndexFileInfo>,
    /// align to cloud rowset
    #[prost(message, optional, tag = "1008")]
    pub schema_dict_key_list: ::core::option::Option<SchemaDictKeyList>,
    /// A special field, DO NOT change it.
    #[prost(message, optional, tag = "1009")]
    pub split_schema: ::core::option::Option<SplitSchemaPb>,
    #[prost(int64, optional, tag = "1010")]
    pub visible_ts_ms: ::core::option::Option<i64>,
    /// For cluster snapshot
    #[prost(string, optional, tag = "1011")]
    pub reference_instance_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SchemaDictKeyList {
    /// save the dict keys for column pb info
    #[prost(int32, repeated, packed = "false", tag = "1")]
    pub column_dict_key_list: ::prost::alloc::vec::Vec<i32>,
    /// save the dict keys for tablet index pb info
    #[prost(int32, repeated, packed = "false", tag = "2")]
    pub index_info_dict_key_list: ::prost::alloc::vec::Vec<i32>,
    /// save the dict keys for sparse column pb info
    #[prost(int32, repeated, packed = "false", tag = "3")]
    pub sparse_column_dict_key_list: ::prost::alloc::vec::Vec<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RowsetMetaCloudPb {
    /// Deprecated. Use rowset_id_v2 instead.
    #[prost(int64, required, tag = "1")]
    pub rowset_id: i64,
    #[prost(int64, optional, tag = "2")]
    pub partition_id: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "3")]
    pub tablet_id: ::core::option::Option<i64>,
    /// only for pending rowset
    #[prost(int64, optional, tag = "4")]
    pub txn_id: ::core::option::Option<i64>,
    /// tablet id and schema hash could find tablet
    #[prost(int32, optional, tag = "5")]
    pub tablet_schema_hash: ::core::option::Option<i32>,
    #[prost(enumeration = "RowsetTypePb", optional, tag = "6")]
    pub rowset_type: ::core::option::Option<i32>,
    #[prost(enumeration = "RowsetStatePb", optional, tag = "7")]
    pub rowset_state: ::core::option::Option<i32>,
    /// only for visible rowset. For alpha rowset, it's the same as PDelta.start_version
    #[prost(int64, optional, tag = "8")]
    pub start_version: ::core::option::Option<i64>,
    /// only for visible rowset. For alpha rowset, it's the same as PDelta.end_version
    #[prost(int64, optional, tag = "9")]
    pub end_version: ::core::option::Option<i64>,
    /// only for visible rowset. For alpha rowset, it's the same as PDelta.version_hash
    #[prost(int64, optional, tag = "10")]
    pub version_hash: ::core::option::Option<i64>,
    /// total number of rows. For alpha rowset, it's calculated from segment group
    #[prost(int64, optional, tag = "11")]
    pub num_rows: ::core::option::Option<i64>,
    /// calculated by index + data
    #[prost(int64, optional, tag = "12")]
    pub total_disk_size: ::core::option::Option<i64>,
    /// calculated sum(segmentgroup.data_size)
    #[prost(int64, optional, tag = "13")]
    pub data_disk_size: ::core::option::Option<i64>,
    /// calculated sum(segmentgroup.index_size)
    #[prost(int64, optional, tag = "14")]
    pub index_disk_size: ::core::option::Option<i64>,
    /// rowset level column min/max/null statistics, not not used currently
    #[prost(message, repeated, tag = "15")]
    pub zone_maps: ::prost::alloc::vec::Vec<ZoneMap>,
    #[prost(message, optional, tag = "16")]
    pub delete_predicate: ::core::option::Option<DeletePredicatePb>,
    /// calculated from segment group
    #[prost(bool, optional, tag = "17")]
    pub empty: ::core::option::Option<bool>,
    /// only for pending rowset
    #[prost(message, optional, tag = "18")]
    pub load_id: ::core::option::Option<PUniqueId>,
    /// not set, get from olap index header msg?
    #[prost(bool, optional, tag = "19")]
    pub delete_flag: ::core::option::Option<bool>,
    /// For alpha rowset, it's the same as PDelta.creation_time
    #[prost(int64, optional, tag = "20")]
    pub creation_time: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "21")]
    pub tablet_uid: ::core::option::Option<PUniqueId>,
    /// total number of segments
    #[prost(int64, optional, tag = "22")]
    pub num_segments: ::core::option::Option<i64>,
    /// rowset id definition, it will replace required rowset id
    #[prost(string, optional, tag = "23")]
    pub rowset_id_v2: ::core::option::Option<::prost::alloc::string::String>,
    /// resource id
    #[prost(string, optional, tag = "24")]
    pub resource_id: ::core::option::Option<::prost::alloc::string::String>,
    /// latest write time
    #[prost(int64, optional, tag = "26", default = "-1")]
    pub newest_write_timestamp: ::core::option::Option<i64>,
    /// the encoded segment min/max key of segments in this rowset,
    /// ATTN: segments_key_bounds may be truncated! please refer to field `segments_key_bounds_truncated`
    /// to check if these are truncated segments key bounds
    #[prost(message, repeated, tag = "27")]
    pub segments_key_bounds: ::prost::alloc::vec::Vec<KeyBoundsPb>,
    /// tablet meta pb, for compaction
    #[prost(message, optional, tag = "28")]
    pub tablet_schema: ::core::option::Option<TabletSchemaCloudPb>,
    /// for data recycling in CLOUD_MODE
    #[prost(int64, optional, tag = "29")]
    pub txn_expiration: ::core::option::Option<i64>,
    /// to indicate whether the data between the segments overlap
    #[prost(
        enumeration = "SegmentsOverlapPb",
        optional,
        tag = "51",
        default = "OverlapUnknown"
    )]
    pub segments_overlap_pb: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "52", default = "0")]
    pub compaction_level: ::core::option::Option<i64>,
    /// For backup/restore, record the tablet id and rowset id of the source cluster.
    #[prost(int64, optional, tag = "53")]
    pub source_tablet_id: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "54")]
    pub source_rowset_id: ::core::option::Option<::prost::alloc::string::String>,
    /// indicate that whether the segments key bounds is truncated
    #[prost(bool, optional, tag = "55")]
    pub segments_key_bounds_truncated: ::core::option::Option<bool>,
    /// cloud
    /// the field is a vector, rename it
    #[prost(int64, repeated, packed = "false", tag = "100")]
    pub segments_file_size: ::prost::alloc::vec::Vec<i64>,
    /// index_id, schema_version -> schema
    #[prost(int64, optional, tag = "101")]
    pub index_id: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "102")]
    pub schema_version: ::core::option::Option<i32>,
    /// If enable_segments_file_size is false,
    /// the segments_file_size maybe is empty or error
    #[prost(bool, optional, tag = "103")]
    pub enable_segments_file_size: ::core::option::Option<bool>,
    /// extra info for variants
    #[prost(bool, optional, tag = "104")]
    pub has_variant_type_in_schema: ::core::option::Option<bool>,
    /// dict key lists for compress schema info
    #[prost(message, optional, tag = "105")]
    pub schema_dict_key_list: ::core::option::Option<SchemaDictKeyList>,
    #[prost(bool, optional, tag = "106")]
    pub enable_inverted_index_file_info: ::core::option::Option<bool>,
    #[prost(message, repeated, tag = "107")]
    pub inverted_index_file_info: ::prost::alloc::vec::Vec<InvertedIndexFileInfo>,
    /// A special field, DO NOT change it.
    #[prost(message, optional, tag = "108")]
    pub split_schema: ::core::option::Option<SplitSchemaPb>,
    #[prost(int64, optional, tag = "109")]
    pub visible_ts_ms: ::core::option::Option<i64>,
    /// For cluster snapshot
    #[prost(string, optional, tag = "110")]
    pub reference_instance_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SegmentStatisticsPb {
    #[prost(int64, optional, tag = "1")]
    pub row_num: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "2")]
    pub data_size: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "3")]
    pub index_size: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "4")]
    pub key_bounds: ::core::option::Option<KeyBoundsPb>,
}
/// kv value for reclaiming remote rowset
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoteRowsetGcPb {
    #[prost(string, required, tag = "1")]
    pub resource_id: ::prost::alloc::string::String,
    #[prost(int64, required, tag = "2")]
    pub tablet_id: i64,
    #[prost(int64, required, tag = "3")]
    pub num_segments: i64,
}
/// kv value for reclaiming all remote rowsets of tablet
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoteTabletGcPb {
    #[prost(string, repeated, tag = "1")]
    pub resource_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeletePredicatePb {
    /// This field is useless, but could not removed, not depend on it
    #[prost(int32, required, tag = "1")]
    pub version: i32,
    #[prost(string, repeated, tag = "2")]
    pub sub_predicates: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "3")]
    pub in_predicates: ::prost::alloc::vec::Vec<InPredicatePb>,
    #[prost(message, repeated, tag = "4")]
    pub sub_predicates_v2: ::prost::alloc::vec::Vec<DeleteSubPredicatePb>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSubPredicatePb {
    #[prost(int32, optional, tag = "1")]
    pub column_unique_id: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub column_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub op: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub cond_value: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InPredicatePb {
    #[prost(string, optional, tag = "1")]
    pub column_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "2")]
    pub is_not_in: ::core::option::Option<bool>,
    #[prost(string, repeated, tag = "3")]
    pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "4")]
    pub column_unique_id: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlterTabletPb {
    #[prost(enumeration = "AlterTabletState", optional, tag = "1")]
    pub alter_state: ::core::option::Option<i32>,
    #[prost(int64, required, tag = "2")]
    pub related_tablet_id: i64,
    #[prost(int32, optional, tag = "3")]
    pub related_schema_hash: ::core::option::Option<i32>,
    #[prost(enumeration = "AlterTabletType", optional, tag = "4")]
    pub alter_type: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ColumnPb {
    /// ColumnMessage.unique_id
    #[prost(int32, required, tag = "1")]
    pub unique_id: i32,
    /// ColumnMessage.name
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// ColumnMessage.type
    #[prost(string, required, tag = "3")]
    pub r#type: ::prost::alloc::string::String,
    /// ColumnMessage.is_key
    #[prost(bool, optional, tag = "4")]
    pub is_key: ::core::option::Option<bool>,
    /// ColumnMessage.aggregation
    #[prost(string, optional, tag = "5")]
    pub aggregation: ::core::option::Option<::prost::alloc::string::String>,
    /// ColumnMessage.is_allow_null
    #[prost(bool, optional, tag = "6")]
    pub is_nullable: ::core::option::Option<bool>,
    /// ColumnMessage.default_value ?
    #[prost(bytes = "vec", optional, tag = "7")]
    pub default_value: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// ColumnMessage.precision
    #[prost(int32, optional, tag = "8")]
    pub precision: ::core::option::Option<i32>,
    /// ColumnMessage.frac
    #[prost(int32, optional, tag = "9")]
    pub frac: ::core::option::Option<i32>,
    /// ColumnMessage.length
    #[prost(int32, optional, tag = "10")]
    pub length: ::core::option::Option<i32>,
    /// ColumnMessage.index_length
    #[prost(int32, optional, tag = "11")]
    pub index_length: ::core::option::Option<i32>,
    /// ColumnMessage.is_bf_column
    #[prost(bool, optional, tag = "12")]
    pub is_bf_column: ::core::option::Option<bool>,
    /// deprecated
    #[prost(int32, optional, tag = "13")]
    pub referenced_column_id: ::core::option::Option<i32>,
    /// deprecated
    #[prost(string, optional, tag = "14")]
    pub referenced_column: ::core::option::Option<::prost::alloc::string::String>,
    /// ColumnMessage.has_bitmap_index
    #[prost(bool, optional, tag = "15", default = "false")]
    pub has_bitmap_index: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "16", default = "true")]
    pub visible: ::core::option::Option<bool>,
    #[prost(message, repeated, tag = "17")]
    pub children_columns: ::prost::alloc::vec::Vec<ColumnPb>,
    #[prost(string, repeated, tag = "18")]
    pub children_column_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "19")]
    pub result_is_nullable: ::core::option::Option<bool>,
    /// persist info for PathInData that represents path in document, e.g. JSON.
    #[prost(message, optional, tag = "20")]
    pub column_path_info: ::core::option::Option<segment_v2::ColumnPathInfo>,
    /// sparse column within a variant column
    #[prost(message, repeated, tag = "21")]
    pub sparse_columns: ::prost::alloc::vec::Vec<ColumnPb>,
    #[prost(bool, optional, tag = "22")]
    pub is_auto_increment: ::core::option::Option<bool>,
    /// only reference by variant sparse columns
    #[prost(int32, optional, tag = "23")]
    pub parent_unique_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "24")]
    pub be_exec_version: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "25", default = "0")]
    pub variant_max_subcolumns_count: ::core::option::Option<i32>,
    #[prost(enumeration = "PatternTypePb", optional, tag = "26")]
    pub pattern_type: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "27", default = "false")]
    pub variant_enable_typed_paths_to_sparse: ::core::option::Option<bool>,
    /// this field is only used during flexible partial update load
    #[prost(bool, optional, tag = "28", default = "false")]
    pub is_on_update_current_timestamp: ::core::option::Option<bool>,
    /// variant_max_sparse_column_statistics_size
    #[prost(int32, optional, tag = "29", default = "10000")]
    pub variant_max_sparse_column_statistics_size: ::core::option::Option<i32>,
    /// number of buckets used to store sparse map
    #[prost(int32, optional, tag = "30")]
    pub variant_sparse_hash_shard_count: ::core::option::Option<i32>,
}
/// Dictionary of Schema info, to reduce TabletSchemaCloudPB fdb kv size
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SchemaCloudDictionary {
    #[prost(map = "int32, message", tag = "1")]
    pub column_dict: ::std::collections::HashMap<i32, ColumnPb>,
    /// monotonic increasing
    #[prost(int64, optional, tag = "2")]
    pub current_column_dict_id: ::core::option::Option<i64>,
    #[prost(map = "int32, message", tag = "3")]
    pub index_dict: ::std::collections::HashMap<i32, TabletIndexPb>,
    /// monotonic increasing
    #[prost(int64, optional, tag = "4")]
    pub current_index_dict_id: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TabletIndexPb {
    #[prost(int64, optional, tag = "1")]
    pub index_id: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "2")]
    pub index_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "IndexType", optional, tag = "3")]
    pub index_type: ::core::option::Option<i32>,
    #[prost(int32, repeated, packed = "false", tag = "4")]
    pub col_unique_id: ::prost::alloc::vec::Vec<i32>,
    #[prost(map = "string, string", tag = "5")]
    pub properties: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "6")]
    pub index_suffix_name: ::core::option::Option<::prost::alloc::string::String>,
}
/// ATTN: When adding or deleting fields, please update `message TabletSchemaCloudPB`
/// simultaneously and modify the conversion function in the be/src/cloud/pb_convert.{h,cpp}.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TabletSchemaPb {
    /// OLAPHeaderMessage.keys_type
    #[prost(enumeration = "KeysType", optional, tag = "1")]
    pub keys_type: ::core::option::Option<i32>,
    /// OLAPHeaderMessage.column
    #[prost(message, repeated, tag = "2")]
    pub column: ::prost::alloc::vec::Vec<ColumnPb>,
    /// OLAPHeaderMessage.num_short_key_fields
    #[prost(int32, optional, tag = "3")]
    pub num_short_key_columns: ::core::option::Option<i32>,
    /// OLAPHeaderMessage.num_rows_per_data_block
    #[prost(int32, optional, tag = "4")]
    pub num_rows_per_row_block: ::core::option::Option<i32>,
    /// OLAPHeaderMessage.compress_kind
    #[prost(enumeration = "CompressKind", optional, tag = "5")]
    pub compress_kind: ::core::option::Option<i32>,
    /// OLAPHeaderMessage.bf_fpp
    #[prost(double, optional, tag = "6")]
    pub bf_fpp: ::core::option::Option<f64>,
    /// OLAPHeaderMessage.next_column_unique_id
    #[prost(uint32, optional, tag = "7")]
    pub next_column_unique_id: ::core::option::Option<u32>,
    /// FIXME(gavin): deprecate and remove in the future
    #[prost(bool, optional, tag = "8", default = "false")]
    pub is_in_memory: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "9", default = "-1")]
    pub delete_sign_idx: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "10", default = "-1")]
    pub sequence_col_idx: ::core::option::Option<i32>,
    #[prost(enumeration = "SortType", optional, tag = "11")]
    pub sort_type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "12")]
    pub sort_col_num: ::core::option::Option<i32>,
    #[prost(
        enumeration = "segment_v2::CompressionTypePb",
        optional,
        tag = "13",
        default = "Lz4f"
    )]
    pub compression_type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "14")]
    pub schema_version: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "15", default = "false")]
    pub disable_auto_compaction: ::core::option::Option<bool>,
    #[prost(message, repeated, tag = "16")]
    pub index: ::prost::alloc::vec::Vec<TabletIndexPb>,
    #[prost(int32, optional, tag = "17", default = "-1")]
    pub version_col_idx: ::core::option::Option<i32>,
    /// store tuplerow oriented column
    #[prost(bool, optional, tag = "18", default = "false")]
    pub store_row_column: ::core::option::Option<bool>,
    /// deprecated
    #[prost(bool, optional, tag = "19", default = "false")]
    pub is_dynamic_schema: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "22", default = "false")]
    pub enable_single_replica_compaction: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "23", default = "false")]
    pub skip_write_index_on_load: ::core::option::Option<bool>,
    #[prost(int32, repeated, packed = "false", tag = "24")]
    pub cluster_key_uids: ::prost::alloc::vec::Vec<i32>,
    #[prost(
        enumeration = "InvertedIndexStorageFormatPb",
        optional,
        tag = "25",
        default = "V1"
    )]
    pub inverted_index_storage_format: ::core::option::Option<i32>,
    /// column unique ids for row store columns
    #[prost(int32, repeated, packed = "false", tag = "26")]
    pub row_store_column_unique_ids: ::prost::alloc::vec::Vec<i32>,
    #[prost(int64, optional, tag = "27", default = "16384")]
    pub row_store_page_size: ::core::option::Option<i64>,
    #[prost(bool, optional, tag = "28", default = "false")]
    pub enable_variant_flatten_nested: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "29", default = "-1")]
    pub skip_bitmap_col_idx: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "30", default = "65536")]
    pub storage_page_size: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "31", default = "262144")]
    pub storage_dict_page_size: ::core::option::Option<i64>,
    /// A special field, DO NOT change it.
    #[prost(message, optional, tag = "1000")]
    pub split_schema: ::core::option::Option<SplitSchemaPb>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TabletSchemaCloudPb {
    /// OLAPHeaderMessage.keys_type
    #[prost(enumeration = "KeysType", optional, tag = "1")]
    pub keys_type: ::core::option::Option<i32>,
    /// OLAPHeaderMessage.column
    #[prost(message, repeated, tag = "2")]
    pub column: ::prost::alloc::vec::Vec<ColumnPb>,
    /// OLAPHeaderMessage.num_short_key_fields
    #[prost(int32, optional, tag = "3")]
    pub num_short_key_columns: ::core::option::Option<i32>,
    /// OLAPHeaderMessage.num_rows_per_data_block
    #[prost(int32, optional, tag = "4")]
    pub num_rows_per_row_block: ::core::option::Option<i32>,
    /// OLAPHeaderMessage.compress_kind
    #[prost(enumeration = "CompressKind", optional, tag = "5")]
    pub compress_kind: ::core::option::Option<i32>,
    /// OLAPHeaderMessage.bf_fpp
    #[prost(double, optional, tag = "6")]
    pub bf_fpp: ::core::option::Option<f64>,
    /// OLAPHeaderMessage.next_column_unique_id
    #[prost(uint32, optional, tag = "7")]
    pub next_column_unique_id: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "8", default = "-1")]
    pub delete_sign_idx: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "9", default = "-1")]
    pub sequence_col_idx: ::core::option::Option<i32>,
    #[prost(enumeration = "SortType", optional, tag = "10")]
    pub sort_type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "11")]
    pub sort_col_num: ::core::option::Option<i32>,
    #[prost(
        enumeration = "segment_v2::CompressionTypePb",
        optional,
        tag = "12",
        default = "Lz4f"
    )]
    pub compression_type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "13")]
    pub schema_version: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "14", default = "false")]
    pub disable_auto_compaction: ::core::option::Option<bool>,
    #[prost(message, repeated, tag = "15")]
    pub index: ::prost::alloc::vec::Vec<TabletIndexPb>,
    #[prost(int32, optional, tag = "16", default = "-1")]
    pub version_col_idx: ::core::option::Option<i32>,
    /// store tuplerow oriented column
    #[prost(bool, optional, tag = "18", default = "false")]
    pub store_row_column: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "22", default = "false")]
    pub enable_single_replica_compaction: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "23", default = "false")]
    pub skip_write_index_on_load: ::core::option::Option<bool>,
    #[prost(int32, repeated, packed = "false", tag = "24")]
    pub cluster_key_uids: ::prost::alloc::vec::Vec<i32>,
    #[prost(
        enumeration = "InvertedIndexStorageFormatPb",
        optional,
        tag = "25",
        default = "V1"
    )]
    pub inverted_index_storage_format: ::core::option::Option<i32>,
    /// column unique ids for row store columns
    #[prost(int32, repeated, packed = "false", tag = "26")]
    pub row_store_column_unique_ids: ::prost::alloc::vec::Vec<i32>,
    #[prost(int64, optional, tag = "27", default = "16384")]
    pub row_store_page_size: ::core::option::Option<i64>,
    #[prost(bool, optional, tag = "29", default = "false")]
    pub enable_variant_flatten_nested: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "30", default = "-1")]
    pub skip_bitmap_col_idx: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "31", default = "65536")]
    pub storage_page_size: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "32", default = "262144")]
    pub storage_dict_page_size: ::core::option::Option<i64>,
    #[prost(bool, optional, tag = "100", default = "false")]
    pub is_dynamic_schema: ::core::option::Option<bool>,
    /// FIXME(gavin): deprecate and remove in the future
    ///
    /// unused, just keep align to TabletSchemaPB
    #[prost(bool, optional, tag = "200", default = "false")]
    pub is_in_memory: ::core::option::Option<bool>,
    /// A special field, DO NOT change it.
    #[prost(message, optional, tag = "1000")]
    pub split_schema: ::core::option::Option<SplitSchemaPb>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct S3StorageParamPb {
    #[prost(string, optional, tag = "1")]
    pub s3_endpoint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub s3_region: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub s3_ak: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub s3_sk: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "5", default = "50")]
    pub s3_max_conn: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6", default = "3000")]
    pub s3_request_timeout_ms: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "7", default = "1000")]
    pub s3_conn_timeout_ms: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "8")]
    pub root_path: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BinlogConfigPb {
    #[prost(bool, optional, tag = "1")]
    pub enable: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "2")]
    pub ttl_seconds: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "3")]
    pub max_bytes: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "4")]
    pub max_history_nums: ::core::option::Option<i64>,
}
/// ATTN: When adding or deleting fields, please update `message TabletMetaCloudPB`
/// simultaneously and modify the conversion function in the be/src/cloud/pb_convert.{h,cpp}.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TabletMetaPb {
    /// ?
    #[prost(int64, optional, tag = "1")]
    pub table_id: ::core::option::Option<i64>,
    /// ?
    #[prost(int64, optional, tag = "2")]
    pub partition_id: ::core::option::Option<i64>,
    /// OlapHeaderMessage.tablet_id
    #[prost(int64, optional, tag = "3")]
    pub tablet_id: ::core::option::Option<i64>,
    /// OlapHeaderMessage.schema_hash
    #[prost(int32, optional, tag = "4")]
    pub schema_hash: ::core::option::Option<i32>,
    /// OlapHeaderMessage.shard
    #[prost(int32, optional, tag = "5")]
    pub shard_id: ::core::option::Option<i32>,
    /// OlapHeaderMessage.creation_time
    #[prost(int64, optional, tag = "6")]
    pub creation_time: ::core::option::Option<i64>,
    /// OlapHeaderMessage.cumulative_layer_point
    #[prost(int64, optional, tag = "7")]
    pub cumulative_layer_point: ::core::option::Option<i64>,
    #[prost(enumeration = "TabletStatePb", optional, tag = "8")]
    pub tablet_state: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "9")]
    pub schema: ::core::option::Option<TabletSchemaPb>,
    #[prost(message, repeated, tag = "10")]
    pub rs_metas: ::prost::alloc::vec::Vec<RowsetMetaPb>,
    /// @Deprecated
    #[prost(message, repeated, tag = "11")]
    pub inc_rs_metas: ::prost::alloc::vec::Vec<RowsetMetaPb>,
    #[prost(message, optional, tag = "12")]
    pub alter_task: ::core::option::Option<AlterTabletPb>,
    /// if true, this tablet will not do compaction,
    /// and does not create init version
    ///
    /// OlapHeaderMessage.in_restore_mode
    #[prost(bool, optional, tag = "13", default = "false")]
    pub in_restore_mode: ::core::option::Option<bool>,
    /// a uniqued id to identified tablet with same tablet_id and schema hash
    #[prost(message, optional, tag = "14")]
    pub tablet_uid: ::core::option::Option<PUniqueId>,
    #[prost(int64, optional, tag = "15")]
    pub end_rowset_id: ::core::option::Option<i64>,
    #[prost(enumeration = "RowsetTypePb", optional, tag = "16")]
    pub preferred_rowset_type: ::core::option::Option<i32>,
    #[prost(enumeration = "TabletTypePb", optional, tag = "17")]
    pub tablet_type: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "18")]
    pub stale_rs_metas: ::prost::alloc::vec::Vec<RowsetMetaPb>,
    /// optional StorageMediumPB storage_medium = 19 \[default = HDD\];
    /// optional string remote_storage_name = 20;
    #[prost(int64, optional, tag = "21", default = "0")]
    pub replica_id: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "23")]
    pub delete_bitmap: ::core::option::Option<DeleteBitmapPb>,
    /// Use primary key index to speed up tabel unique key model
    #[prost(bool, optional, tag = "24", default = "false")]
    pub enable_unique_key_merge_on_write: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "25")]
    pub storage_policy_id: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "26")]
    pub cooldown_meta_id: ::core::option::Option<PUniqueId>,
    #[prost(message, optional, tag = "27")]
    pub binlog_config: ::core::option::Option<BinlogConfigPb>,
    #[prost(string, optional, tag = "28", default = "size_based")]
    pub compaction_policy: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "29", default = "1024")]
    pub time_series_compaction_goal_size_mbytes: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "30", default = "2000")]
    pub time_series_compaction_file_count_threshold: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "31", default = "3600")]
    pub time_series_compaction_time_threshold_seconds: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "32", default = "5")]
    pub time_series_compaction_empty_rowsets_threshold: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "33", default = "1")]
    pub time_series_compaction_level_threshold: ::core::option::Option<i64>,
    #[prost(enumeration = "EncryptionAlgorithmPb", optional, tag = "34")]
    pub encryption_algorithm: ::core::option::Option<i32>,
    /// For cloud
    #[prost(int64, optional, tag = "1000")]
    pub index_id: ::core::option::Option<i64>,
    #[prost(bool, optional, tag = "1001")]
    pub is_in_memory: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "1002")]
    pub is_persistent: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "1003")]
    pub table_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "1004")]
    pub ttl_seconds: ::core::option::Option<i64>,
    /// index_id, schema_version -> schema
    #[prost(int32, optional, tag = "1005")]
    pub schema_version: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TabletMetaCloudPb {
    /// ?
    #[prost(int64, optional, tag = "1")]
    pub table_id: ::core::option::Option<i64>,
    /// ?
    #[prost(int64, optional, tag = "2")]
    pub partition_id: ::core::option::Option<i64>,
    /// OlapHeaderMessage.tablet_id
    #[prost(int64, optional, tag = "3")]
    pub tablet_id: ::core::option::Option<i64>,
    /// OlapHeaderMessage.schema_hash
    #[prost(int32, optional, tag = "4")]
    pub schema_hash: ::core::option::Option<i32>,
    /// OlapHeaderMessage.shard
    #[prost(int32, optional, tag = "5")]
    pub shard_id: ::core::option::Option<i32>,
    /// OlapHeaderMessage.creation_time
    #[prost(int64, optional, tag = "6")]
    pub creation_time: ::core::option::Option<i64>,
    /// OlapHeaderMessage.cumulative_layer_point
    #[prost(int64, optional, tag = "7")]
    pub cumulative_layer_point: ::core::option::Option<i64>,
    #[prost(enumeration = "TabletStatePb", optional, tag = "8")]
    pub tablet_state: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "9")]
    pub schema: ::core::option::Option<TabletSchemaCloudPb>,
    #[prost(message, repeated, tag = "10")]
    pub rs_metas: ::prost::alloc::vec::Vec<RowsetMetaCloudPb>,
    /// @Deprecated
    #[prost(message, repeated, tag = "11")]
    pub inc_rs_metas: ::prost::alloc::vec::Vec<RowsetMetaCloudPb>,
    #[prost(message, optional, tag = "12")]
    pub alter_task: ::core::option::Option<AlterTabletPb>,
    /// if true, this tablet will not do compaction,
    /// and does not create init version
    ///
    /// OlapHeaderMessage.in_restore_mode
    #[prost(bool, optional, tag = "13", default = "false")]
    pub in_restore_mode: ::core::option::Option<bool>,
    /// a uniqued id to identified tablet with same tablet_id and schema hash
    #[prost(message, optional, tag = "14")]
    pub tablet_uid: ::core::option::Option<PUniqueId>,
    #[prost(int64, optional, tag = "15")]
    pub end_rowset_id: ::core::option::Option<i64>,
    #[prost(enumeration = "RowsetTypePb", optional, tag = "16")]
    pub preferred_rowset_type: ::core::option::Option<i32>,
    #[prost(enumeration = "TabletTypePb", optional, tag = "17")]
    pub tablet_type: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "18")]
    pub stale_rs_metas: ::prost::alloc::vec::Vec<RowsetMetaCloudPb>,
    /// optional StorageMediumPB storage_medium = 19 \[default = HDD\];
    /// optional string remote_storage_name = 20;
    #[prost(int64, optional, tag = "21", default = "0")]
    pub replica_id: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "23")]
    pub delete_bitmap: ::core::option::Option<DeleteBitmapPb>,
    /// Use primary key index to speed up tabel unique key model
    #[prost(bool, optional, tag = "24", default = "false")]
    pub enable_unique_key_merge_on_write: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "25")]
    pub index_id: ::core::option::Option<i64>,
    #[prost(bool, optional, tag = "26", default = "false")]
    pub is_in_memory: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "27", default = "false")]
    pub is_persistent: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "28")]
    pub storage_policy_id: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "29")]
    pub cooldown_meta_id: ::core::option::Option<PUniqueId>,
    #[prost(message, optional, tag = "30")]
    pub binlog_config: ::core::option::Option<BinlogConfigPb>,
    #[prost(string, optional, tag = "31", default = "size_based")]
    pub compaction_policy: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "32", default = "1024")]
    pub time_series_compaction_goal_size_mbytes: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "33", default = "2000")]
    pub time_series_compaction_file_count_threshold: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "34", default = "3600")]
    pub time_series_compaction_time_threshold_seconds: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "37", default = "5")]
    pub time_series_compaction_empty_rowsets_threshold: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "38", default = "1")]
    pub time_series_compaction_level_threshold: ::core::option::Option<i64>,
    #[prost(enumeration = "EncryptionAlgorithmPb", optional, tag = "39")]
    pub encryption_algorithm: ::core::option::Option<i32>,
    /// Use for selectdb-cloud
    #[prost(string, optional, tag = "101")]
    pub table_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "102")]
    pub ttl_seconds: ::core::option::Option<i64>,
    /// index_id, schema_version -> schema
    #[prost(int32, optional, tag = "103")]
    pub schema_version: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OlapRawDeltaHeaderMessage {
    #[prost(int32, required, tag = "2")]
    pub schema_hash: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteBitmapPb {
    #[prost(string, repeated, tag = "1")]
    pub rowset_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(uint32, repeated, packed = "false", tag = "2")]
    pub segment_ids: ::prost::alloc::vec::Vec<u32>,
    #[prost(int64, repeated, packed = "false", tag = "3")]
    pub versions: ::prost::alloc::vec::Vec<i64>,
    /// Serialized roaring bitmaps indexed with {rowset_id, segment_id, version}
    #[prost(bytes = "vec", repeated, tag = "4")]
    pub segment_delete_bitmaps: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BinlogMetaEntryPb {
    #[prost(int64, optional, tag = "1")]
    pub version: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "2")]
    pub tablet_id: ::core::option::Option<i64>,
    /// Deprecated use rowset_id_v2 instead
    #[prost(int64, optional, tag = "3")]
    pub rowset_id: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "4")]
    pub num_segments: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "5")]
    pub creation_time: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "6")]
    pub rowset_id_v2: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PendingPublishInfoPb {
    #[prost(int64, optional, tag = "1")]
    pub partition_id: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "2")]
    pub transaction_id: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RowsetBinlogMetasPb {
    #[prost(message, repeated, tag = "1")]
    pub rowset_binlog_metas: ::prost::alloc::vec::Vec<
        rowset_binlog_metas_pb::RowsetBinlogMetaPb,
    >,
}
/// Nested message and enum types in `RowsetBinlogMetasPB`.
pub mod rowset_binlog_metas_pb {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RowsetBinlogMetaPb {
        #[prost(string, optional, tag = "1")]
        pub rowset_id: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(int64, optional, tag = "2")]
        pub version: ::core::option::Option<i64>,
        #[prost(int64, optional, tag = "3")]
        pub num_segments: ::core::option::Option<i64>,
        #[prost(string, optional, tag = "4")]
        pub meta_key: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bytes = "vec", optional, tag = "5")]
        pub meta: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        #[prost(string, optional, tag = "6")]
        pub data_key: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bytes = "vec", optional, tag = "7")]
        pub data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PartialUpdateInfoPb {
    /// deprecated
    #[prost(bool, optional, tag = "1", default = "false")]
    pub is_partial_update: ::core::option::Option<bool>,
    #[prost(string, repeated, tag = "2")]
    pub partial_update_input_columns: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[prost(uint32, repeated, packed = "false", tag = "3")]
    pub missing_cids: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, packed = "false", tag = "4")]
    pub update_cids: ::prost::alloc::vec::Vec<u32>,
    #[prost(bool, optional, tag = "5", default = "false")]
    pub can_insert_new_rows_in_partial_update: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "6", default = "false")]
    pub is_strict_mode: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "7", default = "0")]
    pub timestamp_ms: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "8")]
    pub timezone: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "9", default = "false")]
    pub is_input_columns_contains_auto_inc_column: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "10", default = "false")]
    pub is_schema_contains_auto_inc_column: ::core::option::Option<bool>,
    #[prost(string, repeated, tag = "11")]
    pub default_values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "12", default = "-1")]
    pub max_version_in_flush_phase: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "13", default = "0")]
    pub nano_seconds: ::core::option::Option<i32>,
    #[prost(
        enumeration = "UniqueKeyUpdateModePb",
        optional,
        tag = "14",
        default = "Upsert"
    )]
    pub partial_update_mode: ::core::option::Option<i32>,
    #[prost(
        enumeration = "PartialUpdateNewRowPolicyPb",
        optional,
        tag = "15",
        default = "Append"
    )]
    pub partial_update_new_key_policy: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileEncryptionInfoPb {
    #[prost(message, optional, tag = "1")]
    pub data_key_info: ::core::option::Option<EncryptionKeyPb>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub data_iv_nonce: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EncryptionKeyPb {
    #[prost(string, optional, tag = "1")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "2")]
    pub version: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "3")]
    pub parent_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "4")]
    pub parent_version: ::core::option::Option<i32>,
    #[prost(enumeration = "EncryptionKeyTypePb", optional, tag = "5")]
    pub r#type: ::core::option::Option<i32>,
    #[prost(enumeration = "EncryptionAlgorithmPb", optional, tag = "6")]
    pub algorithm: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "7")]
    pub ciphertext_base64: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes = "vec", optional, tag = "8")]
    pub plaintext: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(string, optional, tag = "9")]
    pub iv_base64: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "10")]
    pub crc32: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "11")]
    pub ctime: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "12")]
    pub mtime: ::core::option::Option<i64>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RowsetTypePb {
    /// doris original column storage format
    AlphaRowset = 0,
    /// new column storage format
    BetaRowset = 1,
}
impl RowsetTypePb {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            RowsetTypePb::AlphaRowset => "ALPHA_ROWSET",
            RowsetTypePb::BetaRowset => "BETA_ROWSET",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ALPHA_ROWSET" => Some(Self::AlphaRowset),
            "BETA_ROWSET" => Some(Self::BetaRowset),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RowsetStatePb {
    /// Rowset is being written
    Prepared = 0,
    /// Rowset writting is completed, but the user is not yet visible
    /// For rowset in this state, BE cannot determine whether to delete it by itself, it must be instructed by FE
    Committed = 1,
    /// Rowset is already visible to the user
    Visible = 2,
    /// Rowset is partial updated, the recycler should use list+delete to recycle segments.
    BeginPartialUpdate = 10000,
}
impl RowsetStatePb {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            RowsetStatePb::Prepared => "PREPARED",
            RowsetStatePb::Committed => "COMMITTED",
            RowsetStatePb::Visible => "VISIBLE",
            RowsetStatePb::BeginPartialUpdate => "BEGIN_PARTIAL_UPDATE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PREPARED" => Some(Self::Prepared),
            "COMMITTED" => Some(Self::Committed),
            "VISIBLE" => Some(Self::Visible),
            "BEGIN_PARTIAL_UPDATE" => Some(Self::BeginPartialUpdate),
            _ => None,
        }
    }
}
/// indicate whether date between segments of a rowset is overlappinng
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SegmentsOverlapPb {
    /// this enum is added since Doris v0.11, so previous rowset's segment is unknown
    OverlapUnknown = 0,
    Overlapping = 1,
    Nonoverlapping = 2,
}
impl SegmentsOverlapPb {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            SegmentsOverlapPb::OverlapUnknown => "OVERLAP_UNKNOWN",
            SegmentsOverlapPb::Overlapping => "OVERLAPPING",
            SegmentsOverlapPb::Nonoverlapping => "NONOVERLAPPING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OVERLAP_UNKNOWN" => Some(Self::OverlapUnknown),
            "OVERLAPPING" => Some(Self::Overlapping),
            "NONOVERLAPPING" => Some(Self::Nonoverlapping),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DataFileType {
    /// Deprecated. Only columnar-wise format is supported.
    OlapDataFile = 0,
    ColumnOrientedFile = 1,
}
impl DataFileType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            DataFileType::OlapDataFile => "OLAP_DATA_FILE",
            DataFileType::ColumnOrientedFile => "COLUMN_ORIENTED_FILE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OLAP_DATA_FILE" => Some(Self::OlapDataFile),
            "COLUMN_ORIENTED_FILE" => Some(Self::ColumnOrientedFile),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum KeysType {
    DupKeys = 0,
    UniqueKeys = 1,
    AggKeys = 2,
}
impl KeysType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            KeysType::DupKeys => "DUP_KEYS",
            KeysType::UniqueKeys => "UNIQUE_KEYS",
            KeysType::AggKeys => "AGG_KEYS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DUP_KEYS" => Some(Self::DupKeys),
            "UNIQUE_KEYS" => Some(Self::UniqueKeys),
            "AGG_KEYS" => Some(Self::AggKeys),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AlterTabletState {
    AlterPrepared = 0,
    AlterRunning = 1,
    AlterFinished = 2,
    AlterFailed = 3,
}
impl AlterTabletState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            AlterTabletState::AlterPrepared => "ALTER_PREPARED",
            AlterTabletState::AlterRunning => "ALTER_RUNNING",
            AlterTabletState::AlterFinished => "ALTER_FINISHED",
            AlterTabletState::AlterFailed => "ALTER_FAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ALTER_PREPARED" => Some(Self::AlterPrepared),
            "ALTER_RUNNING" => Some(Self::AlterRunning),
            "ALTER_FINISHED" => Some(Self::AlterFinished),
            "ALTER_FAILED" => Some(Self::AlterFailed),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AlterTabletType {
    SchemaChange = 1,
    Rollup = 2,
    Migration = 3,
}
impl AlterTabletType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            AlterTabletType::SchemaChange => "SCHEMA_CHANGE",
            AlterTabletType::Rollup => "ROLLUP",
            AlterTabletType::Migration => "MIGRATION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SCHEMA_CHANGE" => Some(Self::SchemaChange),
            "ROLLUP" => Some(Self::Rollup),
            "MIGRATION" => Some(Self::Migration),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PatternTypePb {
    MatchName = 1,
    MatchNameGlob = 2,
}
impl PatternTypePb {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            PatternTypePb::MatchName => "MATCH_NAME",
            PatternTypePb::MatchNameGlob => "MATCH_NAME_GLOB",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MATCH_NAME" => Some(Self::MatchName),
            "MATCH_NAME_GLOB" => Some(Self::MatchNameGlob),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IndexType {
    Bitmap = 0,
    Inverted = 1,
    Bloomfilter = 2,
    NgramBf = 3,
    Ann = 4,
}
impl IndexType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            IndexType::Bitmap => "BITMAP",
            IndexType::Inverted => "INVERTED",
            IndexType::Bloomfilter => "BLOOMFILTER",
            IndexType::NgramBf => "NGRAM_BF",
            IndexType::Ann => "ANN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BITMAP" => Some(Self::Bitmap),
            "INVERTED" => Some(Self::Inverted),
            "BLOOMFILTER" => Some(Self::Bloomfilter),
            "NGRAM_BF" => Some(Self::NgramBf),
            "ANN" => Some(Self::Ann),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum InvertedIndexStorageFormatPb {
    V1 = 0,
    V2 = 1,
    V3 = 2,
}
impl InvertedIndexStorageFormatPb {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            InvertedIndexStorageFormatPb::V1 => "V1",
            InvertedIndexStorageFormatPb::V2 => "V2",
            InvertedIndexStorageFormatPb::V3 => "V3",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "V1" => Some(Self::V1),
            "V2" => Some(Self::V2),
            "V3" => Some(Self::V3),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SortType {
    Lexical = 0,
    Zorder = 1,
}
impl SortType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            SortType::Lexical => "LEXICAL",
            SortType::Zorder => "ZORDER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LEXICAL" => Some(Self::Lexical),
            "ZORDER" => Some(Self::Zorder),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UniqueKeyUpdateModePb {
    Upsert = 0,
    UpdateFixedColumns = 1,
    UpdateFlexibleColumns = 2,
}
impl UniqueKeyUpdateModePb {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            UniqueKeyUpdateModePb::Upsert => "UPSERT",
            UniqueKeyUpdateModePb::UpdateFixedColumns => "UPDATE_FIXED_COLUMNS",
            UniqueKeyUpdateModePb::UpdateFlexibleColumns => "UPDATE_FLEXIBLE_COLUMNS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UPSERT" => Some(Self::Upsert),
            "UPDATE_FIXED_COLUMNS" => Some(Self::UpdateFixedColumns),
            "UPDATE_FLEXIBLE_COLUMNS" => Some(Self::UpdateFlexibleColumns),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TabletStatePb {
    /// under alter table, rollup, clone
    PbNotready = 0,
    PbRunning = 1,
    PbTombstoned = 2,
    PbStopped = 3,
    PbShutdown = 4,
}
impl TabletStatePb {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            TabletStatePb::PbNotready => "PB_NOTREADY",
            TabletStatePb::PbRunning => "PB_RUNNING",
            TabletStatePb::PbTombstoned => "PB_TOMBSTONED",
            TabletStatePb::PbStopped => "PB_STOPPED",
            TabletStatePb::PbShutdown => "PB_SHUTDOWN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PB_NOTREADY" => Some(Self::PbNotready),
            "PB_RUNNING" => Some(Self::PbRunning),
            "PB_TOMBSTONED" => Some(Self::PbTombstoned),
            "PB_STOPPED" => Some(Self::PbStopped),
            "PB_SHUTDOWN" => Some(Self::PbShutdown),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TabletTypePb {
    TabletTypeDisk = 0,
    TabletTypeMemory = 1,
}
impl TabletTypePb {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            TabletTypePb::TabletTypeDisk => "TABLET_TYPE_DISK",
            TabletTypePb::TabletTypeMemory => "TABLET_TYPE_MEMORY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TABLET_TYPE_DISK" => Some(Self::TabletTypeDisk),
            "TABLET_TYPE_MEMORY" => Some(Self::TabletTypeMemory),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum StorageMediumPb {
    Hdd = 0,
    Ssd = 1,
    S3 = 2,
    RemoteCache = 99,
}
impl StorageMediumPb {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            StorageMediumPb::Hdd => "HDD",
            StorageMediumPb::Ssd => "SSD",
            StorageMediumPb::S3 => "S3",
            StorageMediumPb::RemoteCache => "REMOTE_CACHE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "HDD" => Some(Self::Hdd),
            "SSD" => Some(Self::Ssd),
            "S3" => Some(Self::S3),
            "REMOTE_CACHE" => Some(Self::RemoteCache),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PartialUpdateNewRowPolicyPb {
    Append = 0,
    Error = 1,
}
impl PartialUpdateNewRowPolicyPb {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            PartialUpdateNewRowPolicyPb::Append => "APPEND",
            PartialUpdateNewRowPolicyPb::Error => "ERROR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "APPEND" => Some(Self::Append),
            "ERROR" => Some(Self::Error),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EncryptionKeyTypePb {
    MasterKey = 0,
    DataKey = 1,
}
impl EncryptionKeyTypePb {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            EncryptionKeyTypePb::MasterKey => "MASTER_KEY",
            EncryptionKeyTypePb::DataKey => "DATA_KEY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MASTER_KEY" => Some(Self::MasterKey),
            "DATA_KEY" => Some(Self::DataKey),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EncryptionAlgorithmPb {
    Plaintext = 0,
    Aes256Ctr = 1,
    Sm4128Ctr = 2,
}
impl EncryptionAlgorithmPb {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            EncryptionAlgorithmPb::Plaintext => "PLAINTEXT",
            EncryptionAlgorithmPb::Aes256Ctr => "AES_256_CTR",
            EncryptionAlgorithmPb::Sm4128Ctr => "SM4_128_CTR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PLAINTEXT" => Some(Self::Plaintext),
            "AES_256_CTR" => Some(Self::Aes256Ctr),
            "SM4_128_CTR" => Some(Self::Sm4128Ctr),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PSlotDescriptor {
    #[prost(int32, required, tag = "1")]
    pub id: i32,
    /// tuple id which this slot is belong to
    #[prost(int32, required, tag = "2")]
    pub parent: i32,
    #[prost(message, required, tag = "3")]
    pub slot_type: PTypeDesc,
    /// in originating table
    #[prost(int32, required, tag = "4")]
    pub column_pos: i32,
    /// // deprecated
    #[prost(int32, required, tag = "5")]
    pub byte_offset: i32,
    #[prost(int32, required, tag = "6")]
    pub null_indicator_byte: i32,
    #[prost(int32, required, tag = "7")]
    pub null_indicator_bit: i32,
    #[prost(string, required, tag = "8")]
    pub col_name: ::prost::alloc::string::String,
    #[prost(int32, required, tag = "9")]
    pub slot_idx: i32,
    #[prost(bool, optional, tag = "10")]
    pub is_materialized: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "11")]
    pub col_unique_id: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "12")]
    pub is_key: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "13")]
    pub is_auto_increment: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "14", default = "0")]
    pub col_type: ::core::option::Option<i32>,
    #[prost(string, repeated, tag = "15")]
    pub column_paths: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PTupleDescriptor {
    #[prost(int32, required, tag = "1")]
    pub id: i32,
    /// deprecated
    #[prost(int32, required, tag = "2")]
    pub byte_size: i32,
    /// deprecated
    #[prost(int32, required, tag = "3")]
    pub num_null_bytes: i32,
    #[prost(int64, optional, tag = "4")]
    pub table_id: ::core::option::Option<i64>,
    /// deprecated
    #[prost(int32, optional, tag = "5")]
    pub num_null_slots: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct POlapTableIndexSchema {
    #[prost(int64, required, tag = "1")]
    pub id: i64,
    #[prost(string, repeated, tag = "2")]
    pub columns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int32, required, tag = "3")]
    pub schema_hash: i32,
    #[prost(message, repeated, tag = "4")]
    pub columns_desc: ::prost::alloc::vec::Vec<ColumnPb>,
    #[prost(message, repeated, tag = "5")]
    pub indexes_desc: ::prost::alloc::vec::Vec<TabletIndexPb>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct POlapTableSchemaParam {
    #[prost(int64, required, tag = "1")]
    pub db_id: i64,
    #[prost(int64, required, tag = "2")]
    pub table_id: i64,
    #[prost(int64, required, tag = "3")]
    pub version: i64,
    /// Logical columns, contain all column that in logical table
    #[prost(message, repeated, tag = "4")]
    pub slot_descs: ::prost::alloc::vec::Vec<PSlotDescriptor>,
    #[prost(message, required, tag = "5")]
    pub tuple_desc: PTupleDescriptor,
    #[prost(message, repeated, tag = "6")]
    pub indexes: ::prost::alloc::vec::Vec<POlapTableIndexSchema>,
    /// deprecated, use unique_key_update_mode
    #[prost(bool, optional, tag = "7", default = "false")]
    pub partial_update: ::core::option::Option<bool>,
    #[prost(string, repeated, tag = "8")]
    pub partial_update_input_columns: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[prost(bool, optional, tag = "9", default = "false")]
    pub is_strict_mode: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "10")]
    pub auto_increment_column: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "11", default = "0")]
    pub timestamp_ms: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "12")]
    pub timezone: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "13", default = "-1")]
    pub auto_increment_column_unique_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "14", default = "0")]
    pub nano_seconds: ::core::option::Option<i32>,
    #[prost(
        enumeration = "UniqueKeyUpdateModePb",
        optional,
        tag = "15",
        default = "Upsert"
    )]
    pub unique_key_update_mode: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "16", default = "-1")]
    pub sequence_map_col_unique_id: ::core::option::Option<i32>,
    #[prost(
        enumeration = "PartialUpdateNewRowPolicyPb",
        optional,
        tag = "17",
        default = "Append"
    )]
    pub partial_update_new_key_policy: ::core::option::Option<i32>,
}
/// A single performance counter
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PProfileCounter {
    #[prost(string, required, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "PProfileUnit", required, tag = "2")]
    pub r#type: i32,
    #[prost(int64, required, tag = "3")]
    pub value: i64,
    #[prost(int64, optional, tag = "4")]
    pub level: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "5")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
}
/// A set of child counters (used in map<string, set<string>>)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PProfileChildCounterSet {
    #[prost(string, repeated, tag = "1")]
    pub child_counters: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// A single runtime profile node
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PRuntimeProfileNode {
    #[prost(string, required, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(int32, required, tag = "2")]
    pub num_children: i32,
    /// Flattened counters for this node and all its children
    #[prost(message, repeated, tag = "3")]
    pub counters: ::prost::alloc::vec::Vec<PProfileCounter>,
    /// Node metadata (e.g., node id)
    #[prost(int64, required, tag = "4")]
    pub metadata: i64,
    /// Whether the child is indented
    #[prost(bool, required, tag = "5")]
    pub indent: bool,
    /// Key-value info strings describing additional metadata
    #[prost(map = "string, string", tag = "6")]
    pub info_strings: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Order to display info strings
    #[prost(string, repeated, tag = "7")]
    pub info_strings_display_order: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// Map from parent counter name to a set of child counter names
    #[prost(map = "string, message", tag = "8")]
    pub child_counters_map: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        PProfileChildCounterSet,
    >,
    /// Timestamp for this node
    #[prost(int64, required, tag = "9")]
    pub timestamp: i64,
    /// Deprecated field
    #[prost(bool, optional, tag = "10")]
    pub deprecated_is_sink: ::core::option::Option<bool>,
}
/// A flattened runtime profile tree in in-order traversal
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PRuntimeProfileTree {
    #[prost(message, repeated, tag = "1")]
    pub nodes: ::prost::alloc::vec::Vec<PRuntimeProfileNode>,
}
/// Counter unit types (equivalent to Metrics.TUnit)
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PProfileUnit {
    /// A dimensionless numerical quantity
    Unit = 0,
    /// Rate of a dimensionless numerical quantity
    UnitPerSecond = 1,
    CpuTicks = 2,
    Bytes = 3,
    BytesPerSecond = 4,
    TimeNs = 5,
    DoubleValue = 6,
    /// No units at all, may not be a numerical quantity
    /// It is used as a label now, so do not treat it as
    /// a real counter.
    None = 7,
    TimeMs = 8,
    TimeS = 9,
}
impl PProfileUnit {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            PProfileUnit::Unit => "UNIT",
            PProfileUnit::UnitPerSecond => "UNIT_PER_SECOND",
            PProfileUnit::CpuTicks => "CPU_TICKS",
            PProfileUnit::Bytes => "BYTES",
            PProfileUnit::BytesPerSecond => "BYTES_PER_SECOND",
            PProfileUnit::TimeNs => "TIME_NS",
            PProfileUnit::DoubleValue => "DOUBLE_VALUE",
            PProfileUnit::None => "NONE",
            PProfileUnit::TimeMs => "TIME_MS",
            PProfileUnit::TimeS => "TIME_S",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNIT" => Some(Self::Unit),
            "UNIT_PER_SECOND" => Some(Self::UnitPerSecond),
            "CPU_TICKS" => Some(Self::CpuTicks),
            "BYTES" => Some(Self::Bytes),
            "BYTES_PER_SECOND" => Some(Self::BytesPerSecond),
            "TIME_NS" => Some(Self::TimeNs),
            "DOUBLE_VALUE" => Some(Self::DoubleValue),
            "NONE" => Some(Self::None),
            "TIME_MS" => Some(Self::TimeMs),
            "TIME_S" => Some(Self::TimeS),
            _ => None,
        }
    }
}
/// Transmit data when process SQL query
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PTransmitDataParams {
    /// non-change member
    #[prost(message, required, tag = "1")]
    pub finst_id: PUniqueId,
    #[prost(int32, required, tag = "2")]
    pub node_id: i32,
    /// Id of this fragment in its role as a sender.
    #[prost(int32, required, tag = "3")]
    pub sender_id: i32,
    #[prost(int32, required, tag = "4")]
    pub be_number: i32,
    /// if set to true, indicates that no more row batches will be sent
    /// for this dest_node_id
    #[prost(bool, required, tag = "5")]
    pub eos: bool,
    #[prost(message, optional, tag = "6")]
    pub row_batch: ::core::option::Option<PRowBatch>,
    /// different per packet
    #[prost(int64, required, tag = "7")]
    pub packet_seq: i64,
    #[prost(message, optional, tag = "8")]
    pub query_statistics: ::core::option::Option<PQueryStatistics>,
    #[prost(message, optional, tag = "9")]
    pub block: ::core::option::Option<PBlock>,
    /// transfer the RowBatch to the Controller Attachment
    #[prost(bool, optional, tag = "10", default = "false")]
    pub transfer_by_attachment: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "11")]
    pub query_id: ::core::option::Option<PUniqueId>,
    #[prost(message, optional, tag = "12")]
    pub exec_status: ::core::option::Option<PStatus>,
    #[prost(message, repeated, tag = "13")]
    pub blocks: ::prost::alloc::vec::Vec<PBlock>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PTransmitDataResult {
    #[prost(message, optional, tag = "1")]
    pub status: ::core::option::Option<PStatus>,
    #[prost(int64, optional, tag = "2")]
    pub receive_time: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PTabletWithPartition {
    #[prost(int64, required, tag = "1")]
    pub partition_id: i64,
    #[prost(int64, required, tag = "2")]
    pub tablet_id: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PTabletLoadRowsetInfo {
    #[prost(int32, required, tag = "1")]
    pub current_rowset_nums: i32,
    #[prost(int32, required, tag = "2")]
    pub max_config_rowset_nums: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PTabletId {
    #[prost(int64, optional, tag = "1")]
    pub partition_id: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "2")]
    pub index_id: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "3")]
    pub tablet_id: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "4")]
    pub num_segments: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PTabletInfo {
    #[prost(int64, required, tag = "1")]
    pub tablet_id: i64,
    #[prost(int32, required, tag = "2")]
    pub schema_hash: i32,
    /// Delta Writer will write data to local disk and then check if there are new raw values not in global dict
    /// if appears, then it should add the column name to this vector
    #[prost(string, repeated, tag = "3")]
    pub invalid_dict_cols: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// total rows num received by DeltaWriter
    #[prost(int64, optional, tag = "4")]
    pub received_rows: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "5", default = "0")]
    pub num_rows_filtered: ::core::option::Option<i64>,
}
/// open a tablet writer
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PTabletWriterOpenRequest {
    #[prost(message, required, tag = "1")]
    pub id: PUniqueId,
    #[prost(int64, required, tag = "2")]
    pub index_id: i64,
    #[prost(int64, required, tag = "3")]
    pub txn_id: i64,
    #[prost(message, required, tag = "4")]
    pub schema: POlapTableSchemaParam,
    #[prost(message, repeated, tag = "5")]
    pub tablets: ::prost::alloc::vec::Vec<PTabletWithPartition>,
    #[prost(int32, required, tag = "6")]
    pub num_senders: i32,
    /// Deprecated, not used since alter job v2
    #[prost(bool, required, tag = "7")]
    pub need_gen_rollup: bool,
    #[prost(int64, optional, tag = "8")]
    pub load_mem_limit: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "9")]
    pub load_channel_timeout_s: ::core::option::Option<i64>,
    #[prost(bool, optional, tag = "10", default = "false")]
    pub is_high_priority: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "11", default = "")]
    pub sender_ip: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "12", default = "false")]
    pub is_vectorized: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "13", default = "-1")]
    pub backend_id: ::core::option::Option<i64>,
    #[prost(bool, optional, tag = "14", default = "false")]
    pub enable_profile: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "15", default = "false")]
    pub is_incremental: ::core::option::Option<bool>,
    /// Absolute time
    #[prost(int64, optional, tag = "16")]
    pub txn_expiration: ::core::option::Option<i64>,
    #[prost(bool, optional, tag = "17")]
    pub write_file_cache: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "18")]
    pub storage_vault_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "19")]
    pub sender_id: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "20")]
    pub workload_group_id: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PTabletWriterOpenResult {
    #[prost(message, required, tag = "1")]
    pub status: PStatus,
    #[prost(message, repeated, tag = "2")]
    pub tablet_load_rowset_num_infos: ::prost::alloc::vec::Vec<PTabletLoadRowsetInfo>,
}
/// add batch to tablet writer
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PTabletWriterAddBatchRequest {
    #[prost(message, required, tag = "1")]
    pub id: PUniqueId,
    #[prost(int64, required, tag = "2")]
    pub index_id: i64,
    #[prost(int32, required, tag = "3")]
    pub sender_id: i32,
    /// If this is the last batch from this sender
    #[prost(bool, optional, tag = "4")]
    pub eos: ::core::option::Option<bool>,
    #[prost(int64, required, tag = "5")]
    pub packet_seq: i64,
    #[prost(int64, repeated, packed = "false", tag = "6")]
    pub tablet_ids: ::prost::alloc::vec::Vec<i64>,
    /// unset if and only if when eos is true
    #[prost(message, optional, tag = "7")]
    pub row_batch: ::core::option::Option<PRowBatch>,
    /// only valid when eos is true
    /// valid partition ids that would write in this writer
    #[prost(int64, repeated, packed = "false", tag = "8")]
    pub partition_ids: ::prost::alloc::vec::Vec<i64>,
    /// the backend which send this request
    #[prost(int64, optional, tag = "9", default = "-1")]
    pub backend_id: ::core::option::Option<i64>,
    /// transfer the RowBatch to the Controller Attachment
    #[prost(bool, optional, tag = "10", default = "false")]
    pub transfer_by_attachment: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "11", default = "false")]
    pub is_high_priority: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "12", default = "false")]
    pub write_single_replica: ::core::option::Option<bool>,
    #[prost(map = "int64, message", tag = "13")]
    pub slave_tablet_nodes: ::std::collections::HashMap<i64, PSlaveTabletNodes>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PTabletWriterAddBlockRequest {
    #[prost(message, required, tag = "1")]
    pub id: PUniqueId,
    #[prost(int64, required, tag = "2")]
    pub index_id: i64,
    #[prost(int32, required, tag = "3")]
    pub sender_id: i32,
    /// If this is the last batch from this sender
    #[prost(bool, optional, tag = "4")]
    pub eos: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "5")]
    pub packet_seq: ::core::option::Option<i64>,
    #[prost(int64, repeated, packed = "false", tag = "6")]
    pub tablet_ids: ::prost::alloc::vec::Vec<i64>,
    /// unset if and only if when eos is true
    #[prost(message, optional, tag = "7")]
    pub block: ::core::option::Option<PBlock>,
    /// only valid when eos is true
    /// valid partition ids that would write in this writer
    #[prost(int64, repeated, packed = "false", tag = "8")]
    pub partition_ids: ::prost::alloc::vec::Vec<i64>,
    /// the backend which send this request
    #[prost(int64, optional, tag = "9", default = "-1")]
    pub backend_id: ::core::option::Option<i64>,
    /// transfer the vectorized::Block to the Controller Attachment
    #[prost(bool, optional, tag = "10", default = "false")]
    pub transfer_by_attachment: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "11", default = "false")]
    pub is_high_priority: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "12", default = "false")]
    pub write_single_replica: ::core::option::Option<bool>,
    #[prost(map = "int64, message", tag = "13")]
    pub slave_tablet_nodes: ::std::collections::HashMap<i64, PSlaveTabletNodes>,
    #[prost(bool, optional, tag = "14", default = "false")]
    pub is_single_tablet_block: ::core::option::Option<bool>,
    /// for auto-partition first stage close, we should hang.
    #[prost(bool, optional, tag = "15", default = "false")]
    pub hang_wait: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PSlaveTabletNodes {
    #[prost(message, repeated, tag = "1")]
    pub slave_nodes: ::prost::alloc::vec::Vec<PNodeInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PNodeInfo {
    #[prost(int64, optional, tag = "1")]
    pub id: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "2")]
    pub option: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "3")]
    pub host: ::core::option::Option<::prost::alloc::string::String>,
    /// used to transfer data between nodes
    #[prost(int32, optional, tag = "4")]
    pub async_internal_port: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PSuccessSlaveTabletNodeIds {
    #[prost(int64, repeated, packed = "false", tag = "1")]
    pub slave_node_ids: ::prost::alloc::vec::Vec<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PTabletError {
    #[prost(int64, optional, tag = "1")]
    pub tablet_id: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "2")]
    pub msg: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PTabletWriterAddBatchResult {
    #[prost(message, required, tag = "1")]
    pub status: PStatus,
    #[prost(message, repeated, tag = "2")]
    pub tablet_vec: ::prost::alloc::vec::Vec<PTabletInfo>,
    #[prost(int64, optional, tag = "3")]
    pub execution_time_us: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "4")]
    pub wait_lock_time_us: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "5")]
    pub wait_execution_time_us: ::core::option::Option<i64>,
    #[prost(message, repeated, tag = "6")]
    pub tablet_errors: ::prost::alloc::vec::Vec<PTabletError>,
    #[prost(map = "int64, message", tag = "7")]
    pub success_slave_tablet_node_ids: ::std::collections::HashMap<
        i64,
        PSuccessSlaveTabletNodeIds,
    >,
    /// For cloud
    #[prost(int64, optional, tag = "1000")]
    pub build_rowset_latency_ms: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "1001")]
    pub commit_rowset_latency_ms: ::core::option::Option<i64>,
    #[prost(message, repeated, tag = "1002")]
    pub tablet_load_rowset_num_infos: ::prost::alloc::vec::Vec<PTabletLoadRowsetInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PTabletWriterAddBlockResult {
    #[prost(message, required, tag = "1")]
    pub status: PStatus,
    #[prost(message, repeated, tag = "2")]
    pub tablet_vec: ::prost::alloc::vec::Vec<PTabletInfo>,
    #[prost(int64, optional, tag = "3")]
    pub execution_time_us: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "4")]
    pub wait_lock_time_us: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "5")]
    pub wait_execution_time_us: ::core::option::Option<i64>,
    #[prost(message, repeated, tag = "6")]
    pub tablet_errors: ::prost::alloc::vec::Vec<PTabletError>,
    #[prost(map = "int64, message", tag = "7")]
    pub success_slave_tablet_node_ids: ::std::collections::HashMap<
        i64,
        PSuccessSlaveTabletNodeIds,
    >,
    #[prost(bytes = "vec", optional, tag = "8")]
    pub load_channel_profile: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// For cloud
    #[prost(int64, optional, tag = "1000")]
    pub build_rowset_latency_ms: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "1001")]
    pub commit_rowset_latency_ms: ::core::option::Option<i64>,
    #[prost(message, repeated, tag = "1002")]
    pub tablet_load_rowset_num_infos: ::prost::alloc::vec::Vec<PTabletLoadRowsetInfo>,
}
/// tablet writer cancel
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PTabletWriterCancelRequest {
    #[prost(message, required, tag = "1")]
    pub id: PUniqueId,
    #[prost(int64, required, tag = "2")]
    pub index_id: i64,
    #[prost(int32, required, tag = "3")]
    pub sender_id: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PTabletWriterCancelResult {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PExecPlanFragmentRequest {
    #[prost(bytes = "vec", optional, tag = "1")]
    pub request: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bool, optional, tag = "2")]
    pub compact: ::core::option::Option<bool>,
    #[prost(
        enumeration = "PFragmentRequestVersion",
        optional,
        tag = "3",
        default = "Version2"
    )]
    pub version: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PExecPlanFragmentStartRequest {
    #[prost(message, optional, tag = "1")]
    pub query_id: ::core::option::Option<PUniqueId>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PExecPlanFragmentResult {
    #[prost(message, required, tag = "1")]
    pub status: PStatus,
    /// BE receive rpc
    #[prost(int64, optional, tag = "2")]
    pub received_time: ::core::option::Option<i64>,
    /// Start executing on bthread
    #[prost(int64, optional, tag = "3")]
    pub execution_time: ::core::option::Option<i64>,
    /// Done on bthread
    #[prost(int64, optional, tag = "4")]
    pub execution_done_time: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PCancelPlanFragmentRequest {
    #[prost(message, required, tag = "1")]
    pub finst_id: PUniqueId,
    #[prost(enumeration = "PPlanFragmentCancelReason", optional, tag = "2")]
    pub cancel_reason: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "3")]
    pub query_id: ::core::option::Option<PUniqueId>,
    #[prost(int32, optional, tag = "4")]
    pub fragment_id: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "5")]
    pub cancel_status: ::core::option::Option<PStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PCancelPlanFragmentResult {
    #[prost(message, required, tag = "1")]
    pub status: PStatus,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PFetchDataRequest {
    #[prost(message, required, tag = "1")]
    pub finst_id: PUniqueId,
    #[prost(bool, optional, tag = "2")]
    pub resp_in_attachment: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PFetchDataResult {
    #[prost(message, required, tag = "1")]
    pub status: PStatus,
    /// valid when status is ok
    #[prost(int64, optional, tag = "2")]
    pub packet_seq: ::core::option::Option<i64>,
    #[prost(bool, optional, tag = "3")]
    pub eos: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "4")]
    pub query_statistics: ::core::option::Option<PQueryStatistics>,
    #[prost(bytes = "vec", optional, tag = "5")]
    pub row_batch: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bool, optional, tag = "6")]
    pub empty_batch: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PFetchArrowDataRequest {
    #[prost(message, optional, tag = "1")]
    pub finst_id: ::core::option::Option<PUniqueId>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PFetchArrowDataResult {
    #[prost(message, optional, tag = "1")]
    pub status: ::core::option::Option<PStatus>,
    /// valid when status is ok
    #[prost(int64, optional, tag = "2")]
    pub packet_seq: ::core::option::Option<i64>,
    #[prost(bool, optional, tag = "3")]
    pub eos: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "4")]
    pub block: ::core::option::Option<PBlock>,
    #[prost(bool, optional, tag = "5")]
    pub empty_batch: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "6")]
    pub timezone: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PFetchArrowFlightSchemaRequest {
    #[prost(message, optional, tag = "1")]
    pub finst_id: ::core::option::Option<PUniqueId>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PFetchArrowFlightSchemaResult {
    #[prost(message, optional, tag = "1")]
    pub status: ::core::option::Option<PStatus>,
    /// valid when status is ok
    #[prost(bytes = "vec", optional, tag = "2")]
    pub schema: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "3")]
    pub be_arrow_flight_ip: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(int32, optional, tag = "4")]
    pub be_arrow_flight_port: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeyTuple {
    #[prost(string, repeated, tag = "1")]
    pub key_column_rep: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Uuid {
    #[prost(int64, required, tag = "1")]
    pub uuid_high: i64,
    #[prost(int64, required, tag = "2")]
    pub uuid_low: i64,
}
/// We use thrift definition for some structure, since TExpr,
/// list<Exprs.TExpr>, Descriptors.TDescriptorTable are all thrift format.
/// Modify them to protobuf is a redundant work.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PTabletKeyLookupRequest {
    #[prost(int64, required, tag = "1")]
    pub tablet_id: i64,
    #[prost(message, repeated, tag = "2")]
    pub key_tuples: ::prost::alloc::vec::Vec<KeyTuple>,
    /// reusable structures
    /// serilized from Descriptors.TDescriptorTable
    #[prost(message, optional, tag = "3")]
    pub uuid: ::core::option::Option<Uuid>,
    #[prost(bytes = "vec", optional, tag = "4")]
    pub desc_tbl: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// serilized from TExprList
    #[prost(bytes = "vec", optional, tag = "5")]
    pub output_expr: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// return binary mysql row format if true
    #[prost(bool, optional, tag = "6")]
    pub is_binary_row: ::core::option::Option<bool>,
    /// For cloud
    /// version to read
    #[prost(int64, optional, tag = "7")]
    pub version: ::core::option::Option<i64>,
    /// serilized from TQueryOptions
    #[prost(bytes = "vec", optional, tag = "8")]
    pub query_options: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PTabletKeyLookupResponse {
    #[prost(message, required, tag = "1")]
    pub status: PStatus,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub row_batch: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bool, optional, tag = "3")]
    pub empty_batch: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PCacheParam {
    #[prost(int64, required, tag = "1")]
    pub partition_key: i64,
    #[prost(int64, optional, tag = "2")]
    pub last_version: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "3")]
    pub last_version_time: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "4")]
    pub partition_num: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PCacheValue {
    #[prost(message, required, tag = "1")]
    pub param: PCacheParam,
    #[prost(int32, required, tag = "2")]
    pub data_size: i32,
    #[prost(bytes = "vec", repeated, tag = "3")]
    pub rows: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
/// for update&clear return
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PCacheResponse {
    #[prost(enumeration = "PCacheStatus", required, tag = "1")]
    pub status: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PUpdateCacheRequest {
    #[prost(message, required, tag = "1")]
    pub sql_key: PUniqueId,
    #[prost(message, repeated, tag = "2")]
    pub values: ::prost::alloc::vec::Vec<PCacheValue>,
    #[prost(enumeration = "CacheType", optional, tag = "3")]
    pub cache_type: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PFetchCacheRequest {
    #[prost(message, required, tag = "1")]
    pub sql_key: PUniqueId,
    #[prost(message, repeated, tag = "2")]
    pub params: ::prost::alloc::vec::Vec<PCacheParam>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PFetchCacheResult {
    #[prost(enumeration = "PCacheStatus", required, tag = "1")]
    pub status: i32,
    #[prost(message, repeated, tag = "2")]
    pub values: ::prost::alloc::vec::Vec<PCacheValue>,
    #[prost(int64, optional, tag = "3", default = "0")]
    pub all_count: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PClearCacheRequest {
    #[prost(enumeration = "PClearType", required, tag = "1")]
    pub clear_type: i32,
    #[prost(int64, optional, tag = "2")]
    pub before_time: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "3")]
    pub sql_key: ::core::option::Option<PUniqueId>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PStringPair {
    #[prost(string, required, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(string, required, tag = "2")]
    pub val: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PIntegerPair {
    #[prost(int32, required, tag = "1")]
    pub key: i32,
    #[prost(int64, required, tag = "2")]
    pub val: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PKafkaLoadInfo {
    #[prost(string, required, tag = "1")]
    pub brokers: ::prost::alloc::string::String,
    #[prost(string, required, tag = "2")]
    pub topic: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub properties: ::prost::alloc::vec::Vec<PStringPair>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PKafkaMetaProxyRequest {
    #[prost(message, optional, tag = "1")]
    pub kafka_info: ::core::option::Option<PKafkaLoadInfo>,
    /// optional for getting offsets for times
    #[prost(message, repeated, tag = "3")]
    pub offset_times: ::prost::alloc::vec::Vec<PIntegerPair>,
    /// optional for getting latest offsets of partitons
    #[prost(int32, repeated, packed = "false", tag = "4")]
    pub partition_id_for_latest_offsets: ::prost::alloc::vec::Vec<i32>,
    /// optional for getting real offset for end/beginning flag
    #[prost(message, repeated, tag = "5")]
    pub offset_flags: ::prost::alloc::vec::Vec<PIntegerPair>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PProxyRequest {
    #[prost(message, optional, tag = "1")]
    pub kafka_meta_request: ::core::option::Option<PKafkaMetaProxyRequest>,
    #[prost(int64, optional, tag = "2")]
    pub timeout_secs: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PKafkaMetaProxyResult {
    #[prost(int32, repeated, packed = "false", tag = "1")]
    pub partition_ids: ::prost::alloc::vec::Vec<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PKafkaPartitionOffsets {
    #[prost(message, repeated, tag = "1")]
    pub offset_times: ::prost::alloc::vec::Vec<PIntegerPair>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PProxyResult {
    #[prost(message, required, tag = "1")]
    pub status: PStatus,
    #[prost(message, optional, tag = "2")]
    pub kafka_meta_result: ::core::option::Option<PKafkaMetaProxyResult>,
    #[prost(message, optional, tag = "3")]
    pub partition_offsets: ::core::option::Option<PKafkaPartitionOffsets>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PDataColumn {
    #[prost(string, optional, tag = "1")]
    pub value: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PDataRow {
    #[prost(message, repeated, tag = "1")]
    pub col: ::prost::alloc::vec::Vec<PDataColumn>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PSendDataRequest {
    #[prost(message, required, tag = "1")]
    pub fragment_instance_id: PUniqueId,
    #[prost(message, repeated, tag = "2")]
    pub data: ::prost::alloc::vec::Vec<PDataRow>,
    /// load_id == query_id in fragment exec
    #[prost(message, optional, tag = "3")]
    pub load_id: ::core::option::Option<PUniqueId>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PSendDataResult {
    #[prost(message, required, tag = "1")]
    pub status: PStatus,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PCommitRequest {
    #[prost(message, required, tag = "1")]
    pub fragment_instance_id: PUniqueId,
    #[prost(message, optional, tag = "2")]
    pub load_id: ::core::option::Option<PUniqueId>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PCommitResult {
    #[prost(message, required, tag = "1")]
    pub status: PStatus,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PRollbackRequest {
    #[prost(message, required, tag = "1")]
    pub fragment_instance_id: PUniqueId,
    #[prost(message, optional, tag = "2")]
    pub load_id: ::core::option::Option<PUniqueId>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PRollbackResult {
    #[prost(message, required, tag = "1")]
    pub status: PStatus,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PBloomFilter {
    #[prost(bool, required, tag = "2")]
    pub always_true: bool,
    #[prost(int32, required, tag = "1")]
    pub filter_length: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PColumnValue {
    #[prost(bool, optional, tag = "1")]
    pub bool_val: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "2")]
    pub int_val: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "3")]
    pub long_val: ::core::option::Option<i64>,
    #[prost(double, optional, tag = "4")]
    pub double_val: ::core::option::Option<f64>,
    #[prost(bytes = "vec", optional, tag = "5")]
    pub string_val: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(int32, optional, tag = "6")]
    pub precision: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "7")]
    pub scale: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PMinMaxFilter {
    /// Deprecated
    #[prost(enumeration = "PColumnType", required, tag = "1")]
    pub column_type: i32,
    #[prost(message, required, tag = "2")]
    pub min_val: PColumnValue,
    #[prost(message, required, tag = "3")]
    pub max_val: PColumnValue,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PInFilter {
    /// Deprecated
    #[prost(enumeration = "PColumnType", required, tag = "1")]
    pub column_type: i32,
    #[prost(message, repeated, tag = "2")]
    pub values: ::prost::alloc::vec::Vec<PColumnValue>,
    #[prost(string, optional, tag = "3")]
    pub ignored_msg: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PSendFilterSizeRequest {
    #[prost(int32, required, tag = "1")]
    pub filter_id: i32,
    #[prost(message, required, tag = "2")]
    pub query_id: PUniqueId,
    #[prost(message, required, tag = "3")]
    pub source_addr: PNetworkAddress,
    #[prost(uint64, required, tag = "4")]
    pub filter_size: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PSendFilterSizeResponse {
    #[prost(message, required, tag = "1")]
    pub status: PStatus,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PSyncFilterSizeRequest {
    #[prost(int32, required, tag = "1")]
    pub filter_id: i32,
    #[prost(message, required, tag = "2")]
    pub query_id: PUniqueId,
    #[prost(uint64, required, tag = "3")]
    pub filter_size: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PSyncFilterSizeResponse {
    #[prost(message, required, tag = "1")]
    pub status: PStatus,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PMergeFilterRequest {
    #[prost(int32, required, tag = "1")]
    pub filter_id: i32,
    #[prost(message, required, tag = "2")]
    pub query_id: PUniqueId,
    #[prost(message, required, tag = "3")]
    pub fragment_instance_id: PUniqueId,
    #[prost(enumeration = "PFilterType", required, tag = "4")]
    pub filter_type: i32,
    #[prost(message, optional, tag = "5")]
    pub minmax_filter: ::core::option::Option<PMinMaxFilter>,
    #[prost(message, optional, tag = "6")]
    pub bloom_filter: ::core::option::Option<PBloomFilter>,
    #[prost(message, optional, tag = "7")]
    pub in_filter: ::core::option::Option<PInFilter>,
    #[deprecated]
    #[prost(bool, optional, tag = "8")]
    pub is_pipeline: ::core::option::Option<bool>,
    /// Deprecated
    #[prost(bool, optional, tag = "9")]
    pub opt_remote_rf: ::core::option::Option<bool>,
    /// Deprecated
    #[prost(enumeration = "PColumnType", optional, tag = "10")]
    pub column_type: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "11")]
    pub contain_null: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "12")]
    pub ignored: ::core::option::Option<bool>,
    #[prost(uint64, optional, tag = "13")]
    pub local_merge_time: ::core::option::Option<u64>,
    #[prost(bool, optional, tag = "14")]
    pub disabled: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PMergeFilterResponse {
    #[prost(message, required, tag = "1")]
    pub status: PStatus,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PPublishFilterRequestV2 {
    #[prost(int32, required, tag = "1")]
    pub filter_id: i32,
    #[prost(message, required, tag = "2")]
    pub query_id: PUniqueId,
    #[prost(message, repeated, tag = "3")]
    pub fragment_instance_ids: ::prost::alloc::vec::Vec<PUniqueId>,
    #[prost(enumeration = "PFilterType", required, tag = "4")]
    pub filter_type: i32,
    #[prost(message, optional, tag = "5")]
    pub minmax_filter: ::core::option::Option<PMinMaxFilter>,
    #[prost(message, optional, tag = "6")]
    pub bloom_filter: ::core::option::Option<PBloomFilter>,
    #[prost(message, optional, tag = "7")]
    pub in_filter: ::core::option::Option<PInFilter>,
    #[deprecated]
    #[prost(bool, optional, tag = "8")]
    pub is_pipeline: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "9")]
    pub merge_time: ::core::option::Option<i64>,
    #[prost(bool, optional, tag = "10")]
    pub contain_null: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "11")]
    pub ignored: ::core::option::Option<bool>,
    /// deprecated
    #[prost(int32, repeated, packed = "false", tag = "12")]
    pub fragment_ids: ::prost::alloc::vec::Vec<i32>,
    #[prost(uint64, optional, tag = "13")]
    pub local_merge_time: ::core::option::Option<u64>,
    #[prost(bool, optional, tag = "14")]
    pub disabled: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PPublishFilterResponse {
    #[prost(message, required, tag = "1")]
    pub status: PStatus,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PExprResult {
    #[prost(message, required, tag = "1")]
    pub r#type: PScalarType,
    /// maybe need remove after next version of 2.1
    #[prost(string, required, tag = "2")]
    pub content: ::prost::alloc::string::String,
    #[prost(bool, required, tag = "3")]
    pub success: bool,
    #[prost(message, optional, tag = "4")]
    pub type_desc: ::core::option::Option<PTypeDesc>,
    #[prost(message, optional, tag = "5")]
    pub result_content: ::core::option::Option<PValues>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PExprResultMap {
    #[prost(map = "string, message", tag = "1")]
    pub map: ::std::collections::HashMap<::prost::alloc::string::String, PExprResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PConstantExprRequest {
    #[prost(bytes = "vec", optional, tag = "1")]
    pub request: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PConstantExprResult {
    #[prost(message, required, tag = "1")]
    pub status: PStatus,
    #[prost(map = "string, message", tag = "2")]
    pub expr_result_map: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        PExprResultMap,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PCheckRpcChannelRequest {
    #[prost(bytes = "vec", optional, tag = "1")]
    pub data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(uint32, optional, tag = "2")]
    pub size: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "3")]
    pub md5: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PCheckRpcChannelResponse {
    #[prost(message, required, tag = "1")]
    pub status: PStatus,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PResetRpcChannelRequest {
    #[prost(bool, required, tag = "1")]
    pub all: bool,
    #[prost(string, repeated, tag = "2")]
    pub endpoints: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PResetRpcChannelResponse {
    #[prost(message, required, tag = "1")]
    pub status: PStatus,
    #[prost(string, repeated, tag = "2")]
    pub channels: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PEmptyRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PTabletWriteSlaveRequest {
    #[prost(message, optional, tag = "1")]
    pub rowset_meta: ::core::option::Option<RowsetMetaPb>,
    #[prost(string, optional, tag = "2")]
    pub rowset_path: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "int64, int64", tag = "3")]
    pub segments_size: ::std::collections::HashMap<i64, i64>,
    #[prost(string, optional, tag = "4")]
    pub host: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "5")]
    pub http_port: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub brpc_port: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "7")]
    pub token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "8")]
    pub node_id: ::core::option::Option<i32>,
    #[prost(map = "int64, message", tag = "9")]
    pub inverted_indices_size: ::std::collections::HashMap<
        i64,
        p_tablet_write_slave_request::IndexSizeMap,
    >,
}
/// Nested message and enum types in `PTabletWriteSlaveRequest`.
pub mod p_tablet_write_slave_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct IndexSize {
        #[prost(int64, required, tag = "1")]
        pub index_id: i64,
        #[prost(int64, required, tag = "2")]
        pub size: i64,
        #[prost(string, optional, tag = "3")]
        pub suffix_path: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct IndexSizeMap {
        #[prost(message, repeated, tag = "1")]
        pub index_sizes: ::prost::alloc::vec::Vec<IndexSize>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PTabletWriteSlaveResult {
    #[prost(message, optional, tag = "1")]
    pub status: ::core::option::Option<PStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PTabletWriteSlaveDoneRequest {
    #[prost(int64, optional, tag = "1")]
    pub txn_id: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "2")]
    pub tablet_id: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "3")]
    pub node_id: ::core::option::Option<i64>,
    #[prost(bool, optional, tag = "4", default = "false")]
    pub is_succeed: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PTabletWriteSlaveDoneResult {
    #[prost(message, optional, tag = "1")]
    pub status: ::core::option::Option<PStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PFetchTableSchemaRequest {
    #[prost(bytes = "vec", optional, tag = "1")]
    pub file_scan_range: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PFetchTableSchemaResult {
    #[prost(message, optional, tag = "1")]
    pub status: ::core::option::Option<PStatus>,
    #[prost(int32, optional, tag = "2")]
    pub column_nums: ::core::option::Option<i32>,
    #[prost(string, repeated, tag = "3")]
    pub column_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "4")]
    pub column_types: ::prost::alloc::vec::Vec<PTypeDesc>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct POutfileWriteSuccessRequest {
    #[prost(bytes = "vec", optional, tag = "1")]
    pub result_file_sink: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct POutfileWriteSuccessResult {
    #[prost(message, optional, tag = "1")]
    pub status: ::core::option::Option<PStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PJdbcTestConnectionRequest {
    #[prost(bytes = "vec", optional, tag = "1")]
    pub jdbc_table: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(int32, optional, tag = "2")]
    pub jdbc_table_type: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "3")]
    pub query_str: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PJdbcTestConnectionResult {
    #[prost(message, optional, tag = "1")]
    pub status: ::core::option::Option<PStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PRowLocation {
    #[prost(int64, optional, tag = "1")]
    pub tablet_id: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "2")]
    pub rowset_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "3")]
    pub segment_id: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "4")]
    pub ordinal_id: ::core::option::Option<u64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PMultiGetRequest {
    #[prost(message, repeated, tag = "1")]
    pub row_locs: ::prost::alloc::vec::Vec<PRowLocation>,
    #[prost(message, optional, tag = "2")]
    pub desc: ::core::option::Option<PTupleDescriptor>,
    #[prost(message, repeated, tag = "3")]
    pub slots: ::prost::alloc::vec::Vec<PSlotDescriptor>,
    /// for compability
    #[prost(int32, optional, tag = "4")]
    pub be_exec_version: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "5")]
    pub fetch_row_store: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "6")]
    pub query_id: ::core::option::Option<PUniqueId>,
    #[prost(message, repeated, tag = "7")]
    pub column_desc: ::prost::alloc::vec::Vec<ColumnPb>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PMultiGetResponse {
    #[prost(message, optional, tag = "1")]
    pub block: ::core::option::Option<PBlock>,
    #[prost(message, optional, tag = "2")]
    pub status: ::core::option::Option<PStatus>,
    #[prost(enumeration = "p_multi_get_response::RowFormat", optional, tag = "3")]
    pub format: ::core::option::Option<i32>,
    #[prost(bytes = "vec", repeated, tag = "4")]
    pub binary_row_data: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// for sorting rows
    #[prost(message, repeated, tag = "5")]
    pub row_locs: ::prost::alloc::vec::Vec<PRowLocation>,
}
/// Nested message and enum types in `PMultiGetResponse`.
pub mod p_multi_get_response {
    /// more effecient serialization fields for row store
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RowFormat {
        Jsonb = 0,
    }
    impl RowFormat {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                RowFormat::Jsonb => "JSONB",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "JSONB" => Some(Self::Jsonb),
                _ => None,
            }
        }
    }
}
/// Eeach block have own schema to read
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PRequestBlockDesc {
    #[prost(bool, optional, tag = "1")]
    pub fetch_row_store: ::core::option::Option<bool>,
    #[prost(message, repeated, tag = "2")]
    pub slots: ::prost::alloc::vec::Vec<PSlotDescriptor>,
    #[prost(message, repeated, tag = "3")]
    pub column_descs: ::prost::alloc::vec::Vec<ColumnPb>,
    #[prost(uint32, repeated, packed = "false", tag = "4")]
    pub file_id: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, packed = "false", tag = "5")]
    pub row_id: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, optional, tag = "6")]
    pub desc: ::core::option::Option<PTupleDescriptor>,
    #[prost(uint32, repeated, packed = "false", tag = "7")]
    pub column_idxs: ::prost::alloc::vec::Vec<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PMultiGetRequestV2 {
    #[prost(message, repeated, tag = "1")]
    pub request_block_descs: ::prost::alloc::vec::Vec<PRequestBlockDesc>,
    /// for compability
    #[prost(int32, optional, tag = "2")]
    pub be_exec_version: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "3")]
    pub query_id: ::core::option::Option<PUniqueId>,
    #[prost(bool, optional, tag = "4")]
    pub gc_id_map: ::core::option::Option<bool>,
    #[prost(uint64, optional, tag = "5")]
    pub wg_id: ::core::option::Option<u64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PMultiGetBlockV2 {
    #[prost(message, optional, tag = "1")]
    pub block: ::core::option::Option<PBlock>,
    #[prost(enumeration = "p_multi_get_block_v2::RowFormat", optional, tag = "2")]
    pub format: ::core::option::Option<i32>,
    #[prost(bytes = "vec", repeated, tag = "3")]
    pub binary_row_data: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(message, optional, tag = "4")]
    pub profile: ::core::option::Option<PRuntimeProfileTree>,
}
/// Nested message and enum types in `PMultiGetBlockV2`.
pub mod p_multi_get_block_v2 {
    /// more effecient serialization fields for row store
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RowFormat {
        Jsonb = 0,
    }
    impl RowFormat {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                RowFormat::Jsonb => "JSONB",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "JSONB" => Some(Self::Jsonb),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PMultiGetResponseV2 {
    #[prost(message, optional, tag = "1")]
    pub status: ::core::option::Option<PStatus>,
    #[prost(message, repeated, tag = "2")]
    pub blocks: ::prost::alloc::vec::Vec<PMultiGetBlockV2>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PFetchColIdsRequest {
    #[prost(message, repeated, tag = "1")]
    pub params: ::prost::alloc::vec::Vec<p_fetch_col_ids_request::PFetchColIdParam>,
}
/// Nested message and enum types in `PFetchColIdsRequest`.
pub mod p_fetch_col_ids_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PFetchColIdParam {
        #[prost(int64, required, tag = "1")]
        pub index_id: i64,
        #[prost(int64, repeated, packed = "false", tag = "2")]
        pub tablet_ids: ::prost::alloc::vec::Vec<i64>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PFetchColIdsResponse {
    #[prost(message, optional, tag = "1")]
    pub status: ::core::option::Option<PStatus>,
    #[prost(message, repeated, tag = "2")]
    pub entries: ::prost::alloc::vec::Vec<
        p_fetch_col_ids_response::PFetchColIdsResultEntry,
    >,
}
/// Nested message and enum types in `PFetchColIdsResponse`.
pub mod p_fetch_col_ids_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PFetchColIdsResultEntry {
        #[prost(int64, required, tag = "1")]
        pub index_id: i64,
        #[prost(map = "string, int32", tag = "2")]
        pub col_name_to_id: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            i32,
        >,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PGetTabletVersionsRequest {
    #[prost(int64, required, tag = "1")]
    pub tablet_id: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PGetTabletVersionsResponse {
    #[prost(message, required, tag = "1")]
    pub status: PStatus,
    #[prost(message, repeated, tag = "2")]
    pub versions: ::prost::alloc::vec::Vec<p_get_tablet_versions_response::PVersion>,
}
/// Nested message and enum types in `PGetTabletVersionsResponse`.
pub mod p_get_tablet_versions_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PVersion {
        #[prost(int64, required, tag = "1")]
        pub first: i64,
        #[prost(int64, required, tag = "2")]
        pub second: i64,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PGetFileCacheMetaRequest {
    #[prost(int64, repeated, packed = "false", tag = "1")]
    pub tablet_ids: ::prost::alloc::vec::Vec<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileCacheBlockMeta {
    #[prost(int64, required, tag = "1")]
    pub tablet_id: i64,
    #[prost(string, required, tag = "2")]
    pub rowset_id: ::prost::alloc::string::String,
    #[prost(int64, required, tag = "3")]
    pub segment_id: i64,
    #[prost(string, required, tag = "4")]
    pub file_name: ::prost::alloc::string::String,
    #[prost(int64, required, tag = "5")]
    pub offset: i64,
    #[prost(int64, required, tag = "6")]
    pub size: i64,
    #[prost(enumeration = "FileCacheType", required, tag = "7")]
    pub cache_type: i32,
    #[prost(int64, required, tag = "8")]
    pub expiration_time: i64,
    #[prost(int64, optional, tag = "9")]
    pub file_size: ::core::option::Option<i64>,
    #[prost(enumeration = "FileType", optional, tag = "10")]
    pub file_type: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PGetFileCacheMetaResponse {
    #[prost(message, repeated, tag = "1")]
    pub file_cache_block_metas: ::prost::alloc::vec::Vec<FileCacheBlockMeta>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PWarmUpRowsetRequest {
    #[prost(message, repeated, tag = "1")]
    pub rowset_metas: ::prost::alloc::vec::Vec<RowsetMetaPb>,
    #[prost(int64, optional, tag = "2")]
    pub unix_ts_us: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "3")]
    pub sync_wait_timeout_ms: ::core::option::Option<i64>,
    #[prost(bool, optional, tag = "4")]
    pub skip_existence_check: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PWarmUpRowsetResponse {
    #[prost(message, optional, tag = "1")]
    pub status: ::core::option::Option<PStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecycleCacheMeta {
    #[prost(int64, optional, tag = "1")]
    pub tablet_id: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "2")]
    pub rowset_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "3")]
    pub num_segments: ::core::option::Option<i64>,
    #[prost(string, repeated, tag = "4")]
    pub index_file_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PRecycleCacheRequest {
    #[prost(message, repeated, tag = "1")]
    pub cache_metas: ::prost::alloc::vec::Vec<RecycleCacheMeta>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PRecycleCacheResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PReportStreamLoadStatusRequest {
    #[prost(message, optional, tag = "1")]
    pub load_id: ::core::option::Option<PUniqueId>,
    #[prost(message, optional, tag = "2")]
    pub status: ::core::option::Option<PStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PReportStreamLoadStatusResponse {
    #[prost(message, optional, tag = "1")]
    pub status: ::core::option::Option<PStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PGlobRequest {
    #[prost(string, optional, tag = "1")]
    pub pattern: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PGlobResponse {
    #[prost(message, required, tag = "1")]
    pub status: PStatus,
    #[prost(message, repeated, tag = "2")]
    pub files: ::prost::alloc::vec::Vec<p_glob_response::PFileInfo>,
}
/// Nested message and enum types in `PGlobResponse`.
pub mod p_glob_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PFileInfo {
        #[prost(string, optional, tag = "1")]
        pub file: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(int64, optional, tag = "2")]
        pub size: ::core::option::Option<i64>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PGroupCommitInsertRequest {
    /// deprecated
    #[prost(int64, optional, tag = "1")]
    pub db_id: ::core::option::Option<i64>,
    /// deprecated
    #[prost(int64, optional, tag = "2")]
    pub table_id: ::core::option::Option<i64>,
    ///   Descriptors.TDescriptorTable
    /// optional bytes desc_tbl = 3;
    ///
    /// deprecated
    #[prost(int64, optional, tag = "4")]
    pub base_schema_version: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "7")]
    pub load_id: ::core::option::Option<PUniqueId>,
    #[prost(message, repeated, tag = "8")]
    pub data: ::prost::alloc::vec::Vec<PDataRow>,
    /// TExecPlanFragmentParams
    #[prost(message, optional, tag = "9")]
    pub exec_plan_fragment_request: ::core::option::Option<PExecPlanFragmentRequest>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PGroupCommitInsertResponse {
    #[prost(message, required, tag = "1")]
    pub status: PStatus,
    #[prost(string, optional, tag = "2")]
    pub label: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "3")]
    pub txn_id: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "4")]
    pub loaded_rows: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "5")]
    pub filtered_rows: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "6")]
    pub error_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "7")]
    pub first_error_msg: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct POpenLoadStreamRequest {
    #[prost(message, optional, tag = "1")]
    pub load_id: ::core::option::Option<PUniqueId>,
    #[prost(int64, optional, tag = "2")]
    pub txn_id: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "3")]
    pub src_id: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "4")]
    pub schema: ::core::option::Option<POlapTableSchemaParam>,
    #[prost(message, repeated, tag = "5")]
    pub tablets: ::prost::alloc::vec::Vec<PTabletId>,
    #[prost(bool, optional, tag = "6", default = "false")]
    pub enable_profile: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "7")]
    pub total_streams: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "8")]
    pub idle_timeout_ms: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PTabletSchemaWithIndex {
    #[prost(int64, optional, tag = "1")]
    pub index_id: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "2")]
    pub tablet_schema: ::core::option::Option<TabletSchemaPb>,
    #[prost(bool, optional, tag = "3")]
    pub enable_unique_key_merge_on_write: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct POpenLoadStreamResponse {
    #[prost(message, optional, tag = "1")]
    pub status: ::core::option::Option<PStatus>,
    #[prost(message, repeated, tag = "2")]
    pub tablet_schemas: ::prost::alloc::vec::Vec<PTabletSchemaWithIndex>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PFailedTablet {
    #[prost(int64, optional, tag = "1")]
    pub id: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "2")]
    pub status: ::core::option::Option<PStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PLoadStreamResponse {
    #[prost(message, optional, tag = "1")]
    pub status: ::core::option::Option<PStatus>,
    #[prost(int64, repeated, packed = "false", tag = "2")]
    pub success_tablet_ids: ::prost::alloc::vec::Vec<i64>,
    #[prost(message, repeated, tag = "3")]
    pub failed_tablets: ::prost::alloc::vec::Vec<PFailedTablet>,
    #[prost(bytes = "vec", optional, tag = "4")]
    pub load_stream_profile: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(message, repeated, tag = "5")]
    pub tablet_schemas: ::prost::alloc::vec::Vec<PTabletSchemaWithIndex>,
    #[prost(bool, optional, tag = "6")]
    pub eos: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PStreamHeader {
    #[prost(message, optional, tag = "1")]
    pub load_id: ::core::option::Option<PUniqueId>,
    #[prost(int64, optional, tag = "2")]
    pub partition_id: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "3")]
    pub index_id: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "4")]
    pub tablet_id: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "5")]
    pub segment_id: ::core::option::Option<i32>,
    #[prost(enumeration = "p_stream_header::Opcode", optional, tag = "6")]
    pub opcode: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "7")]
    pub segment_eos: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "8")]
    pub src_id: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "9")]
    pub segment_statistics: ::core::option::Option<SegmentStatisticsPb>,
    #[prost(message, repeated, tag = "10")]
    pub tablets: ::prost::alloc::vec::Vec<PTabletId>,
    #[prost(message, optional, tag = "11")]
    pub flush_schema: ::core::option::Option<TabletSchemaPb>,
    #[prost(uint64, optional, tag = "12")]
    pub offset: ::core::option::Option<u64>,
    #[prost(enumeration = "FileType", optional, tag = "13")]
    pub file_type: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "14")]
    pub num_incremental_streams: ::core::option::Option<i64>,
}
/// Nested message and enum types in `PStreamHeader`.
pub mod p_stream_header {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Opcode {
        AppendData = 1,
        CloseLoad = 2,
        AddSegment = 3,
        GetSchema = 4,
    }
    impl Opcode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Opcode::AppendData => "APPEND_DATA",
                Opcode::CloseLoad => "CLOSE_LOAD",
                Opcode::AddSegment => "ADD_SEGMENT",
                Opcode::GetSchema => "GET_SCHEMA",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "APPEND_DATA" => Some(Self::AppendData),
                "CLOSE_LOAD" => Some(Self::CloseLoad),
                "ADD_SEGMENT" => Some(Self::AddSegment),
                "GET_SCHEMA" => Some(Self::GetSchema),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PGetWalQueueSizeRequest {
    #[prost(int64, optional, tag = "1")]
    pub table_id: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PGetWalQueueSizeResponse {
    #[prost(message, required, tag = "1")]
    pub status: PStatus,
    #[prost(int64, optional, tag = "2")]
    pub size: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PTabletsLocation {
    #[prost(string, required, tag = "1")]
    pub host: ::prost::alloc::string::String,
    #[prost(int32, required, tag = "2")]
    pub brpc_port: i32,
    #[prost(int64, repeated, packed = "false", tag = "3")]
    pub tablet_id: ::prost::alloc::vec::Vec<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PFetchRemoteSchemaRequest {
    #[prost(message, repeated, tag = "1")]
    pub tablet_location: ::prost::alloc::vec::Vec<PTabletsLocation>,
    #[prost(bool, required, tag = "2")]
    pub is_coordinator: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PFetchRemoteSchemaResponse {
    #[prost(message, optional, tag = "1")]
    pub status: ::core::option::Option<PStatus>,
    /// intermediate merged schema
    #[prost(message, optional, tag = "2")]
    pub merged_schema: ::core::option::Option<TabletSchemaPb>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PAlterVaultSyncRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PAlterVaultSyncResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PGetBeResourceRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PGlobalResourceUsage {
    #[prost(int64, optional, tag = "1")]
    pub mem_limit: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "2")]
    pub mem_usage: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PGetBeResourceResponse {
    #[prost(message, optional, tag = "1")]
    pub status: ::core::option::Option<PStatus>,
    #[prost(message, optional, tag = "2")]
    pub global_be_resource_usage: ::core::option::Option<PGlobalResourceUsage>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PDeleteDictionaryRequest {
    #[prost(int64, optional, tag = "1")]
    pub dictionary_id: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PDeleteDictionaryResponse {
    #[prost(message, optional, tag = "1")]
    pub status: ::core::option::Option<PStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PCommitRefreshDictionaryRequest {
    #[prost(int64, optional, tag = "1")]
    pub dictionary_id: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "2")]
    pub version_id: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PCommitRefreshDictionaryResponse {
    #[prost(message, optional, tag = "1")]
    pub status: ::core::option::Option<PStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PAbortRefreshDictionaryRequest {
    #[prost(int64, optional, tag = "1")]
    pub dictionary_id: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "2")]
    pub version_id: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PAbortRefreshDictionaryResponse {
    #[prost(message, optional, tag = "1")]
    pub status: ::core::option::Option<PStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PGetTabletRowsetsRequest {
    #[prost(int64, optional, tag = "1")]
    pub tablet_id: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "2")]
    pub version_start: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "3")]
    pub version_end: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "4")]
    pub delete_bitmap_keys: ::core::option::Option<DeleteBitmapPb>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PGetTabletRowsetsResponse {
    #[prost(message, required, tag = "1")]
    pub status: PStatus,
    #[prost(message, repeated, tag = "2")]
    pub rowsets: ::prost::alloc::vec::Vec<RowsetMetaPb>,
    #[prost(message, optional, tag = "3")]
    pub delete_bitmap: ::core::option::Option<DeleteBitmapPb>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CacheBlockReqest {
    /// PEER_FILE_CACHE_BLOCK
    #[prost(int64, optional, tag = "1")]
    pub block_offset: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "2")]
    pub block_size: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PFetchPeerDataRequest {
    #[prost(enumeration = "p_fetch_peer_data_request::Type", optional, tag = "1")]
    pub r#type: ::core::option::Option<i32>,
    /// obj path, let peer calc hash, and download file cache
    /// PEER_FILE_RANGE and PEER_FILE_CACHE_BLOCK use
    #[prost(string, optional, tag = "2")]
    pub path: ::core::option::Option<::prost::alloc::string::String>,
    /// PEER_FILE_RANGE
    #[prost(int64, optional, tag = "3")]
    pub file_offset: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "4")]
    pub file_size: ::core::option::Option<i64>,
    /// PEER_FILE_CACHE_BLOCK
    #[prost(message, repeated, tag = "5")]
    pub cache_req: ::prost::alloc::vec::Vec<CacheBlockReqest>,
}
/// Nested message and enum types in `PFetchPeerDataRequest`.
pub mod p_fetch_peer_data_request {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        PeerFileRange = 1,
        PeerFileCacheBlock = 2,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::PeerFileRange => "PEER_FILE_RANGE",
                Type::PeerFileCacheBlock => "PEER_FILE_CACHE_BLOCK",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PEER_FILE_RANGE" => Some(Self::PeerFileRange),
                "PEER_FILE_CACHE_BLOCK" => Some(Self::PeerFileCacheBlock),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CacheBlockPb {
    #[prost(int64, optional, tag = "1")]
    pub block_offset: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "2")]
    pub block_size: ::core::option::Option<i64>,
    #[prost(bytes = "vec", optional, tag = "3")]
    pub data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PFetchPeerDataResponse {
    #[prost(message, optional, tag = "1")]
    pub status: ::core::option::Option<PStatus>,
    #[prost(message, repeated, tag = "2")]
    pub datas: ::prost::alloc::vec::Vec<CacheBlockPb>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PFragmentRequestVersion {
    /// only one TExecPlanFragmentParams in request
    Version1 = 1,
    /// multi TExecPlanFragmentParams in request
    Version2 = 2,
    /// multi TPipelineFragmentParams in request
    Version3 = 3,
    /// multi TPipelineFragmentParams with optimized common fields in request. Used by 2.1
    Version4 = 4,
}
impl PFragmentRequestVersion {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            PFragmentRequestVersion::Version1 => "VERSION_1",
            PFragmentRequestVersion::Version2 => "VERSION_2",
            PFragmentRequestVersion::Version3 => "VERSION_3",
            PFragmentRequestVersion::Version4 => "VERSION_4",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VERSION_1" => Some(Self::Version1),
            "VERSION_2" => Some(Self::Version2),
            "VERSION_3" => Some(Self::Version3),
            "VERSION_4" => Some(Self::Version4),
            _ => None,
        }
    }
}
/// Add message definition to fetch and update cache
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PCacheStatus {
    Default = 0,
    CacheOk = 1,
    ParamError = 2,
    SizeOverLimit = 3,
    NoSqlKey = 4,
    NoPartitionKey = 5,
    InvalidKeyRange = 6,
    DataOverdue = 7,
    EmptyData = 8,
    Canceled = 9,
}
impl PCacheStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            PCacheStatus::Default => "DEFAULT",
            PCacheStatus::CacheOk => "CACHE_OK",
            PCacheStatus::ParamError => "PARAM_ERROR",
            PCacheStatus::SizeOverLimit => "SIZE_OVER_LIMIT",
            PCacheStatus::NoSqlKey => "NO_SQL_KEY",
            PCacheStatus::NoPartitionKey => "NO_PARTITION_KEY",
            PCacheStatus::InvalidKeyRange => "INVALID_KEY_RANGE",
            PCacheStatus::DataOverdue => "DATA_OVERDUE",
            PCacheStatus::EmptyData => "EMPTY_DATA",
            PCacheStatus::Canceled => "CANCELED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DEFAULT" => Some(Self::Default),
            "CACHE_OK" => Some(Self::CacheOk),
            "PARAM_ERROR" => Some(Self::ParamError),
            "SIZE_OVER_LIMIT" => Some(Self::SizeOverLimit),
            "NO_SQL_KEY" => Some(Self::NoSqlKey),
            "NO_PARTITION_KEY" => Some(Self::NoPartitionKey),
            "INVALID_KEY_RANGE" => Some(Self::InvalidKeyRange),
            "DATA_OVERDUE" => Some(Self::DataOverdue),
            "EMPTY_DATA" => Some(Self::EmptyData),
            "CANCELED" => Some(Self::Canceled),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CacheType {
    SqlCache = 1,
    PartitionCache = 2,
}
impl CacheType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            CacheType::SqlCache => "SQL_CACHE",
            CacheType::PartitionCache => "PARTITION_CACHE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SQL_CACHE" => Some(Self::SqlCache),
            "PARTITION_CACHE" => Some(Self::PartitionCache),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PClearType {
    ClearAll = 0,
    PruneCache = 1,
    ClearBeforeTime = 2,
    ClearSqlKey = 3,
}
impl PClearType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            PClearType::ClearAll => "CLEAR_ALL",
            PClearType::PruneCache => "PRUNE_CACHE",
            PClearType::ClearBeforeTime => "CLEAR_BEFORE_TIME",
            PClearType::ClearSqlKey => "CLEAR_SQL_KEY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CLEAR_ALL" => Some(Self::ClearAll),
            "PRUNE_CACHE" => Some(Self::PruneCache),
            "CLEAR_BEFORE_TIME" => Some(Self::ClearBeforeTime),
            "CLEAR_SQL_KEY" => Some(Self::ClearSqlKey),
            _ => None,
        }
    }
}
/// TODO: CHECK ALL TYPE
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PColumnType {
    ColumnTypeBool = 0,
    ColumnTypeInt = 1,
    ColumnTypeTinyInt = 2,
    ColumnTypeSmallInt = 3,
    ColumnTypeBigint = 4,
    ColumnTypeLargeint = 5,
    ColumnTypeVarchar = 6,
    ColumnTypeChar = 7,
    ColumnTypeDate = 8,
    ColumnTypeDatetime = 9,
    ColumnTypeDouble = 10,
    ColumnTypeFloat = 11,
    ColumnTypeDecimal = 12,
    ColumnTypeDecimalv2 = 13,
    ColumnTypeString = 14,
    ColumnTypeDatev2 = 15,
    ColumnTypeDatetimev2 = 16,
    ColumnTypeDecimal32 = 17,
    ColumnTypeDecimal64 = 18,
    ColumnTypeDecimal128i = 19,
    ColumnTypeDecimal256 = 20,
    ColumnTypeIpv4 = 21,
    ColumnTypeIpv6 = 22,
    ColumnTypeTimev2 = 23,
}
impl PColumnType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            PColumnType::ColumnTypeBool => "COLUMN_TYPE_BOOL",
            PColumnType::ColumnTypeInt => "COLUMN_TYPE_INT",
            PColumnType::ColumnTypeTinyInt => "COLUMN_TYPE_TINY_INT",
            PColumnType::ColumnTypeSmallInt => "COLUMN_TYPE_SMALL_INT",
            PColumnType::ColumnTypeBigint => "COLUMN_TYPE_BIGINT",
            PColumnType::ColumnTypeLargeint => "COLUMN_TYPE_LARGEINT",
            PColumnType::ColumnTypeVarchar => "COLUMN_TYPE_VARCHAR",
            PColumnType::ColumnTypeChar => "COLUMN_TYPE_CHAR",
            PColumnType::ColumnTypeDate => "COLUMN_TYPE_DATE",
            PColumnType::ColumnTypeDatetime => "COLUMN_TYPE_DATETIME",
            PColumnType::ColumnTypeDouble => "COLUMN_TYPE_DOUBLE",
            PColumnType::ColumnTypeFloat => "COLUMN_TYPE_FLOAT",
            PColumnType::ColumnTypeDecimal => "COLUMN_TYPE_DECIMAL",
            PColumnType::ColumnTypeDecimalv2 => "COLUMN_TYPE_DECIMALV2",
            PColumnType::ColumnTypeString => "COLUMN_TYPE_STRING",
            PColumnType::ColumnTypeDatev2 => "COLUMN_TYPE_DATEV2",
            PColumnType::ColumnTypeDatetimev2 => "COLUMN_TYPE_DATETIMEV2",
            PColumnType::ColumnTypeDecimal32 => "COLUMN_TYPE_DECIMAL32",
            PColumnType::ColumnTypeDecimal64 => "COLUMN_TYPE_DECIMAL64",
            PColumnType::ColumnTypeDecimal128i => "COLUMN_TYPE_DECIMAL128I",
            PColumnType::ColumnTypeDecimal256 => "COLUMN_TYPE_DECIMAL256",
            PColumnType::ColumnTypeIpv4 => "COLUMN_TYPE_IPV4",
            PColumnType::ColumnTypeIpv6 => "COLUMN_TYPE_IPV6",
            PColumnType::ColumnTypeTimev2 => "COLUMN_TYPE_TIMEV2",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "COLUMN_TYPE_BOOL" => Some(Self::ColumnTypeBool),
            "COLUMN_TYPE_INT" => Some(Self::ColumnTypeInt),
            "COLUMN_TYPE_TINY_INT" => Some(Self::ColumnTypeTinyInt),
            "COLUMN_TYPE_SMALL_INT" => Some(Self::ColumnTypeSmallInt),
            "COLUMN_TYPE_BIGINT" => Some(Self::ColumnTypeBigint),
            "COLUMN_TYPE_LARGEINT" => Some(Self::ColumnTypeLargeint),
            "COLUMN_TYPE_VARCHAR" => Some(Self::ColumnTypeVarchar),
            "COLUMN_TYPE_CHAR" => Some(Self::ColumnTypeChar),
            "COLUMN_TYPE_DATE" => Some(Self::ColumnTypeDate),
            "COLUMN_TYPE_DATETIME" => Some(Self::ColumnTypeDatetime),
            "COLUMN_TYPE_DOUBLE" => Some(Self::ColumnTypeDouble),
            "COLUMN_TYPE_FLOAT" => Some(Self::ColumnTypeFloat),
            "COLUMN_TYPE_DECIMAL" => Some(Self::ColumnTypeDecimal),
            "COLUMN_TYPE_DECIMALV2" => Some(Self::ColumnTypeDecimalv2),
            "COLUMN_TYPE_STRING" => Some(Self::ColumnTypeString),
            "COLUMN_TYPE_DATEV2" => Some(Self::ColumnTypeDatev2),
            "COLUMN_TYPE_DATETIMEV2" => Some(Self::ColumnTypeDatetimev2),
            "COLUMN_TYPE_DECIMAL32" => Some(Self::ColumnTypeDecimal32),
            "COLUMN_TYPE_DECIMAL64" => Some(Self::ColumnTypeDecimal64),
            "COLUMN_TYPE_DECIMAL128I" => Some(Self::ColumnTypeDecimal128i),
            "COLUMN_TYPE_DECIMAL256" => Some(Self::ColumnTypeDecimal256),
            "COLUMN_TYPE_IPV4" => Some(Self::ColumnTypeIpv4),
            "COLUMN_TYPE_IPV6" => Some(Self::ColumnTypeIpv6),
            "COLUMN_TYPE_TIMEV2" => Some(Self::ColumnTypeTimev2),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PFilterType {
    UnknownFilter = 0,
    BloomFilter = 1,
    MinmaxFilter = 2,
    InFilter = 3,
    InOrBloomFilter = 4,
    MinFilter = 5,
    MaxFilter = 6,
}
impl PFilterType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            PFilterType::UnknownFilter => "UNKNOWN_FILTER",
            PFilterType::BloomFilter => "BLOOM_FILTER",
            PFilterType::MinmaxFilter => "MINMAX_FILTER",
            PFilterType::InFilter => "IN_FILTER",
            PFilterType::InOrBloomFilter => "IN_OR_BLOOM_FILTER",
            PFilterType::MinFilter => "MIN_FILTER",
            PFilterType::MaxFilter => "MAX_FILTER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNKNOWN_FILTER" => Some(Self::UnknownFilter),
            "BLOOM_FILTER" => Some(Self::BloomFilter),
            "MINMAX_FILTER" => Some(Self::MinmaxFilter),
            "IN_FILTER" => Some(Self::InFilter),
            "IN_OR_BLOOM_FILTER" => Some(Self::InOrBloomFilter),
            "MIN_FILTER" => Some(Self::MinFilter),
            "MAX_FILTER" => Some(Self::MaxFilter),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FileCacheType {
    Ttl = 0,
    Index = 1,
    Normal = 2,
}
impl FileCacheType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            FileCacheType::Ttl => "TTL",
            FileCacheType::Index => "INDEX",
            FileCacheType::Normal => "NORMAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TTL" => Some(Self::Ttl),
            "INDEX" => Some(Self::Index),
            "NORMAL" => Some(Self::Normal),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod p_backend_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct PBackendServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl PBackendServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> PBackendServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> PBackendServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            PBackendServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// If #fragments of a query is < 3, use exec_plan_fragment directly.
        /// If #fragments of a query is >=3, use exec_plan_fragment_prepare + exec_plan_fragment_start
        pub async fn exec_plan_fragment(
            &mut self,
            request: impl tonic::IntoRequest<super::PExecPlanFragmentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PExecPlanFragmentResult>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/exec_plan_fragment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("doris.PBackendService", "exec_plan_fragment"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn exec_plan_fragment_prepare(
            &mut self,
            request: impl tonic::IntoRequest<super::PExecPlanFragmentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PExecPlanFragmentResult>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/exec_plan_fragment_prepare",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "doris.PBackendService",
                        "exec_plan_fragment_prepare",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn exec_plan_fragment_start(
            &mut self,
            request: impl tonic::IntoRequest<super::PExecPlanFragmentStartRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PExecPlanFragmentResult>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/exec_plan_fragment_start",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("doris.PBackendService", "exec_plan_fragment_start"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn cancel_plan_fragment(
            &mut self,
            request: impl tonic::IntoRequest<super::PCancelPlanFragmentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PCancelPlanFragmentResult>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/cancel_plan_fragment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("doris.PBackendService", "cancel_plan_fragment"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn fetch_data(
            &mut self,
            request: impl tonic::IntoRequest<super::PFetchDataRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PFetchDataResult>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/fetch_data",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("doris.PBackendService", "fetch_data"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn fetch_arrow_data(
            &mut self,
            request: impl tonic::IntoRequest<super::PFetchArrowDataRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PFetchArrowDataResult>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/fetch_arrow_data",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("doris.PBackendService", "fetch_arrow_data"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn tablet_writer_open(
            &mut self,
            request: impl tonic::IntoRequest<super::PTabletWriterOpenRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PTabletWriterOpenResult>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/tablet_writer_open",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("doris.PBackendService", "tablet_writer_open"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn open_load_stream(
            &mut self,
            request: impl tonic::IntoRequest<super::POpenLoadStreamRequest>,
        ) -> std::result::Result<
            tonic::Response<super::POpenLoadStreamResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/open_load_stream",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("doris.PBackendService", "open_load_stream"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn tablet_writer_add_block(
            &mut self,
            request: impl tonic::IntoRequest<super::PTabletWriterAddBlockRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PTabletWriterAddBlockResult>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/tablet_writer_add_block",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("doris.PBackendService", "tablet_writer_add_block"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn tablet_writer_add_block_by_http(
            &mut self,
            request: impl tonic::IntoRequest<super::PEmptyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PTabletWriterAddBlockResult>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/tablet_writer_add_block_by_http",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "doris.PBackendService",
                        "tablet_writer_add_block_by_http",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn tablet_writer_cancel(
            &mut self,
            request: impl tonic::IntoRequest<super::PTabletWriterCancelRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PTabletWriterCancelResult>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/tablet_writer_cancel",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("doris.PBackendService", "tablet_writer_cancel"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_info(
            &mut self,
            request: impl tonic::IntoRequest<super::PProxyRequest>,
        ) -> std::result::Result<tonic::Response<super::PProxyResult>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/get_info",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("doris.PBackendService", "get_info"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn update_cache(
            &mut self,
            request: impl tonic::IntoRequest<super::PUpdateCacheRequest>,
        ) -> std::result::Result<tonic::Response<super::PCacheResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/update_cache",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("doris.PBackendService", "update_cache"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn fetch_cache(
            &mut self,
            request: impl tonic::IntoRequest<super::PFetchCacheRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PFetchCacheResult>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/fetch_cache",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("doris.PBackendService", "fetch_cache"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn clear_cache(
            &mut self,
            request: impl tonic::IntoRequest<super::PClearCacheRequest>,
        ) -> std::result::Result<tonic::Response<super::PCacheResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/clear_cache",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("doris.PBackendService", "clear_cache"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn send_data(
            &mut self,
            request: impl tonic::IntoRequest<super::PSendDataRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PSendDataResult>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/send_data",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("doris.PBackendService", "send_data"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn commit(
            &mut self,
            request: impl tonic::IntoRequest<super::PCommitRequest>,
        ) -> std::result::Result<tonic::Response<super::PCommitResult>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/commit",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("doris.PBackendService", "commit"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn rollback(
            &mut self,
            request: impl tonic::IntoRequest<super::PRollbackRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PRollbackResult>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/rollback",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("doris.PBackendService", "rollback"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn merge_filter(
            &mut self,
            request: impl tonic::IntoRequest<super::PMergeFilterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PMergeFilterResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/merge_filter",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("doris.PBackendService", "merge_filter"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn send_filter_size(
            &mut self,
            request: impl tonic::IntoRequest<super::PSendFilterSizeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PSendFilterSizeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/send_filter_size",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("doris.PBackendService", "send_filter_size"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn sync_filter_size(
            &mut self,
            request: impl tonic::IntoRequest<super::PSyncFilterSizeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PSyncFilterSizeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/sync_filter_size",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("doris.PBackendService", "sync_filter_size"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn apply_filterv2(
            &mut self,
            request: impl tonic::IntoRequest<super::PPublishFilterRequestV2>,
        ) -> std::result::Result<
            tonic::Response<super::PPublishFilterResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/apply_filterv2",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("doris.PBackendService", "apply_filterv2"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn fold_constant_expr(
            &mut self,
            request: impl tonic::IntoRequest<super::PConstantExprRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PConstantExprResult>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/fold_constant_expr",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("doris.PBackendService", "fold_constant_expr"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn transmit_block(
            &mut self,
            request: impl tonic::IntoRequest<super::PTransmitDataParams>,
        ) -> std::result::Result<
            tonic::Response<super::PTransmitDataResult>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/transmit_block",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("doris.PBackendService", "transmit_block"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn transmit_block_by_http(
            &mut self,
            request: impl tonic::IntoRequest<super::PEmptyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PTransmitDataResult>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/transmit_block_by_http",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("doris.PBackendService", "transmit_block_by_http"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn check_rpc_channel(
            &mut self,
            request: impl tonic::IntoRequest<super::PCheckRpcChannelRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PCheckRpcChannelResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/check_rpc_channel",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("doris.PBackendService", "check_rpc_channel"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn reset_rpc_channel(
            &mut self,
            request: impl tonic::IntoRequest<super::PResetRpcChannelRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PResetRpcChannelResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/reset_rpc_channel",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("doris.PBackendService", "reset_rpc_channel"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn hand_shake(
            &mut self,
            request: impl tonic::IntoRequest<super::PHandShakeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PHandShakeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/hand_shake",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("doris.PBackendService", "hand_shake"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn request_slave_tablet_pull_rowset(
            &mut self,
            request: impl tonic::IntoRequest<super::PTabletWriteSlaveRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PTabletWriteSlaveResult>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/request_slave_tablet_pull_rowset",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "doris.PBackendService",
                        "request_slave_tablet_pull_rowset",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn response_slave_tablet_pull_rowset(
            &mut self,
            request: impl tonic::IntoRequest<super::PTabletWriteSlaveDoneRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PTabletWriteSlaveDoneResult>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/response_slave_tablet_pull_rowset",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "doris.PBackendService",
                        "response_slave_tablet_pull_rowset",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn outfile_write_success(
            &mut self,
            request: impl tonic::IntoRequest<super::POutfileWriteSuccessRequest>,
        ) -> std::result::Result<
            tonic::Response<super::POutfileWriteSuccessResult>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/outfile_write_success",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("doris.PBackendService", "outfile_write_success"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn fetch_table_schema(
            &mut self,
            request: impl tonic::IntoRequest<super::PFetchTableSchemaRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PFetchTableSchemaResult>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/fetch_table_schema",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("doris.PBackendService", "fetch_table_schema"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn multiget_data(
            &mut self,
            request: impl tonic::IntoRequest<super::PMultiGetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PMultiGetResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/multiget_data",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("doris.PBackendService", "multiget_data"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn multiget_data_v2(
            &mut self,
            request: impl tonic::IntoRequest<super::PMultiGetRequestV2>,
        ) -> std::result::Result<
            tonic::Response<super::PMultiGetResponseV2>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/multiget_data_v2",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("doris.PBackendService", "multiget_data_v2"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_file_cache_meta_by_tablet_id(
            &mut self,
            request: impl tonic::IntoRequest<super::PGetFileCacheMetaRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PGetFileCacheMetaResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/get_file_cache_meta_by_tablet_id",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "doris.PBackendService",
                        "get_file_cache_meta_by_tablet_id",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn warm_up_rowset(
            &mut self,
            request: impl tonic::IntoRequest<super::PWarmUpRowsetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PWarmUpRowsetResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/warm_up_rowset",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("doris.PBackendService", "warm_up_rowset"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn recycle_cache(
            &mut self,
            request: impl tonic::IntoRequest<super::PRecycleCacheRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PRecycleCacheResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/recycle_cache",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("doris.PBackendService", "recycle_cache"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn tablet_fetch_data(
            &mut self,
            request: impl tonic::IntoRequest<super::PTabletKeyLookupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PTabletKeyLookupResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/tablet_fetch_data",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("doris.PBackendService", "tablet_fetch_data"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_column_ids_by_tablet_ids(
            &mut self,
            request: impl tonic::IntoRequest<super::PFetchColIdsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PFetchColIdsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/get_column_ids_by_tablet_ids",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "doris.PBackendService",
                        "get_column_ids_by_tablet_ids",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_tablet_rowset_versions(
            &mut self,
            request: impl tonic::IntoRequest<super::PGetTabletVersionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PGetTabletVersionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/get_tablet_rowset_versions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "doris.PBackendService",
                        "get_tablet_rowset_versions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn report_stream_load_status(
            &mut self,
            request: impl tonic::IntoRequest<super::PReportStreamLoadStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PReportStreamLoadStatusResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/report_stream_load_status",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("doris.PBackendService", "report_stream_load_status"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn glob(
            &mut self,
            request: impl tonic::IntoRequest<super::PGlobRequest>,
        ) -> std::result::Result<tonic::Response<super::PGlobResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/glob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("doris.PBackendService", "glob"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn group_commit_insert(
            &mut self,
            request: impl tonic::IntoRequest<super::PGroupCommitInsertRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PGroupCommitInsertResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/group_commit_insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("doris.PBackendService", "group_commit_insert"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_wal_queue_size(
            &mut self,
            request: impl tonic::IntoRequest<super::PGetWalQueueSizeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PGetWalQueueSizeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/get_wal_queue_size",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("doris.PBackendService", "get_wal_queue_size"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn fetch_arrow_flight_schema(
            &mut self,
            request: impl tonic::IntoRequest<super::PFetchArrowFlightSchemaRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PFetchArrowFlightSchemaResult>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/fetch_arrow_flight_schema",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("doris.PBackendService", "fetch_arrow_flight_schema"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn fetch_remote_tablet_schema(
            &mut self,
            request: impl tonic::IntoRequest<super::PFetchRemoteSchemaRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PFetchRemoteSchemaResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/fetch_remote_tablet_schema",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "doris.PBackendService",
                        "fetch_remote_tablet_schema",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn test_jdbc_connection(
            &mut self,
            request: impl tonic::IntoRequest<super::PJdbcTestConnectionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PJdbcTestConnectionResult>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/test_jdbc_connection",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("doris.PBackendService", "test_jdbc_connection"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn alter_vault_sync(
            &mut self,
            request: impl tonic::IntoRequest<super::PAlterVaultSyncRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PAlterVaultSyncResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/alter_vault_sync",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("doris.PBackendService", "alter_vault_sync"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_be_resource(
            &mut self,
            request: impl tonic::IntoRequest<super::PGetBeResourceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PGetBeResourceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/get_be_resource",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("doris.PBackendService", "get_be_resource"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete_dictionary(
            &mut self,
            request: impl tonic::IntoRequest<super::PDeleteDictionaryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PDeleteDictionaryResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/delete_dictionary",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("doris.PBackendService", "delete_dictionary"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn commit_refresh_dictionary(
            &mut self,
            request: impl tonic::IntoRequest<super::PCommitRefreshDictionaryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PCommitRefreshDictionaryResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/commit_refresh_dictionary",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("doris.PBackendService", "commit_refresh_dictionary"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn abort_refresh_dictionary(
            &mut self,
            request: impl tonic::IntoRequest<super::PAbortRefreshDictionaryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PAbortRefreshDictionaryResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/abort_refresh_dictionary",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("doris.PBackendService", "abort_refresh_dictionary"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_tablet_rowsets(
            &mut self,
            request: impl tonic::IntoRequest<super::PGetTabletRowsetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PGetTabletRowsetsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/get_tablet_rowsets",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("doris.PBackendService", "get_tablet_rowsets"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn fetch_peer_data(
            &mut self,
            request: impl tonic::IntoRequest<super::PFetchPeerDataRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PFetchPeerDataResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/doris.PBackendService/fetch_peer_data",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("doris.PBackendService", "fetch_peer_data"));
            self.inner.unary(req, path, codec).await
        }
    }
}
